--- /home/V1SCAN/CWE-476/FormattedUsed/cJSON-turicreate-6.4.1.c	2023-12-06 03:45:07.976687542 +0900
+++ /home/V1SCAN/CWE-476/FormattedVul/OLD##CVE-2019-1010239##0##DaveGamble@@cJSON##cJSON.c	2023-12-06 03:45:08.476688375 +0900
@@ -55,11 +55,11 @@
 #pragma GCC visibility pop
 #endif
 
-#include <aws/core/external/cjson/cJSON.h>
+#include "cJSON.h"
 
 /* define our own boolean type */
-// #define true ((cJSON_bool)1)
-// #define false ((cJSON_bool)0)
+#define true((cJSON_bool)1)
+#define false((cJSON_bool)0)
 
 typedef struct {
   const unsigned char *json;
@@ -82,7 +82,7 @@
 /* This is a safeguard to prevent copy-pasters from using incompatible C and
  * header files */
 #if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) ||                \
-    (CJSON_VERSION_PATCH != 7)
+    (CJSON_VERSION_PATCH != 8)
 #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
 #endif
 
@@ -116,17 +116,17 @@
 }
 
 typedef struct internal_hooks {
-  void *(*allocate)(size_t size);
-  void (*deallocate)(void *pointer);
-  void *(*reallocate)(void *pointer, size_t size);
+  void *(CJSON_CDECL *allocate)(size_t size);
+  void(CJSON_CDECL *deallocate)(void *pointer);
+  void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
 } internal_hooks;
 
 #if defined(_MSC_VER)
 /* work around MSVC error C2322: '...' address of dillimport '...' is not static
  */
-static void *internal_malloc(size_t size) { return malloc(size); }
-static void internal_free(void *pointer) { free(pointer); }
-static void *internal_realloc(void *pointer, size_t size) {
+static void *CJSON_CDECL internal_malloc(size_t size) { return malloc(size); }
+static void CJSON_CDECL internal_free(void *pointer) { free(pointer); }
+static void *CJSON_CDECL internal_realloc(void *pointer, size_t size) {
   return realloc(pointer, size);
 }
 #else
@@ -302,7 +302,7 @@
   /* use saturation in case of overflow */
   if (number >= INT_MAX) {
     item->valueint = INT_MAX;
-  } else if (number <= INT_MIN) {
+  } else if (number <= (double)INT_MIN) {
     item->valueint = INT_MIN;
   } else {
     item->valueint = (int)number;
@@ -319,7 +319,7 @@
 CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number) {
   if (number >= INT_MAX) {
     object->valueint = INT_MAX;
-  } else if (number <= INT_MIN) {
+  } else if (number <= (double)INT_MIN) {
     object->valueint = INT_MIN;
   } else {
     object->valueint = (int)number;
@@ -1515,8 +1515,8 @@
     update_offset(output_buffer);
 
     /* print comma if not last */
-    length = (size_t)((output_buffer->format ? 1 : 0) +
-                      (current_item->next ? 1 : 0));
+    length = ((size_t)(output_buffer->format ? 1 : 0) +
+              (size_t)(current_item->next ? 1 : 0));
     output_pointer = ensure(output_buffer, length + 1);
     if (output_pointer == NULL) {
       return false;
@@ -2083,7 +2083,7 @@
     /* use saturation in case of overflow */
     if (num >= INT_MAX) {
       item->valueint = INT_MAX;
-    } else if (num <= INT_MIN) {
+    } else if (num <= (double)INT_MIN) {
       item->valueint = INT_MIN;
     } else {
       item->valueint = (int)num;
