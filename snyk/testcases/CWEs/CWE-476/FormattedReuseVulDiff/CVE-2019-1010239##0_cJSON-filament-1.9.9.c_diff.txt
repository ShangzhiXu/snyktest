--- /home/V1SCAN/CWE-476/FormattedUsed/cJSON-filament-1.9.9.c	2023-12-06 03:45:07.916687445 +0900
+++ /home/V1SCAN/CWE-476/FormattedVul/OLD##CVE-2019-1010239##0##DaveGamble@@cJSON##cJSON.c	2023-12-06 03:45:08.476688375 +0900
@@ -38,7 +38,6 @@
 #endif
 
 #include <ctype.h>
-#include <float.h>
 #include <limits.h>
 #include <math.h>
 #include <stdio.h>
@@ -83,7 +82,7 @@
 /* This is a safeguard to prevent copy-pasters from using incompatible C and
  * header files */
 #if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) ||                \
-    (CJSON_VERSION_PATCH != 5)
+    (CJSON_VERSION_PATCH != 8)
 #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
 #endif
 
@@ -117,17 +116,17 @@
 }
 
 typedef struct internal_hooks {
-  void *(*allocate)(size_t size);
-  void (*deallocate)(void *pointer);
-  void *(*reallocate)(void *pointer, size_t size);
+  void *(CJSON_CDECL *allocate)(size_t size);
+  void(CJSON_CDECL *deallocate)(void *pointer);
+  void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
 } internal_hooks;
 
 #if defined(_MSC_VER)
 /* work around MSVC error C2322: '...' address of dillimport '...' is not static
  */
-static void *internal_malloc(size_t size) { return malloc(size); }
-static void internal_free(void *pointer) { free(pointer); }
-static void *internal_realloc(void *pointer, size_t size) {
+static void *CJSON_CDECL internal_malloc(size_t size) { return malloc(size); }
+static void CJSON_CDECL internal_free(void *pointer) { free(pointer); }
+static void *CJSON_CDECL internal_realloc(void *pointer, size_t size) {
   return realloc(pointer, size);
 }
 #else
@@ -303,7 +302,7 @@
   /* use saturation in case of overflow */
   if (number >= INT_MAX) {
     item->valueint = INT_MAX;
-  } else if (number <= INT_MIN) {
+  } else if (number <= (double)INT_MIN) {
     item->valueint = INT_MIN;
   } else {
     item->valueint = (int)number;
@@ -320,7 +319,7 @@
 CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number) {
   if (number >= INT_MAX) {
     object->valueint = INT_MAX;
-  } else if (number <= INT_MIN) {
+  } else if (number <= (double)INT_MIN) {
     object->valueint = INT_MIN;
   } else {
     object->valueint = (int)number;
@@ -1006,10 +1005,10 @@
   if (hooks->reallocate != NULL) {
     printed =
         (unsigned char *)hooks->reallocate(buffer->buffer, buffer->offset + 1);
-    buffer->buffer = NULL;
     if (printed == NULL) {
       goto fail;
     }
+    buffer->buffer = NULL;
   } else /* otherwise copy the JSON over to a new buffer */
   {
     printed = (unsigned char *)hooks->allocate(buffer->offset + 1);
@@ -1516,8 +1515,8 @@
     update_offset(output_buffer);
 
     /* print comma if not last */
-    length = (size_t)((output_buffer->format ? 1 : 0) +
-                      (current_item->next ? 1 : 0));
+    length = ((size_t)(output_buffer->format ? 1 : 0) +
+              (size_t)(current_item->next ? 1 : 0));
     output_pointer = ensure(output_buffer, length + 1);
     if (output_pointer == NULL) {
       return false;
@@ -2084,7 +2083,7 @@
     /* use saturation in case of overflow */
     if (num >= INT_MAX) {
       item->valueint = INT_MAX;
-    } else if (num <= INT_MIN) {
+    } else if (num <= (double)INT_MIN) {
       item->valueint = INT_MIN;
     } else {
       item->valueint = (int)num;
