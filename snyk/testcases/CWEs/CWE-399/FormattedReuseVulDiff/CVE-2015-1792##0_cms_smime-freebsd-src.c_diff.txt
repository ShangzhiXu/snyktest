--- /home/V1SCAN/CWE-399/FormattedUsed/cms_smime-freebsd-src.c	2023-12-12 05:12:46.168268794 +0900
+++ /home/V1SCAN/CWE-399/FormattedVul/OLD##CVE-2015-1792##0##openssl@@openssl##cms_smime.c	2023-12-12 05:12:46.238269167 +0900
@@ -1,41 +1,79 @@
-/*
- * Copyright 2008-2020 The OpenSSL Project Authors. All Rights Reserved.
+/* crypto/cms/cms_smime.c */
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
+ * project.
+ */
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
  *
- * Licensed under the OpenSSL license (the "License").  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * https://www.openssl.org/source/license.html
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
  */
 
-#include "cms_local.h"
-#include "crypto/asn1.h"
-#include "internal/cryptlib.h"
+#include "asn1_locl.h"
+#include "cms_lcl.h"
+#include "cryptlib.h"
 #include <openssl/asn1t.h>
 #include <openssl/cms.h>
 #include <openssl/err.h>
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
 
-static BIO *cms_get_text_bio(BIO *out, unsigned int flags) {
-  BIO *rbio;
-  if (out == NULL)
-    rbio = BIO_new(BIO_s_null());
-  else if (flags & CMS_TEXT) {
-    rbio = BIO_new(BIO_s_mem());
-    BIO_set_mem_eof_return(rbio, 0);
-  } else
-    rbio = out;
-  return rbio;
-}
-
 static int cms_copy_content(BIO *out, BIO *in, unsigned int flags) {
   unsigned char buf[4096];
   int r = 0, i;
-  BIO *tmpout;
+  BIO *tmpout = NULL;
 
-  tmpout = cms_get_text_bio(out, flags);
+  if (out == NULL)
+    tmpout = BIO_new(BIO_s_null());
+  else if (flags & CMS_TEXT) {
+    tmpout = BIO_new(BIO_s_mem());
+    BIO_set_mem_eof_return(tmpout, 0);
+  } else
+    tmpout = out;
 
-  if (tmpout == NULL) {
+  if (!tmpout) {
     CMSerr(CMS_F_CMS_COPY_CONTENT, ERR_R_MALLOC_FAILURE);
     goto err;
   }
@@ -67,7 +105,7 @@
   r = 1;
 
 err:
-  if (tmpout != out)
+  if (tmpout && (tmpout != out))
     BIO_free(tmpout);
   return r;
 }
@@ -88,7 +126,7 @@
       tbio = BIO_pop(f);
       BIO_free(f);
       f = tbio;
-    } while (f && f != upto);
+    } while (f != upto);
   } else
     BIO_free_all(f);
 }
@@ -195,7 +233,7 @@
     return NULL;
   }
   cms = CMS_ContentInfo_new();
-  if (cms == NULL)
+  if (!cms)
     return NULL;
   if (!CMS_EncryptedData_set1_key(cms, cipher, key, keylen))
     return NULL;
@@ -212,34 +250,30 @@
 
 static int cms_signerinfo_verify_cert(CMS_SignerInfo *si, X509_STORE *store,
                                       STACK_OF(X509) * certs,
-                                      STACK_OF(X509_CRL) * crls) {
-  X509_STORE_CTX *ctx = X509_STORE_CTX_new();
+                                      STACK_OF(X509_CRL) * crls,
+                                      unsigned int flags) {
+  X509_STORE_CTX ctx;
   X509 *signer;
   int i, j, r = 0;
-
-  if (ctx == NULL) {
-    CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
-    goto err;
-  }
   CMS_SignerInfo_get0_algs(si, NULL, &signer, NULL, NULL);
-  if (!X509_STORE_CTX_init(ctx, store, signer, certs)) {
+  if (!X509_STORE_CTX_init(&ctx, store, signer, certs)) {
     CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT, CMS_R_STORE_INIT_ERROR);
     goto err;
   }
-  X509_STORE_CTX_set_default(ctx, "smime_sign");
+  X509_STORE_CTX_set_default(&ctx, "smime_sign");
   if (crls)
-    X509_STORE_CTX_set0_crls(ctx, crls);
+    X509_STORE_CTX_set0_crls(&ctx, crls);
 
-  i = X509_verify_cert(ctx);
+  i = X509_verify_cert(&ctx);
   if (i <= 0) {
-    j = X509_STORE_CTX_get_error(ctx);
+    j = X509_STORE_CTX_get_error(&ctx);
     CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT, CMS_R_CERTIFICATE_VERIFY_ERROR);
     ERR_add_error_data(2, "Verify error:", X509_verify_cert_error_string(j));
     goto err;
   }
   r = 1;
 err:
-  X509_STORE_CTX_free(ctx);
+  X509_STORE_CTX_cleanup(&ctx);
   return r;
 }
 
@@ -251,15 +285,10 @@
   STACK_OF(X509_CRL) *crls = NULL;
   X509 *signer;
   int i, scount = 0, ret = 0;
-  BIO *cmsbio = NULL, *tmpin = NULL, *tmpout = NULL;
+  BIO *cmsbio = NULL, *tmpin = NULL;
 
   if (!dcont && !check_content(cms))
     return 0;
-  if (dcont && !(flags & CMS_BINARY)) {
-    const ASN1_OBJECT *coid = CMS_get0_eContentType(cms);
-    if (OBJ_obj2nid(coid) == NID_id_ct_asciiTextWithCRLF)
-      flags |= CMS_ASCIICRLF;
-  }
 
   /* Attempt to find all signer certificates */
 
@@ -293,7 +322,7 @@
       crls = CMS_get1_crls(cms);
     for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {
       si = sk_CMS_SignerInfo_value(sinfos, i);
-      if (!cms_signerinfo_verify_cert(si, store, cms_certs, crls))
+      if (!cms_signerinfo_verify_cert(si, store, cms_certs, crls, flags))
         goto err;
     }
   }
@@ -310,61 +339,32 @@
     }
   }
 
-  /*
-   * Performance optimization: if the content is a memory BIO then store
-   * its contents in a temporary read only memory BIO. This avoids
-   * potentially large numbers of slow copies of data which will occur when
-   * reading from a read write memory BIO when signatures are calculated.
+  /* Performance optimization: if the content is a memory BIO then
+   * store its contents in a temporary read only memory BIO. This
+   * avoids potentially large numbers of slow copies of data which will
+   * occur when reading from a read write memory BIO when signatures
+   * are calculated.
    */
 
   if (dcont && (BIO_method_type(dcont) == BIO_TYPE_MEM)) {
     char *ptr;
     long len;
     len = BIO_get_mem_data(dcont, &ptr);
-    tmpin = (len == 0) ? dcont : BIO_new_mem_buf(ptr, len);
+    tmpin = BIO_new_mem_buf(ptr, len);
     if (tmpin == NULL) {
       CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
-      goto err2;
+      return 0;
     }
   } else
     tmpin = dcont;
-  /*
-   * If not binary mode and detached generate digests by *writing* through
-   * the BIO. That makes it possible to canonicalise the input.
-   */
-  if (!(flags & SMIME_BINARY) && dcont) {
-    /*
-     * Create output BIO so we can either handle text or to ensure
-     * included content doesn't override detached content.
-     */
-    tmpout = cms_get_text_bio(out, flags);
-    if (!tmpout) {
-      CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
-      goto err;
-    }
-    cmsbio = CMS_dataInit(cms, tmpout);
-    if (!cmsbio)
-      goto err;
-    /*
-     * Don't use SMIME_TEXT for verify: it adds headers and we want to
-     * remove them.
-     */
-    SMIME_crlf_copy(dcont, cmsbio, flags & ~SMIME_TEXT);
 
-    if (flags & CMS_TEXT) {
-      if (!SMIME_text(tmpout, out)) {
-        CMSerr(CMS_F_CMS_VERIFY, CMS_R_SMIME_TEXT_ERROR);
-        goto err;
-      }
-    }
-  } else {
-    cmsbio = CMS_dataInit(cms, tmpin);
-    if (!cmsbio)
-      goto err;
+  cmsbio = CMS_dataInit(cms, tmpin);
+  if (!cmsbio)
+    goto err;
+
+  if (!cms_copy_content(out, cmsbio, flags))
+    goto err;
 
-    if (!cms_copy_content(out, cmsbio, flags))
-      goto err;
-  }
   if (!(flags & CMS_NO_CONTENT_VERIFY)) {
     for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {
       si = sk_CMS_SignerInfo_value(sinfos, i);
@@ -378,23 +378,16 @@
   ret = 1;
 
 err:
-  if (!(flags & SMIME_BINARY) && dcont) {
-    do_free_upto(cmsbio, tmpout);
-    if (tmpin != dcont)
-      BIO_free(tmpin);
-  } else {
-    if (dcont && (tmpin == dcont))
-      do_free_upto(cmsbio, dcont);
-    else
-      BIO_free_all(cmsbio);
-  }
-
-  if (out != tmpout)
-    BIO_free_all(tmpout);
-
-err2:
-  sk_X509_pop_free(cms_certs, X509_free);
-  sk_X509_CRL_pop_free(crls, X509_CRL_free);
+
+  if (dcont && (tmpin == dcont))
+    do_free_upto(cmsbio, dcont);
+  else
+    BIO_free_all(cmsbio);
+
+  if (cms_certs)
+    sk_X509_pop_free(cms_certs, X509_free);
+  if (crls)
+    sk_X509_CRL_pop_free(crls, X509_CRL_free);
 
   return ret;
 }
@@ -417,11 +410,8 @@
   int i;
 
   cms = CMS_ContentInfo_new();
-  if (cms == NULL || !CMS_SignedData_init(cms))
+  if (!cms || !CMS_SignedData_init(cms))
     goto merr;
-  if (flags & CMS_ASCIICRLF &&
-      !CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_ct_asciiTextWithCRLF)))
-    goto err;
 
   if (pkey && !CMS_add1_signer(cms, signcert, pkey, NULL, flags)) {
     CMSerr(CMS_F_CMS_SIGN, CMS_R_ADD_SIGNER_ERROR);
@@ -446,7 +436,8 @@
   CMSerr(CMS_F_CMS_SIGN, ERR_R_MALLOC_FAILURE);
 
 err:
-  CMS_ContentInfo_free(cms);
+  if (cms)
+    CMS_ContentInfo_free(cms);
   return NULL;
 }
 
@@ -509,7 +500,8 @@
   r = 1;
 
 err:
-  BIO_free(rct_cont);
+  if (rct_cont)
+    BIO_free(rct_cont);
   if (r)
     return cms;
   CMS_ContentInfo_free(cms);
@@ -543,7 +535,8 @@
 merr:
   CMSerr(CMS_F_CMS_ENCRYPT, ERR_R_MALLOC_FAILURE);
 err:
-  CMS_ContentInfo_free(cms);
+  if (cms)
+    CMS_ContentInfo_free(cms);
   return NULL;
 }
 
@@ -553,17 +546,19 @@
   STACK_OF(CMS_RecipientEncryptedKey) * reks;
   CMS_RecipientEncryptedKey *rek;
   reks = CMS_RecipientInfo_kari_get0_reks(ri);
+  if (!cert)
+    return 0;
   for (i = 0; i < sk_CMS_RecipientEncryptedKey_num(reks); i++) {
     int rv;
     rek = sk_CMS_RecipientEncryptedKey_value(reks, i);
-    if (cert != NULL && CMS_RecipientEncryptedKey_cert_cmp(rek, cert))
+    if (CMS_RecipientEncryptedKey_cert_cmp(rek, cert))
       continue;
     CMS_RecipientInfo_kari_set0_pkey(ri, pk);
     rv = CMS_RecipientInfo_kari_decrypt(cms, ri, rek);
     CMS_RecipientInfo_kari_set0_pkey(ri, NULL);
     if (rv > 0)
       return 1;
-    return cert == NULL ? 0 : -1;
+    return -1;
   }
   return 0;
 }
@@ -572,7 +567,7 @@
   STACK_OF(CMS_RecipientInfo) * ris;
   CMS_RecipientInfo *ri;
   int i, r, ri_type;
-  int debug = 0, match_ri = 0;
+  int debug = 0;
   ris = CMS_get0_RecipientInfos(cms);
   if (ris)
     debug = cms->d.envelopedData->encryptedContentInfo->debug;
@@ -586,7 +581,6 @@
     ri = sk_CMS_RecipientInfo_value(ris, i);
     if (CMS_RecipientInfo_type(ri) != ri_type)
       continue;
-    match_ri = 1;
     if (ri_type == CMS_RECIPINFO_AGREE) {
       r = cms_kari_set1_pkey(cms, ri, pk, cert);
       if (r > 0)
@@ -594,19 +588,17 @@
       if (r < 0)
         return 0;
     }
-    /*
-     * If we have a cert try matching RecipientInfo otherwise try them
-     * all.
+    /* If we have a cert try matching RecipientInfo
+     * otherwise try them all.
      */
     else if (!cert || !CMS_RecipientInfo_ktri_cert_cmp(ri, cert)) {
-      EVP_PKEY_up_ref(pk);
       CMS_RecipientInfo_set0_pkey(ri, pk);
       r = CMS_RecipientInfo_decrypt(cms, ri);
       CMS_RecipientInfo_set0_pkey(ri, NULL);
       if (cert) {
-        /*
-         * If not debugging clear any error and return success to
-         * avoid leaking of information useful to MMA
+        /* If not debugging clear any error and
+         * return success to avoid leaking of
+         * information useful to MMA
          */
         if (!debug) {
           ERR_clear_error();
@@ -617,17 +609,17 @@
         CMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY, CMS_R_DECRYPT_ERROR);
         return 0;
       }
-      /*
-       * If no cert and not debugging don't leave loop after first
-       * successful decrypt. Always attempt to decrypt all recipients
-       * to avoid leaking timing of a successful decrypt.
+      /* If no cert and not debugging don't leave loop
+       * after first successful decrypt. Always attempt
+       * to decrypt all recipients to avoid leaking timing
+       * of a successful decrypt.
        */
       else if (r > 0 && debug)
         return 1;
     }
   }
-  /* If no cert, key transport and not debugging always return success */
-  if (cert == NULL && ri_type == CMS_RECIPINFO_TRANS && match_ri && !debug) {
+  /* If no cert and not debugging always return success */
+  if (!cert && !debug) {
     ERR_clear_error();
     return 1;
   }
@@ -637,7 +629,7 @@
 }
 
 int CMS_decrypt_set1_key(CMS_ContentInfo *cms, unsigned char *key,
-                         size_t keylen, const unsigned char *id, size_t idlen) {
+                         size_t keylen, unsigned char *id, size_t idlen) {
   STACK_OF(CMS_RecipientInfo) * ris;
   CMS_RecipientInfo *ri;
   int i, r;
@@ -647,9 +639,8 @@
     if (CMS_RecipientInfo_type(ri) != CMS_RECIPINFO_KEK)
       continue;
 
-    /*
-     * If we have an id try matching RecipientInfo otherwise try them
-     * all.
+    /* If we have an id try matching RecipientInfo
+     * otherwise try them all.
      */
     if (!id || (CMS_RecipientInfo_kekri_id_cmp(ri, id, idlen) == 0)) {
       CMS_RecipientInfo_set0_key(ri, key, keylen);
@@ -704,10 +695,6 @@
     cms->d.envelopedData->encryptedContentInfo->debug = 1;
   else
     cms->d.envelopedData->encryptedContentInfo->debug = 0;
-  if (!cert)
-    cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
-  else
-    cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
   if (!pk && !cert && !dcont && !out)
     return 1;
   if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
@@ -723,9 +710,8 @@
 int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags) {
   BIO *cmsbio;
   int ret = 0;
-
-  if ((cmsbio = CMS_dataInit(cms, dcont)) == NULL) {
-    CMSerr(CMS_F_CMS_FINAL, CMS_R_CMS_LIB);
+  if (!(cmsbio = CMS_dataInit(cms, dcont))) {
+    CMSerr(CMS_F_CMS_FINAL, ERR_R_MALLOC_FAILURE);
     return 0;
   }
 
