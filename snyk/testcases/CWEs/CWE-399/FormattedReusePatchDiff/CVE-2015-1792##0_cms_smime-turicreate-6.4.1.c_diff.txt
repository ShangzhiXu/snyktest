--- /home/V1SCAN/CWE-399/FormattedUsed/cms_smime-turicreate-6.4.1.c	2023-12-12 05:12:42.098286713 +0900
+++ /home/V1SCAN/CWE-399/FormattedPatch/NEW##CVE-2015-1792##0##openssl@@openssl##cms_smime.c	2023-12-12 05:12:42.148285187 +0900
@@ -1,10 +1,9 @@
 /* crypto/cms/cms_smime.c */
-/*
- * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
  * project.
  */
 /* ====================================================================
- * Copyright (c) 2008-2019 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -61,18 +60,24 @@
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
 
+static BIO *cms_get_text_bio(BIO *out, unsigned int flags) {
+  BIO *rbio;
+  if (out == NULL)
+    rbio = BIO_new(BIO_s_null());
+  else if (flags & CMS_TEXT) {
+    rbio = BIO_new(BIO_s_mem());
+    BIO_set_mem_eof_return(rbio, 0);
+  } else
+    rbio = out;
+  return rbio;
+}
+
 static int cms_copy_content(BIO *out, BIO *in, unsigned int flags) {
   unsigned char buf[4096];
   int r = 0, i;
-  BIO *tmpout = NULL;
+  BIO *tmpout;
 
-  if (out == NULL)
-    tmpout = BIO_new(BIO_s_null());
-  else if (flags & CMS_TEXT) {
-    tmpout = BIO_new(BIO_s_mem());
-    BIO_set_mem_eof_return(tmpout, 0);
-  } else
-    tmpout = out;
+  tmpout = cms_get_text_bio(out, flags);
 
   if (!tmpout) {
     CMSerr(CMS_F_CMS_COPY_CONTENT, ERR_R_MALLOC_FAILURE);
@@ -286,7 +291,7 @@
   STACK_OF(X509_CRL) *crls = NULL;
   X509 *signer;
   int i, scount = 0, ret = 0;
-  BIO *cmsbio = NULL, *tmpin = NULL;
+  BIO *cmsbio = NULL, *tmpin = NULL, *tmpout = NULL;
 
   if (!dcont && !check_content(cms))
     return 0;
@@ -340,11 +345,11 @@
     }
   }
 
-  /*
-   * Performance optimization: if the content is a memory BIO then store
-   * its contents in a temporary read only memory BIO. This avoids
-   * potentially large numbers of slow copies of data which will occur when
-   * reading from a read write memory BIO when signatures are calculated.
+  /* Performance optimization: if the content is a memory BIO then
+   * store its contents in a temporary read only memory BIO. This
+   * avoids potentially large numbers of slow copies of data which will
+   * occur when reading from a read write memory BIO when signatures
+   * are calculated.
    */
 
   if (dcont && (BIO_method_type(dcont) == BIO_TYPE_MEM)) {
@@ -354,18 +359,45 @@
     tmpin = BIO_new_mem_buf(ptr, len);
     if (tmpin == NULL) {
       CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
-      goto err2;
+      return 0;
     }
   } else
     tmpin = dcont;
+  /* If not binary mode and detached generate digests by *writing*
+   * through the BIO. That makes it possible to canonicalise the
+   * input.
+   */
+  if (!(flags & SMIME_BINARY) && dcont) {
+    /* Create output BIO so we can either handle text or to
+     * ensure included content doesn't override detached content.
+     */
+    tmpout = cms_get_text_bio(out, flags);
+    if (!tmpout) {
+      CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
+      goto err;
+    }
+    cmsbio = CMS_dataInit(cms, tmpout);
+    if (!cmsbio)
+      goto err;
+    /* Don't use SMIME_TEXT for verify: it adds headers and
+     * we want to remove them.
+     */
+    SMIME_crlf_copy(dcont, cmsbio, flags & ~SMIME_TEXT);
 
-  cmsbio = CMS_dataInit(cms, tmpin);
-  if (!cmsbio)
-    goto err;
-
-  if (!cms_copy_content(out, cmsbio, flags))
-    goto err;
+    if (flags & CMS_TEXT) {
+      if (!SMIME_text(tmpout, out)) {
+        CMSerr(CMS_F_CMS_VERIFY, CMS_R_SMIME_TEXT_ERROR);
+        goto err;
+      }
+    }
+  } else {
+    cmsbio = CMS_dataInit(cms, tmpin);
+    if (!cmsbio)
+      goto err;
 
+    if (!cms_copy_content(out, cmsbio, flags))
+      goto err;
+  }
   if (!(flags & CMS_NO_CONTENT_VERIFY)) {
     for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {
       si = sk_CMS_SignerInfo_value(sinfos, i);
@@ -379,13 +411,21 @@
   ret = 1;
 
 err:
+  if (!(flags & SMIME_BINARY) && dcont) {
+    do_free_upto(cmsbio, tmpout);
+    if (tmpin != dcont)
+      BIO_free(tmpin);
+  } else {
+
+    if (dcont && (tmpin == dcont))
+      do_free_upto(cmsbio, dcont);
+    else
+      BIO_free_all(cmsbio);
+  }
 
-  if (dcont && (tmpin == dcont))
-    do_free_upto(cmsbio, dcont);
-  else
-    BIO_free_all(cmsbio);
+  if (tmpout && out != tmpout)
+    BIO_free_all(tmpout);
 
-err2:
   if (cms_certs)
     sk_X509_pop_free(cms_certs, X509_free);
   if (crls)
@@ -569,7 +609,7 @@
   STACK_OF(CMS_RecipientInfo) * ris;
   CMS_RecipientInfo *ri;
   int i, r, ri_type;
-  int debug = 0, match_ri = 0;
+  int debug = 0;
   ris = CMS_get0_RecipientInfos(cms);
   if (ris)
     debug = cms->d.envelopedData->encryptedContentInfo->debug;
@@ -583,7 +623,6 @@
     ri = sk_CMS_RecipientInfo_value(ris, i);
     if (CMS_RecipientInfo_type(ri) != ri_type)
       continue;
-    match_ri = 1;
     if (ri_type == CMS_RECIPINFO_AGREE) {
       r = cms_kari_set1_pkey(cms, ri, pk, cert);
       if (r > 0)
@@ -591,18 +630,17 @@
       if (r < 0)
         return 0;
     }
-    /*
-     * If we have a cert try matching RecipientInfo otherwise try them
-     * all.
+    /* If we have a cert try matching RecipientInfo
+     * otherwise try them all.
      */
     else if (!cert || !CMS_RecipientInfo_ktri_cert_cmp(ri, cert)) {
       CMS_RecipientInfo_set0_pkey(ri, pk);
       r = CMS_RecipientInfo_decrypt(cms, ri);
       CMS_RecipientInfo_set0_pkey(ri, NULL);
       if (cert) {
-        /*
-         * If not debugging clear any error and return success to
-         * avoid leaking of information useful to MMA
+        /* If not debugging clear any error and
+         * return success to avoid leaking of
+         * information useful to MMA
          */
         if (!debug) {
           ERR_clear_error();
@@ -613,17 +651,17 @@
         CMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY, CMS_R_DECRYPT_ERROR);
         return 0;
       }
-      /*
-       * If no cert and not debugging don't leave loop after first
-       * successful decrypt. Always attempt to decrypt all recipients
-       * to avoid leaking timing of a successful decrypt.
+      /* If no cert and not debugging don't leave loop
+       * after first successful decrypt. Always attempt
+       * to decrypt all recipients to avoid leaking timing
+       * of a successful decrypt.
        */
       else if (r > 0 && debug)
         return 1;
     }
   }
   /* If no cert and not debugging always return success */
-  if (match_ri && !cert && !debug) {
+  if (!cert && !debug) {
     ERR_clear_error();
     return 1;
   }
@@ -643,9 +681,8 @@
     if (CMS_RecipientInfo_type(ri) != CMS_RECIPINFO_KEK)
       continue;
 
-    /*
-     * If we have an id try matching RecipientInfo otherwise try them
-     * all.
+    /* If we have an id try matching RecipientInfo
+     * otherwise try them all.
      */
     if (!id || (CMS_RecipientInfo_kekri_id_cmp(ri, id, idlen) == 0)) {
       CMS_RecipientInfo_set0_key(ri, key, keylen);
@@ -700,10 +737,6 @@
     cms->d.envelopedData->encryptedContentInfo->debug = 1;
   else
     cms->d.envelopedData->encryptedContentInfo->debug = 0;
-  if (!cert)
-    cms->d.envelopedData->encryptedContentInfo->havenocert = 1;
-  else
-    cms->d.envelopedData->encryptedContentInfo->havenocert = 0;
   if (!pk && !cert && !dcont && !out)
     return 1;
   if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))
@@ -720,7 +753,7 @@
   BIO *cmsbio;
   int ret = 0;
   if (!(cmsbio = CMS_dataInit(cms, dcont))) {
-    CMSerr(CMS_F_CMS_FINAL, CMS_R_CMS_LIB);
+    CMSerr(CMS_F_CMS_FINAL, ERR_R_MALLOC_FAILURE);
     return 0;
   }
 
