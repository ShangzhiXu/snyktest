--- /home/V1SCAN/CWE-125/FormattedUsed/rdppm-reactos-0.4.13.c	2023-12-10 02:51:50.558373444 +0900
+++ /home/V1SCAN/CWE-125/FormattedPatch/NEW##CVE-2018-14498##0##libjpeg-turbo@@libjpeg-turbo##rdppm.c	2023-12-10 02:51:51.728364276 +0900
@@ -1,10 +1,13 @@
 /*
  * rdppm.c
  *
+ * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2009-2017 by Bill Allombert, Guido Vollbeding.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
+ * Modified 2009 by Bill Allombert, Guido Vollbeding.
+ * libjpeg-turbo Modifications:
+ * Copyright (C) 2015-2017, D. R. Commander.
+ * For conditions of distribution and use, see the accompanying README.ijg
+ * file.
  *
  * This file contains routines to read input images in PPM/PGM format.
  * The extended 2-byte-per-sample raw PPM/PGM formats are supported.
@@ -20,6 +23,7 @@
  */
 
 #include "cdjpeg.h" /* Common decls for cjpeg/djpeg applications */
+#include "cmyk.h"
 
 #ifdef PPM_SUPPORTED
 
@@ -41,7 +45,7 @@
 typedef unsigned char U_CHAR;
 #define UCH(x) ((int)(x))
 #else /* !HAVE_UNSIGNED_CHAR */
-#ifdef CHAR_IS_UNSIGNED
+#ifdef __CHAR_UNSIGNED__
 typedef char U_CHAR;
 #define UCH(x) ((int)(x))
 #else
@@ -52,23 +56,17 @@
 
 #define ReadOK(file, buffer, len) (JFREAD(file, buffer, len) == ((size_t)(len)))
 
-/*
- * On most systems, reading individual bytes with getc() is drastically less
- * efficient than buffering a row at a time with fread().  On PCs, we must
- * allocate the buffer in near data space, because we are assuming small-data
- * memory model, wherein fread() can't reach far memory.  If you need to
- * process very wide images on a PC, you might have to compile in large-memory
- * model, or else replace fread() with a getc() loop --- which will be much
- * slower.
- */
+static int alpha_index[JPEG_NUMCS] = {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+                                      -1, -1, -1, 3,  3,  0,  0,  -1};
 
 /* Private version of data source object */
 
 typedef struct {
   struct cjpeg_source_struct pub; /* public fields */
 
-  U_CHAR *iobuffer;    /* non-FAR pointer to I/O buffer */
-  JSAMPROW pixrow;     /* FAR pointer to same */
+  /* Usually these two pointers point to the same place: */
+  U_CHAR *iobuffer;    /* fread's I/O buffer */
+  JSAMPROW pixrow;     /* compressor input buffer */
   size_t buffer_width; /* width of I/O buffer */
   JSAMPLE *rescale;    /* => maxval-remapping array, or NULL */
   unsigned int maxval;
@@ -93,7 +91,7 @@
 }
 
 LOCAL(unsigned int)
-read_pbm_integer(j_compress_ptr cinfo, FILE *infile)
+read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)
 /* Read an unsigned decimal integer from the PPM file */
 /* Swallows one trailing character after the integer */
 /* Note that on a 16-bit-int machine, only values up to 64k can be read. */
@@ -117,6 +115,10 @@
     val *= 10;
     val += ch - '0';
   }
+
+  if (val > maxval)
+    ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
+
   return val;
 }
 
@@ -138,20 +140,97 @@
   FILE *infile = source->pub.input_file;
   register JSAMPROW ptr;
   register JSAMPLE *rescale = source->rescale;
-  unsigned int maxval = source->maxval;
   JDIMENSION col;
+  unsigned int maxval = source->maxval;
 
   ptr = source->pub.buffer[0];
   for (col = cinfo->image_width; col > 0; col--) {
-    register unsigned int temp;
-    temp = read_pbm_integer(cinfo, infile);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
+    *ptr++ = rescale[read_pbm_integer(cinfo, infile, maxval)];
   }
   return 1;
 }
 
+#define GRAY_RGB_READ_LOOP(read_op, alpha_set_op)                              \
+  {                                                                            \
+    for (col = cinfo->image_width; col > 0; col--) {                           \
+      ptr[rindex] = ptr[gindex] = ptr[bindex] = read_op;                       \
+      alpha_set_op ptr += ps;                                                  \
+    }                                                                          \
+  }
+
+METHODDEF(JDIMENSION)
+get_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+/* This version is for reading text-format PGM files with any maxval and
+   converting to extended RGB */
+{
+  ppm_source_ptr source = (ppm_source_ptr)sinfo;
+  FILE *infile = source->pub.input_file;
+  register JSAMPROW ptr;
+  register JSAMPLE *rescale = source->rescale;
+  JDIMENSION col;
+  unsigned int maxval = source->maxval;
+  register int rindex = rgb_red[cinfo->in_color_space];
+  register int gindex = rgb_green[cinfo->in_color_space];
+  register int bindex = rgb_blue[cinfo->in_color_space];
+  register int aindex = alpha_index[cinfo->in_color_space];
+  register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+  ptr = source->pub.buffer[0];
+  if (maxval == MAXJSAMPLE) {
+    if (aindex >= 0)
+      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),
+                         ptr[aindex] = 0xFF;)
+    else
+      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval), )
+  } else {
+    if (aindex >= 0)
+      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],
+                         ptr[aindex] = 0xFF;)
+    else
+      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)], )
+  }
+  return 1;
+}
+
+METHODDEF(JDIMENSION)
+get_text_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+/* This version is for reading text-format PGM files with any maxval and
+   converting to CMYK */
+{
+  ppm_source_ptr source = (ppm_source_ptr)sinfo;
+  FILE *infile = source->pub.input_file;
+  register JSAMPROW ptr;
+  register JSAMPLE *rescale = source->rescale;
+  JDIMENSION col;
+  unsigned int maxval = source->maxval;
+
+  ptr = source->pub.buffer[0];
+  if (maxval == MAXJSAMPLE) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE gray = read_pbm_integer(cinfo, infile, maxval);
+      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
+  } else {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE gray = rescale[read_pbm_integer(cinfo, infile, maxval)];
+      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
+  }
+  return 1;
+}
+
+#define RGB_READ_LOOP(read_op, alpha_set_op)                                   \
+  {                                                                            \
+    for (col = cinfo->image_width; col > 0; col--) {                           \
+      ptr[rindex] = read_op;                                                   \
+      ptr[gindex] = read_op;                                                   \
+      ptr[bindex] = read_op;                                                   \
+      alpha_set_op ptr += ps;                                                  \
+    }                                                                          \
+  }
+
 METHODDEF(JDIMENSION)
 get_text_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
 /* This version is for reading text-format PPM files with any maxval */
@@ -160,24 +239,60 @@
   FILE *infile = source->pub.input_file;
   register JSAMPROW ptr;
   register JSAMPLE *rescale = source->rescale;
+  JDIMENSION col;
   unsigned int maxval = source->maxval;
+  register int rindex = rgb_red[cinfo->in_color_space];
+  register int gindex = rgb_green[cinfo->in_color_space];
+  register int bindex = rgb_blue[cinfo->in_color_space];
+  register int aindex = alpha_index[cinfo->in_color_space];
+  register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+  ptr = source->pub.buffer[0];
+  if (maxval == MAXJSAMPLE) {
+    if (aindex >= 0)
+      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),
+                    ptr[aindex] = 0xFF;)
+    else
+      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval), )
+  } else {
+    if (aindex >= 0)
+      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],
+                    ptr[aindex] = 0xFF;)
+    else
+      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)], )
+  }
+  return 1;
+}
+
+METHODDEF(JDIMENSION)
+get_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+/* This version is for reading text-format PPM files with any maxval and
+   converting to CMYK */
+{
+  ppm_source_ptr source = (ppm_source_ptr)sinfo;
+  FILE *infile = source->pub.input_file;
+  register JSAMPROW ptr;
+  register JSAMPLE *rescale = source->rescale;
   JDIMENSION col;
+  unsigned int maxval = source->maxval;
 
   ptr = source->pub.buffer[0];
-  for (col = cinfo->image_width; col > 0; col--) {
-    register unsigned int temp;
-    temp = read_pbm_integer(cinfo, infile);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
-    temp = read_pbm_integer(cinfo, infile);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
-    temp = read_pbm_integer(cinfo, infile);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
+  if (maxval == MAXJSAMPLE) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE r = read_pbm_integer(cinfo, infile, maxval);
+      JSAMPLE g = read_pbm_integer(cinfo, infile, maxval);
+      JSAMPLE b = read_pbm_integer(cinfo, infile, maxval);
+      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
+  } else {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];
+      JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];
+      JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];
+      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
   }
   return 1;
 }
@@ -190,7 +305,6 @@
   register JSAMPROW ptr;
   register U_CHAR *bufferptr;
   register JSAMPLE *rescale = source->rescale;
-  unsigned int maxval = source->maxval;
   JDIMENSION col;
 
   if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
@@ -198,44 +312,144 @@
   ptr = source->pub.buffer[0];
   bufferptr = source->iobuffer;
   for (col = cinfo->image_width; col > 0; col--) {
-    register unsigned int temp;
-    temp = (unsigned int)UCH(*bufferptr++);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
+    *ptr++ = rescale[UCH(*bufferptr++)];
   }
   return 1;
 }
 
 METHODDEF(JDIMENSION)
-get_scaled_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+get_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+/* This version is for reading raw-byte-format PGM files with any maxval
+   and converting to extended RGB */
+{
+  ppm_source_ptr source = (ppm_source_ptr)sinfo;
+  register JSAMPROW ptr;
+  register U_CHAR *bufferptr;
+  register JSAMPLE *rescale = source->rescale;
+  JDIMENSION col;
+  unsigned int maxval = source->maxval;
+  register int rindex = rgb_red[cinfo->in_color_space];
+  register int gindex = rgb_green[cinfo->in_color_space];
+  register int bindex = rgb_blue[cinfo->in_color_space];
+  register int aindex = alpha_index[cinfo->in_color_space];
+  register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
+    ERREXIT(cinfo, JERR_INPUT_EOF);
+  ptr = source->pub.buffer[0];
+  bufferptr = source->iobuffer;
+  if (maxval == MAXJSAMPLE) {
+    if (aindex >= 0)
+      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)
+    else
+      GRAY_RGB_READ_LOOP(*bufferptr++, )
+  } else {
+    if (aindex >= 0)
+      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)
+    else
+      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], )
+  }
+  return 1;
+}
+
+METHODDEF(JDIMENSION)
+get_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+/* This version is for reading raw-byte-format PGM files with any maxval
+   and converting to CMYK */
+{
+  ppm_source_ptr source = (ppm_source_ptr)sinfo;
+  register JSAMPROW ptr;
+  register U_CHAR *bufferptr;
+  register JSAMPLE *rescale = source->rescale;
+  JDIMENSION col;
+  unsigned int maxval = source->maxval;
+
+  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
+    ERREXIT(cinfo, JERR_INPUT_EOF);
+  ptr = source->pub.buffer[0];
+  bufferptr = source->iobuffer;
+  if (maxval == MAXJSAMPLE) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE gray = *bufferptr++;
+      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
+  } else {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE gray = rescale[UCH(*bufferptr++)];
+      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
+  }
+  return 1;
+}
+
+METHODDEF(JDIMENSION)
+get_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
 /* This version is for reading raw-byte-format PPM files with any maxval */
 {
   ppm_source_ptr source = (ppm_source_ptr)sinfo;
   register JSAMPROW ptr;
   register U_CHAR *bufferptr;
   register JSAMPLE *rescale = source->rescale;
+  JDIMENSION col;
   unsigned int maxval = source->maxval;
+  register int rindex = rgb_red[cinfo->in_color_space];
+  register int gindex = rgb_green[cinfo->in_color_space];
+  register int bindex = rgb_blue[cinfo->in_color_space];
+  register int aindex = alpha_index[cinfo->in_color_space];
+  register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
+    ERREXIT(cinfo, JERR_INPUT_EOF);
+  ptr = source->pub.buffer[0];
+  bufferptr = source->iobuffer;
+  if (maxval == MAXJSAMPLE) {
+    if (aindex >= 0)
+      RGB_READ_LOOP(*bufferptr++, ptr[aindex] = 0xFF;)
+    else
+      RGB_READ_LOOP(*bufferptr++, )
+  } else {
+    if (aindex >= 0)
+      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = 0xFF;)
+    else
+      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], )
+  }
+  return 1;
+}
+
+METHODDEF(JDIMENSION)
+get_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
+/* This version is for reading raw-byte-format PPM files with any maxval and
+   converting to CMYK */
+{
+  ppm_source_ptr source = (ppm_source_ptr)sinfo;
+  register JSAMPROW ptr;
+  register U_CHAR *bufferptr;
+  register JSAMPLE *rescale = source->rescale;
   JDIMENSION col;
+  unsigned int maxval = source->maxval;
 
   if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
     ERREXIT(cinfo, JERR_INPUT_EOF);
   ptr = source->pub.buffer[0];
   bufferptr = source->iobuffer;
-  for (col = cinfo->image_width; col > 0; col--) {
-    register unsigned int temp;
-    temp = (unsigned int)UCH(*bufferptr++);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
-    temp = (unsigned int)UCH(*bufferptr++);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
-    temp = (unsigned int)UCH(*bufferptr++);
-    if (temp > maxval)
-      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-    *ptr++ = rescale[temp];
+  if (maxval == MAXJSAMPLE) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE r = *bufferptr++;
+      JSAMPLE g = *bufferptr++;
+      JSAMPLE b = *bufferptr++;
+      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
+  } else {
+    for (col = cinfo->image_width; col > 0; col--) {
+      JSAMPLE r = rescale[UCH(*bufferptr++)];
+      JSAMPLE g = rescale[UCH(*bufferptr++)];
+      JSAMPLE b = rescale[UCH(*bufferptr++)];
+      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);
+      ptr += 4;
+    }
   }
   return 1;
 }
@@ -262,8 +476,8 @@
   register JSAMPROW ptr;
   register U_CHAR *bufferptr;
   register JSAMPLE *rescale = source->rescale;
-  unsigned int maxval = source->maxval;
   JDIMENSION col;
+  unsigned int maxval = source->maxval;
 
   if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
     ERREXIT(cinfo, JERR_INPUT_EOF);
@@ -271,8 +485,8 @@
   bufferptr = source->iobuffer;
   for (col = cinfo->image_width; col > 0; col--) {
     register unsigned int temp;
-    temp = ((unsigned int)UCH(*bufferptr++)) << 8;
-    temp |= (unsigned int)UCH(*bufferptr++);
+    temp = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     if (temp > maxval)
       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
     *ptr++ = rescale[temp];
@@ -288,8 +502,8 @@
   register JSAMPROW ptr;
   register U_CHAR *bufferptr;
   register JSAMPLE *rescale = source->rescale;
-  unsigned int maxval = source->maxval;
   JDIMENSION col;
+  unsigned int maxval = source->maxval;
 
   if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
     ERREXIT(cinfo, JERR_INPUT_EOF);
@@ -297,18 +511,18 @@
   bufferptr = source->iobuffer;
   for (col = cinfo->image_width; col > 0; col--) {
     register unsigned int temp;
-    temp = ((unsigned int)UCH(*bufferptr++)) << 8;
-    temp |= (unsigned int)UCH(*bufferptr++);
+    temp = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     if (temp > maxval)
       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
     *ptr++ = rescale[temp];
-    temp = ((unsigned int)UCH(*bufferptr++)) << 8;
-    temp |= (unsigned int)UCH(*bufferptr++);
+    temp = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     if (temp > maxval)
       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
     *ptr++ = rescale[temp];
-    temp = ((unsigned int)UCH(*bufferptr++)) << 8;
-    temp |= (unsigned int)UCH(*bufferptr++);
+    temp = UCH(*bufferptr++) << 8;
+    temp |= UCH(*bufferptr++);
     if (temp > maxval)
       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
     *ptr++ = rescale[temp];
@@ -345,17 +559,13 @@
   }
 
   /* fetch the remaining header info */
-  w = read_pbm_integer(cinfo, source->pub.input_file);
-  h = read_pbm_integer(cinfo, source->pub.input_file);
-  maxval = read_pbm_integer(cinfo, source->pub.input_file);
+  w = read_pbm_integer(cinfo, source->pub.input_file, 65535);
+  h = read_pbm_integer(cinfo, source->pub.input_file, 65535);
+  maxval = read_pbm_integer(cinfo, source->pub.input_file, 65535);
 
   if (w <= 0 || h <= 0 || maxval <= 0) /* error check */
     ERREXIT(cinfo, JERR_PPM_NOT);
 
-  if (((long)w >> 24) ||    /* sanity check for buffer allocation below */
-      ((long)maxval >> 16)) /* support max 16-bit (2-byte) sample values */
-    ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
-
   cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */
   cinfo->image_width = (JDIMENSION)w;
   cinfo->image_height = (JDIMENSION)h;
@@ -368,57 +578,98 @@
 
   switch (c) {
   case '2': /* it's a text-format PGM file */
-    cinfo->input_components = 1;
-    cinfo->in_color_space = JCS_GRAYSCALE;
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_GRAYSCALE;
     TRACEMS2(cinfo, 1, JTRC_PGM_TEXT, w, h);
-    source->pub.get_pixel_rows = get_text_gray_row;
+    if (cinfo->in_color_space == JCS_GRAYSCALE)
+      source->pub.get_pixel_rows = get_text_gray_row;
+    else if (IsExtRGB(cinfo->in_color_space))
+      source->pub.get_pixel_rows = get_text_gray_rgb_row;
+    else if (cinfo->in_color_space == JCS_CMYK)
+      source->pub.get_pixel_rows = get_text_gray_cmyk_row;
+    else
+      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     need_iobuffer = FALSE;
     break;
 
   case '3': /* it's a text-format PPM file */
-    cinfo->input_components = 3;
-    cinfo->in_color_space = JCS_RGB;
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_EXT_RGB;
     TRACEMS2(cinfo, 1, JTRC_PPM_TEXT, w, h);
-    source->pub.get_pixel_rows = get_text_rgb_row;
+    if (IsExtRGB(cinfo->in_color_space))
+      source->pub.get_pixel_rows = get_text_rgb_row;
+    else if (cinfo->in_color_space == JCS_CMYK)
+      source->pub.get_pixel_rows = get_text_rgb_cmyk_row;
+    else
+      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     need_iobuffer = FALSE;
     break;
 
   case '5': /* it's a raw-format PGM file */
-    cinfo->input_components = 1;
-    cinfo->in_color_space = JCS_GRAYSCALE;
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_GRAYSCALE;
     TRACEMS2(cinfo, 1, JTRC_PGM, w, h);
     if (maxval > 255) {
       source->pub.get_pixel_rows = get_word_gray_row;
-    } else if (maxval == MAXJSAMPLE && SIZEOF(JSAMPLE) == SIZEOF(U_CHAR)) {
+    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&
+               cinfo->in_color_space == JCS_GRAYSCALE) {
       source->pub.get_pixel_rows = get_raw_row;
       use_raw_buffer = TRUE;
       need_rescale = FALSE;
     } else {
-      source->pub.get_pixel_rows = get_scaled_gray_row;
+      if (cinfo->in_color_space == JCS_GRAYSCALE)
+        source->pub.get_pixel_rows = get_scaled_gray_row;
+      else if (IsExtRGB(cinfo->in_color_space))
+        source->pub.get_pixel_rows = get_gray_rgb_row;
+      else if (cinfo->in_color_space == JCS_CMYK)
+        source->pub.get_pixel_rows = get_gray_cmyk_row;
+      else
+        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     }
     break;
 
   case '6': /* it's a raw-format PPM file */
-    cinfo->input_components = 3;
-    cinfo->in_color_space = JCS_RGB;
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_EXT_RGB;
     TRACEMS2(cinfo, 1, JTRC_PPM, w, h);
     if (maxval > 255) {
       source->pub.get_pixel_rows = get_word_rgb_row;
-    } else if (maxval == MAXJSAMPLE && SIZEOF(JSAMPLE) == SIZEOF(U_CHAR)) {
+    } else if (maxval == MAXJSAMPLE && sizeof(JSAMPLE) == sizeof(U_CHAR) &&
+               (cinfo->in_color_space == JCS_EXT_RGB
+#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3
+                || cinfo->in_color_space == JCS_RGB
+#endif
+                )) {
       source->pub.get_pixel_rows = get_raw_row;
       use_raw_buffer = TRUE;
       need_rescale = FALSE;
     } else {
-      source->pub.get_pixel_rows = get_scaled_rgb_row;
+      if (IsExtRGB(cinfo->in_color_space))
+        source->pub.get_pixel_rows = get_rgb_row;
+      else if (cinfo->in_color_space == JCS_CMYK)
+        source->pub.get_pixel_rows = get_rgb_cmyk_row;
+      else
+        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     }
     break;
   }
 
+  if (IsExtRGB(cinfo->in_color_space))
+    cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];
+  else if (cinfo->in_color_space == JCS_GRAYSCALE)
+    cinfo->input_components = 1;
+  else if (cinfo->in_color_space == JCS_CMYK)
+    cinfo->input_components = 4;
+
   /* Allocate space for I/O buffer: 1 or 3 bytes or words/pixel. */
   if (need_iobuffer) {
-    source->buffer_width =
-        (size_t)w * cinfo->input_components *
-        ((maxval <= 255) ? SIZEOF(U_CHAR) : (2 * SIZEOF(U_CHAR)));
+    if (c == '6')
+      source->buffer_width =
+          (size_t)w * 3 *
+          ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));
+    else
+      source->buffer_width =
+          (size_t)w * ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));
     source->iobuffer = (U_CHAR *)(*cinfo->mem->alloc_small)(
         (j_common_ptr)cinfo, JPOOL_IMAGE, source->buffer_width);
   }
@@ -427,7 +678,6 @@
   if (use_raw_buffer) {
     /* For unscaled raw-input case, we can just map it onto the I/O buffer. */
     /* Synthesize a JSAMPARRAY pointer structure */
-    /* Cast here implies near->far pointer conversion on PCs */
     source->pixrow = (JSAMPROW)source->iobuffer;
     source->pub.buffer = &source->pixrow;
     source->pub.buffer_height = 1;
@@ -441,14 +691,14 @@
 
   /* Compute the rescaling array if required. */
   if (need_rescale) {
-    INT32 val, half_maxval;
+    long val, half_maxval;
 
     /* On 16-bit-int machines we have to be careful of maxval = 65535 */
     source->rescale = (JSAMPLE *)(*cinfo->mem->alloc_small)(
         (j_common_ptr)cinfo, JPOOL_IMAGE,
-        (size_t)(((long)maxval + 1L) * SIZEOF(JSAMPLE)));
+        (size_t)(((long)maxval + 1L) * sizeof(JSAMPLE)));
     half_maxval = maxval / 2;
-    for (val = 0; val <= (INT32)maxval; val++) {
+    for (val = 0; val <= (long)maxval; val++) {
       /* The multiplication here must be done in 32 bits to avoid overflow */
       source->rescale[val] =
           (JSAMPLE)((val * MAXJSAMPLE + half_maxval) / maxval);
@@ -473,12 +723,12 @@
 
   /* Create module interface object */
   source = (ppm_source_ptr)(*cinfo->mem->alloc_small)(
-      (j_common_ptr)cinfo, JPOOL_IMAGE, SIZEOF(ppm_source_struct));
+      (j_common_ptr)cinfo, JPOOL_IMAGE, sizeof(ppm_source_struct));
   /* Fill in method ptrs, except get_pixel_rows which start_input sets */
   source->pub.start_input = start_input_ppm;
   source->pub.finish_input = finish_input_ppm;
 
-  return &source->pub;
+  return (cjpeg_source_ptr)source;
 }
 
 #endif /* PPM_SUPPORTED */
