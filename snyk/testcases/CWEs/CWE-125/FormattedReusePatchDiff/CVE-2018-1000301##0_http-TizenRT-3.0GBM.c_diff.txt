--- /home/V1SCAN/CWE-125/FormattedUsed/http-TizenRT-3.0GBM.c	2023-12-10 02:51:50.508373836 +0900
+++ /home/V1SCAN/CWE-125/FormattedPatch/NEW##CVE-2018-1000301##0##curl@@curl##http.c	2023-12-10 02:51:51.668364747 +0900
@@ -22,7 +22,7 @@
 
 #include "curl_setup.h"
 
-#ifndef CONFIG_DISABLE_HTTP
+#ifndef CURL_DISABLE_HTTP
 
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
@@ -91,6 +91,8 @@
                            int numsocks);
 static int http_should_fail(struct connectdata *conn);
 
+static CURLcode add_haproxy_protocol_header(struct connectdata *conn);
+
 #ifdef USE_SSL
 static CURLcode https_connecting(struct connectdata *conn, bool *done);
 static int https_getsock(struct connectdata *conn, curl_socket_t *socks,
@@ -173,9 +175,9 @@
  * if proxy headers are not available, then it will lookup into http header
  * link list
  *
- * It takes a connectdata struct as input instead of the Curl_easy simply
- * to know if this is a proxy request or not, as it then might check a
- * different header list.
+ * It takes a connectdata struct as input instead of the Curl_easy simply to
+ * know if this is a proxy request or not, as it then might check a different
+ * header list. Provide the header prefix without colon!.
  */
 char *Curl_checkProxyheaders(const struct connectdata *conn,
                              const char *thisheader) {
@@ -187,7 +189,8 @@
                   ? data->set.proxyheaders
                   : data->set.headers;
        head; head = head->next) {
-    if (strncasecompare(head->data, thisheader, thislen))
+    if (strncasecompare(head->data, thisheader, thislen) &&
+        Curl_headersep(head->data[thislen]))
       return head->data;
   }
 
@@ -206,8 +209,6 @@
   char *value;
   size_t len;
 
-  DEBUGASSERT(header);
-
   /* Find the end of the header name */
   while (*header && (*header != ':'))
     ++header;
@@ -420,7 +421,7 @@
            data left to send, keep on sending. */
 
         /* rewind data when completely done sending! */
-        if (!conn->bits.authneg) {
+        if (!conn->bits.authneg && (conn->writesockfd != CURL_SOCKET_BAD)) {
           conn->bits.rewindaftersend = TRUE;
           infof(data, "Rewind stream after send\n");
         }
@@ -536,7 +537,7 @@
                                     bool proxy) {
   const char *auth = NULL;
   CURLcode result = CURLE_OK;
-#if defined(USE_SPNEGO)
+#if !defined(CURL_DISABLE_VERBOSE_STRINGS) || defined(USE_SPNEGO)
   struct Curl_easy *data = conn->data;
 #endif
 #ifdef USE_SPNEGO
@@ -544,7 +545,7 @@
       proxy ? &data->state.proxyneg : &data->state.negotiate;
 #endif
 
-#ifdef CONFIG_DISABLE_CRYPTO_AUTH
+#ifdef CURL_DISABLE_CRYPTO_AUTH
   (void)request;
   (void)path;
 #endif
@@ -577,7 +578,7 @@
       return result;
   } else
 #endif
-#ifndef CONFIG_DISABLE_CRYPTO_AUTH
+#ifndef CURL_DISABLE_CRYPTO_AUTH
       if (authstatus->picked == CURLAUTH_DIGEST) {
     auth = "Digest";
     result = Curl_output_digest(conn, proxy, (const unsigned char *)request,
@@ -589,9 +590,9 @@
       if (authstatus->picked == CURLAUTH_BASIC) {
     /* Basic */
     if ((proxy && conn->bits.proxy_user_passwd &&
-         !Curl_checkProxyheaders(conn, "Proxy-authorization:")) ||
+         !Curl_checkProxyheaders(conn, "Proxy-authorization")) ||
         (!proxy && conn->bits.user_passwd &&
-         !Curl_checkheaders(conn, "Authorization:"))) {
+         !Curl_checkheaders(conn, "Authorization"))) {
       auth = "Basic";
       result = http_output_basic(conn, proxy);
       if (result)
@@ -604,12 +605,10 @@
   }
 
   if (auth) {
-#ifdef USE_SPNEGO
     infof(data, "%s auth using %s with user '%s'\n", proxy ? "Proxy" : "Server",
           auth,
           proxy ? (conn->http_proxy.user ? conn->http_proxy.user : "")
                 : (conn->user ? conn->user : ""));
-#endif
     authstatus->multipass = (!authstatus->done) ? TRUE : FALSE;
   } else
     authstatus->multipass = FALSE;
@@ -668,7 +667,7 @@
        and if this is one single bit it'll be used instantly. */
     authproxy->picked = authproxy->want;
 
-#ifndef CONFIG_DISABLE_PROXY
+#ifndef CURL_DISABLE_PROXY
   /* Send proxy authentication header if needed */
   if (conn->bits.httpproxy && (conn->bits.tunnel_proxy == proxytunnel)) {
     result = output_auth_headers(conn, authproxy, request, path, TRUE);
@@ -677,7 +676,7 @@
   } else
 #else
   (void)proxytunnel;
-#endif /* CONFIG_DISABLE_PROXY */
+#endif /* CURL_DISABLE_PROXY */
     /* we have no proxy so let's pretend we're done authenticating
        with it */
     authproxy->done = TRUE;
@@ -811,7 +810,7 @@
       }
     } else
 #endif
-#ifndef CONFIG_DISABLE_CRYPTO_AUTH
+#ifndef CURL_DISABLE_CRYPTO_AUTH
         if (checkprefix("Digest", auth)) {
       if ((authp->avail & CURLAUTH_DIGEST) != 0)
         infof(data, "Ignoring duplicate digest auth header.\n");
@@ -1301,6 +1300,13 @@
     /* nothing else to do except wait right now - we're not done here. */
     return CURLE_OK;
 
+  if (conn->data->set.haproxyprotocol) {
+    /* add HAProxy PROXY protocol header */
+    result = add_haproxy_protocol_header(conn);
+    if (result)
+      return result;
+  }
+
   if (conn->given->protocol & CURLPROTO_HTTPS) {
     /* perform SSL initialization */
     result = https_connecting(conn, done);
@@ -1323,6 +1329,38 @@
   return GETSOCK_WRITESOCK(0);
 }
 
+static CURLcode add_haproxy_protocol_header(struct connectdata *conn) {
+  char proxy_header[128];
+  Curl_send_buffer *req_buffer;
+  CURLcode result;
+  char tcp_version[5];
+
+  /* Emit the correct prefix for IPv6 */
+  if (conn->bits.ipv6) {
+    strcpy(tcp_version, "TCP6");
+  } else {
+    strcpy(tcp_version, "TCP4");
+  }
+
+  snprintf(proxy_header, sizeof proxy_header, "PROXY %s %s %s %i %i\r\n",
+           tcp_version, conn->data->info.conn_local_ip,
+           conn->data->info.conn_primary_ip, conn->data->info.conn_local_port,
+           conn->data->info.conn_primary_port);
+
+  req_buffer = Curl_add_buffer_init();
+  if (!req_buffer)
+    return CURLE_OUT_OF_MEMORY;
+
+  result = Curl_add_bufferf(req_buffer, proxy_header);
+  if (result)
+    return result;
+
+  result = Curl_add_buffer_send(req_buffer, conn,
+                                &conn->data->info.request_size, 0, FIRSTSOCKET);
+
+  return result;
+}
+
 #ifdef USE_SSL
 static CURLcode https_connecting(struct connectdata *conn, bool *done) {
   CURLcode result;
@@ -1441,7 +1479,7 @@
 
 static const char *get_http_string(const struct Curl_easy *data,
                                    const struct connectdata *conn) {
-#ifdef CONFIG_USE_NGHTTP2
+#ifdef USE_NGHTTP2
   if (conn->proto.httpc.h2)
     return "2";
 #endif
@@ -1463,7 +1501,7 @@
     /* if not doing HTTP 1.0 or version 2, or disabled explicitly, we add an
        Expect: 100-continue to the headers which actually speeds up post
        operations (as there is one packet coming back from the web server) */
-    ptr = Curl_checkheaders(conn, "Expect:");
+    ptr = Curl_checkheaders(conn, "Expect");
     if (ptr) {
       data->state.expect100header =
           Curl_compareheader(ptr, "Expect:", "100-continue");
@@ -1524,7 +1562,31 @@
     headers = h[i];
 
     while (headers) {
+      char *semicolonp = NULL;
       ptr = strchr(headers->data, ':');
+      if (!ptr) {
+        char *optr;
+        /* no colon, semicolon? */
+        ptr = strchr(headers->data, ';');
+        if (ptr) {
+          optr = ptr;
+          ptr++; /* pass the semicolon */
+          while (*ptr && ISSPACE(*ptr))
+            ptr++;
+
+          if (*ptr) {
+            /* this may be used for something else in the future */
+            optr = NULL;
+          } else {
+            if (*(--ptr) == ';') {
+              /* send no-value custom header if terminated by semicolon */
+              *ptr = ':';
+              semicolonp = ptr;
+            }
+          }
+          ptr = optr;
+        }
+      }
       if (ptr) {
         /* we require a colon for this to be a true header */
 
@@ -1532,8 +1594,9 @@
         while (*ptr && ISSPACE(*ptr))
           ptr++;
 
-        if (*ptr) {
-          /* only send this if the contents was non-blank */
+        if (*ptr || semicolonp) {
+          /* only send this if the contents was non-blank or done special */
+          CURLcode result = CURLE_OK;
 
           if (conn->allocptr.host &&
               /* a Host: header was sent already, don't pass on any custom Host:
@@ -1570,37 +1633,12 @@
                     !strcasecompare(data->state.first_host, conn->host.name)))
             ;
           else {
-            CURLcode result =
-                Curl_add_bufferf(req_buffer, "%s\r\n", headers->data);
-            if (result)
-              return result;
-          }
-        }
-      } else {
-        ptr = strchr(headers->data, ';');
-        if (ptr) {
-
-          ptr++; /* pass the semicolon */
-          while (*ptr && ISSPACE(*ptr))
-            ptr++;
-
-          if (*ptr) {
-            /* this may be used for something else in the future */
-          } else {
-            if (*(--ptr) == ';') {
-              CURLcode result;
-
-              /* send no-value custom header if terminated by semicolon */
-              *ptr = ':';
-              result = Curl_add_bufferf(req_buffer, "%s\r\n", headers->data);
-
-              /* restore the previous value */
-              *ptr = ';';
-
-              if (result)
-                return result;
-            }
+            result = Curl_add_bufferf(req_buffer, "%s\r\n", headers->data);
           }
+          if (semicolonp)
+            *semicolonp = ';'; /* put back the semicolon */
+          if (result)
+            return result;
         }
       }
       headers = headers->next;
@@ -1680,7 +1718,7 @@
   const char *ptr;
   const char *request;
   Curl_HttpReq httpreq = data->set.httpreq;
-#if !defined(CONFIG_DISABLE_COOKIES)
+#if !defined(CURL_DISABLE_COOKIES)
   char *addcookies = NULL;
 #endif
   curl_off_t included_body = 0;
@@ -1709,7 +1747,7 @@
       break;
     default:
       /* Check if user wants to use HTTP/2 with clear TCP*/
-#ifdef CONFIG_USE_NGHTTP2
+#ifdef USE_NGHTTP2
       if (conn->data->set.httpversion == CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE) {
         DEBUGF(infof(data, "HTTP/2 over clean TCP\n"));
         conn->httpversion = 20;
@@ -1782,7 +1820,7 @@
      it might have been used in the proxy connect, but if we have got a header
      with the user-agent string specified, we erase the previously made string
      here. */
-  if (Curl_checkheaders(conn, "User-Agent:")) {
+  if (Curl_checkheaders(conn, "User-Agent")) {
     free(conn->allocptr.uagent);
     conn->allocptr.uagent = NULL;
   }
@@ -1801,19 +1839,19 @@
     conn->bits.authneg = FALSE;
 
   Curl_safefree(conn->allocptr.ref);
-  if (data->change.referer && !Curl_checkheaders(conn, "Referer:")) {
+  if (data->change.referer && !Curl_checkheaders(conn, "Referer")) {
     conn->allocptr.ref = aprintf("Referer: %s\r\n", data->change.referer);
     if (!conn->allocptr.ref)
       return CURLE_OUT_OF_MEMORY;
   } else
     conn->allocptr.ref = NULL;
 
-#if !defined(CONFIG_DISABLE_COOKIES)
-  if (data->set.str[STRING_COOKIE] && !Curl_checkheaders(conn, "Cookie:"))
+#if !defined(CURL_DISABLE_COOKIES)
+  if (data->set.str[STRING_COOKIE] && !Curl_checkheaders(conn, "Cookie"))
     addcookies = data->set.str[STRING_COOKIE];
 #endif
 
-  if (!Curl_checkheaders(conn, "Accept-Encoding:") &&
+  if (!Curl_checkheaders(conn, "Accept-Encoding") &&
       data->set.str[STRING_ENCODING]) {
     Curl_safefree(conn->allocptr.accept_encoding);
     conn->allocptr.accept_encoding =
@@ -1825,24 +1863,31 @@
     conn->allocptr.accept_encoding = NULL;
   }
 
-#ifdef CONFIG_USE_ZLIB
+#ifdef HAVE_LIBZ
   /* we only consider transfer-encoding magic if libz support is built-in */
 
-  if (!Curl_checkheaders(conn, "TE:") && data->set.http_transfer_encoding) {
+  if (!Curl_checkheaders(conn, "TE") && data->set.http_transfer_encoding) {
     /* When we are to insert a TE: header in the request, we must also insert
        TE in a Connection: header, so we need to merge the custom provided
        Connection: header and prevent the original to get sent. Note that if
        the user has inserted his/hers own TE: header we don't do this magic
        but then assume that the user will handle it all! */
-    char *cptr = Curl_checkheaders(conn, "Connection:");
+    char *cptr = Curl_checkheaders(conn, "Connection");
 #define TE_HEADER "TE: gzip\r\n"
 
     Curl_safefree(conn->allocptr.te);
 
+    if (cptr) {
+      cptr = Curl_copy_header_value(cptr);
+      if (!cptr)
+        return CURLE_OUT_OF_MEMORY;
+    }
+
     /* Create the (updated) Connection: header */
-    conn->allocptr.te = cptr ? aprintf("%s, TE\r\n" TE_HEADER, cptr)
-                             : strdup("Connection: TE\r\n" TE_HEADER);
+    conn->allocptr.te = aprintf("Connection: %s%sTE\r\n" TE_HEADER,
+                                cptr ? cptr : "", (cptr && *cptr) ? ", " : "");
 
+    free(cptr);
     if (!conn->allocptr.te)
       return CURLE_OUT_OF_MEMORY;
   }
@@ -1866,7 +1911,7 @@
   }
 
   if (http->sendit) {
-    const char *cthdr = Curl_checkheaders(conn, "Content-Type:");
+    const char *cthdr = Curl_checkheaders(conn, "Content-Type");
 
     /* Read and seek body only. */
     http->sendit->flags |= MIME_BODY_ONLY;
@@ -1890,7 +1935,7 @@
     http->postsize = Curl_mime_size(http->sendit);
   }
 
-  ptr = Curl_checkheaders(conn, "Transfer-Encoding:");
+  ptr = Curl_checkheaders(conn, "Transfer-Encoding");
   if (ptr) {
     /* Some kind of TE is requested, check if 'chunked' is chosen */
     data->req.upload_chunky =
@@ -1921,10 +1966,10 @@
 
   Curl_safefree(conn->allocptr.host);
 
-  ptr = Curl_checkheaders(conn, "Host:");
+  ptr = Curl_checkheaders(conn, "Host");
   if (ptr && (!data->state.this_is_a_follow ||
               strcasecompare(data->state.first_host, conn->host.name))) {
-#if !defined(CONFIG_DISABLE_COOKIES)
+#if !defined(CURL_DISABLE_COOKIES)
     /* If we have a given custom Host: header, we extract the host name in
        order to possibly use it for cookie reasons later on. We only allow the
        custom Host: header if this is NOT a redirect, as setting Host: in the
@@ -1959,7 +2004,7 @@
 #endif
 
     if (strcmp("Host:", ptr)) {
-      conn->allocptr.host = aprintf("%s\r\n", ptr);
+      conn->allocptr.host = aprintf("Host:%s\r\n", &ptr[5]);
       if (!conn->allocptr.host)
         return CURLE_OUT_OF_MEMORY;
     } else
@@ -1988,7 +2033,7 @@
       return CURLE_OUT_OF_MEMORY;
   }
 
-#ifndef CONFIG_DISABLE_PROXY
+#ifndef CURL_DISABLE_PROXY
   if (conn->bits.httpproxy && !conn->bits.tunnel_proxy) {
     /* Using a proxy but does not tunnel through it */
 
@@ -2060,10 +2105,9 @@
         paste_ftp_userpwd = TRUE;
     }
   }
-#endif /* CONFIG_DISABLE_PROXY */
+#endif /* CURL_DISABLE_PROXY */
 
-  http->p_accept =
-      Curl_checkheaders(conn, "Accept:") ? NULL : "Accept: */*\r\n";
+  http->p_accept = Curl_checkheaders(conn, "Accept") ? NULL : "Accept: */*\r\n";
 
   if ((HTTPREQ_POST == httpreq || HTTPREQ_PUT == httpreq) &&
       data->state.resume_from) {
@@ -2090,8 +2134,10 @@
       /* Now, let's read off the proper amount of bytes from the
          input. */
       if (conn->seek_func) {
+        Curl_set_in_callback(data, true);
         seekerr = conn->seek_func(conn->seek_client, data->state.resume_from,
                                   SEEK_SET);
+        Curl_set_in_callback(data, false);
       }
 
       if (seekerr != CURL_SEEKFUNC_OK) {
@@ -2143,13 +2189,13 @@
      * ones if any such are specified.
      */
     if (((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
-        !Curl_checkheaders(conn, "Range:")) {
+        !Curl_checkheaders(conn, "Range")) {
       /* if a line like this was already allocated, free the previous one */
       free(conn->allocptr.rangeline);
       conn->allocptr.rangeline =
           aprintf("Range: bytes=%s\r\n", data->state.range);
     } else if ((httpreq == HTTPREQ_POST || httpreq == HTTPREQ_PUT) &&
-               !Curl_checkheaders(conn, "Content-Range:")) {
+               !Curl_checkheaders(conn, "Content-Range")) {
 
       /* if a line like this was already allocated, free the previous one */
       free(conn->allocptr.rangeline);
@@ -2245,7 +2291,7 @@
       (data->change.referer && conn->allocptr.ref) ? conn->allocptr.ref
                                                    : "" /* Referer: <data> */,
       (conn->bits.httpproxy && !conn->bits.tunnel_proxy &&
-       !Curl_checkProxyheaders(conn, "Proxy-Connection:"))
+       !Curl_checkProxyheaders(conn, "Proxy-Connection"))
           ? "Proxy-Connection: Keep-Alive\r\n"
           : "",
       te);
@@ -2267,7 +2313,7 @@
       return result;
   }
 
-#if !defined(CONFIG_DISABLE_COOKIES)
+#if !defined(CURL_DISABLE_COOKIES)
   if (data->cookies || addcookies) {
     struct Cookie *co = NULL; /* no cookies from start */
     int count = 0;
@@ -2343,7 +2389,7 @@
       postsize = data->state.infilesize;
 
     if ((postsize != -1) && !data->req.upload_chunky &&
-        (conn->bits.authneg || !Curl_checkheaders(conn, "Content-Length:"))) {
+        (conn->bits.authneg || !Curl_checkheaders(conn, "Content-Length"))) {
       /* only add Content-Length if not uploading chunked */
       result = Curl_add_bufferf(
           req_buffer, "Content-Length: %" CURL_FORMAT_CURL_OFF_T "\r\n",
@@ -2405,7 +2451,7 @@
        we don't upload data chunked, as RFC2616 forbids us to set both
        kinds of headers (Transfer-Encoding: chunked and Content-Length) */
     if (postsize != -1 && !data->req.upload_chunky &&
-        (conn->bits.authneg || !Curl_checkheaders(conn, "Content-Length:"))) {
+        (conn->bits.authneg || !Curl_checkheaders(conn, "Content-Length"))) {
       /* we allow replacing this header if not during auth negotiation,
          although it isn't very wise to actually set your own */
       result = Curl_add_bufferf(
@@ -2430,7 +2476,7 @@
        the somewhat bigger ones we allow the app to disable it. Just make
        sure that the expect100header is always set to the preferred value
        here. */
-    ptr = Curl_checkheaders(conn, "Expect:");
+    ptr = Curl_checkheaders(conn, "Expect");
     if (ptr) {
       data->state.expect100header =
           Curl_compareheader(ptr, "Expect:", "100-continue");
@@ -2482,7 +2528,7 @@
        we don't upload data chunked, as RFC2616 forbids us to set both
        kinds of headers (Transfer-Encoding: chunked and Content-Length) */
     if ((postsize != -1) && !data->req.upload_chunky &&
-        (conn->bits.authneg || !Curl_checkheaders(conn, "Content-Length:"))) {
+        (conn->bits.authneg || !Curl_checkheaders(conn, "Content-Length"))) {
       /* we allow replacing this header if not during auth negotiation,
          although it isn't very wise to actually set your own */
       result = Curl_add_bufferf(
@@ -2492,7 +2538,7 @@
         return result;
     }
 
-    if (!Curl_checkheaders(conn, "Content-Type:")) {
+    if (!Curl_checkheaders(conn, "Content-Type")) {
       result = Curl_add_bufferf(req_buffer, "Content-Type: application/"
                                             "x-www-form-urlencoded\r\n");
       if (result)
@@ -2503,7 +2549,7 @@
        the somewhat bigger ones we allow the app to disable it. Just make
        sure that the expect100header is always set to the preferred value
        here. */
-    ptr = Curl_checkheaders(conn, "Expect:");
+    ptr = Curl_checkheaders(conn, "Expect");
     if (ptr) {
       data->state.expect100header =
           Curl_compareheader(ptr, "Expect:", "100-continue");
@@ -2703,7 +2749,7 @@
   return rc;
 }
 
-#ifndef CONFIG_DISABLE_RTSP
+#ifndef CURL_DISABLE_RTSP
 static bool checkrtspprefix(struct Curl_easy *data, const char *s) {
   bool result = FALSE;
 
@@ -2727,16 +2773,16 @@
 
   return result;
 }
-#endif /* CONFIG_DISABLE_RTSP */
+#endif /* CURL_DISABLE_RTSP */
 
 static bool checkprotoprefix(struct Curl_easy *data, struct connectdata *conn,
                              const char *s) {
-#ifndef CONFIG_DISABLE_RTSP
+#ifndef CURL_DISABLE_RTSP
   if (conn->handler->protocol & CURLPROTO_RTSP)
     return checkrtspprefix(data, s);
 #else
   (void)conn;
-#endif /* CONFIG_DISABLE_RTSP */
+#endif /* CURL_DISABLE_RTSP */
 
   return checkhttpprefix(data, s);
 }
@@ -2748,20 +2794,19 @@
  */
 static CURLcode header_append(struct Curl_easy *data, struct SingleRequest *k,
                               size_t length) {
-  if (k->hbuflen + length >= data->state.headersize) {
+  size_t newsize = k->hbuflen + length;
+  if (newsize > CURL_MAX_HTTP_HEADER) {
+    /* The reason to have a max limit for this is to avoid the risk of a bad
+       server feeding libcurl with a never-ending header that will cause
+       reallocs infinitely */
+    failf(data, "Rejected %zd bytes header (max is %d)!", newsize,
+          CURL_MAX_HTTP_HEADER);
+    return CURLE_OUT_OF_MEMORY;
+  }
+  if (newsize >= data->state.headersize) {
     /* We enlarge the header buffer as it is too small */
     char *newbuff;
     size_t hbufp_index;
-    size_t newsize;
-
-    if (k->hbuflen + length > CURL_MAX_HTTP_HEADER) {
-      /* The reason to have a max limit for this is to avoid the risk of a bad
-         server feeding libcurl with a never-ending header that will cause
-         reallocs infinitely */
-      failf(data, "Avoided giant realloc for header (max is %d)!",
-            CURL_MAX_HTTP_HEADER);
-      return CURLE_OUT_OF_MEMORY;
-    }
 
     newsize =
         CURLMAX((k->hbuflen + length) * 3 / 2, data->state.headersize * 2);
@@ -2827,6 +2872,8 @@
                                      bool *stop_reading) {
   CURLcode result;
   struct SingleRequest *k = &data->req;
+  ssize_t onread = *nread;
+  char *ostr = k->str;
 
   /* header line within buffer loop */
   do {
@@ -2891,7 +2938,9 @@
         else {
           /* this was all we read so it's all a bad header */
           k->badheader = HEADER_ALLBAD;
-          *nread = (ssize_t)rest_length;
+          *nread = onread;
+          k->str = ostr;
+          return CURLE_OK;
         }
         break;
       }
@@ -3102,7 +3151,7 @@
          */
         if (data->set.opt_no_body)
           *stop_reading = TRUE;
-#ifndef CONFIG_DISABLE_RTSP
+#ifndef CURL_DISABLE_RTSP
         else if ((conn->handler->protocol & CURLPROTO_RTSP) &&
                  (data->set.rtspreq == RTSPREQ_DESCRIBE) && (k->size <= -1))
           /* Respect section 4.4 of rfc2326: If the Content-Length header is
@@ -3143,7 +3192,7 @@
            stream.  In order to do this, we keep reading until we
            close the stream. */
         if (0 == k->maxdownload
-#if defined(CONFIG_USE_NGHTTP2)
+#if defined(USE_NGHTTP2)
             && !((conn->handler->protocol & PROTO_FAMILY_HTTP) &&
                  conn->httpversion == 20)
 #endif
@@ -3495,10 +3544,10 @@
       } else
         data->state.resume_from = 0; /* get everything */
     }
-#if !defined(CONFIG_DISABLE_COOKIES)
+#if !defined(CURL_DISABLE_COOKIES)
     else if (data->cookies && checkprefix("Set-Cookie:", k->p)) {
       Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
-      Curl_cookie_add(data, data->cookies, TRUE, k->p + 11,
+      Curl_cookie_add(data, data->cookies, TRUE, FALSE, k->p + 11,
                       /* If there is a custom-set Host: name, use it
                          here, or else use real peer host name. */
                       conn->allocptr.cookiehost ? conn->allocptr.cookiehost
@@ -3512,7 +3561,7 @@
       time_t secs = time(NULL);
       k->timeofdoc = curl_getdate(k->p + strlen("Last-Modified:"), &secs);
       if (data->set.get_filetime)
-        data->info.filetime = (long)k->timeofdoc;
+        data->info.filetime = k->timeofdoc;
     } else if ((checkprefix("WWW-Authenticate:", k->p) &&
                 (401 == k->httpcode)) ||
                (checkprefix("Proxy-authenticate:", k->p) &&
@@ -3590,4 +3639,4 @@
   return CURLE_OK;
 }
 
-#endif /* CONFIG_DISABLE_HTTP */
+#endif /* CURL_DISABLE_HTTP */
