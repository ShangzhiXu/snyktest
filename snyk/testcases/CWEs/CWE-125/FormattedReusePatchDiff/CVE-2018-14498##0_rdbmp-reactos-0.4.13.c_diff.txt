--- /home/V1SCAN/CWE-125/FormattedUsed/rdbmp-reactos-0.4.13.c	2023-12-10 02:51:50.528373680 +0900
+++ /home/V1SCAN/CWE-125/FormattedPatch/NEW##CVE-2018-14498##0##libjpeg-turbo@@libjpeg-turbo##rdbmp.c	2023-12-10 02:51:51.698364512 +0900
@@ -1,14 +1,18 @@
 /*
  * rdbmp.c
  *
+ * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * Modified 2009-2017 by Guido Vollbeding.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
+ * libjpeg-turbo Modifications:
+ * Modified 2011 by Siarhei Siamashka.
+ * Copyright (C) 2015, 2017-2018, D. R. Commander.
+ * For conditions of distribution and use, see the accompanying README.ijg
+ * file.
  *
  * This file contains routines to read input images in Microsoft "BMP"
  * format (MS Windows 3.x, OS/2 1.x, and OS/2 2.x flavors).
- * Currently, only 8-, 24-, and 32-bit images are supported, not 1-bit or
+ * Currently, only 8-bit and 24-bit images are supported, not 1-bit or
  * 4-bit (feeding such low-depth images into JPEG would be silly anyway).
  * Also, we don't support RLE-compressed files.
  *
@@ -23,6 +27,7 @@
  */
 
 #include "cdjpeg.h" /* Common decls for cjpeg/djpeg applications */
+#include "cmyk.h"
 
 #ifdef BMP_SUPPORTED
 
@@ -32,7 +37,7 @@
 typedef unsigned char U_CHAR;
 #define UCH(x) ((int)(x))
 #else /* !HAVE_UNSIGNED_CHAR */
-#ifdef CHAR_IS_UNSIGNED
+#ifdef __CHAR_UNSIGNED__
 typedef char U_CHAR;
 #define UCH(x) ((int)(x))
 #else
@@ -43,6 +48,9 @@
 
 #define ReadOK(file, buffer, len) (JFREAD(file, buffer, len) == ((size_t)(len)))
 
+static int alpha_index[JPEG_NUMCS] = {-1, -1, -1, -1, -1, -1, -1, -1, -1,
+                                      -1, -1, -1, 3,  3,  0,  0,  -1};
+
 /* Private version of data source object */
 
 typedef struct _bmp_source_struct *bmp_source_ptr;
@@ -58,8 +66,19 @@
   JDIMENSION source_row;        /* Current source row number */
   JDIMENSION row_width;         /* Physical width of scanlines in file */
 
-  int bits_per_pixel; /* remembers 8-, 24-, or 32-bit format */
+  int bits_per_pixel; /* remembers 8- or 24-bit format */
   int cmap_length;    /* colormap length */
+
+  boolean use_inversion_array; /* TRUE = preload the whole image, which is
+                                  stored in bottom-up order, and feed it to
+                                  the calling program in top-down order
+
+                                  FALSE = the calling program will maintain
+                                  its own image buffer and read the rows in
+                                  bottom-up order */
+
+  U_CHAR *iobuffer; /* I/O buffer (used to buffer a single row from
+                       disk if use_inversion_array == FALSE) */
 } bmp_source_struct;
 
 LOCAL(int)
@@ -78,7 +97,7 @@
 read_colormap(bmp_source_ptr sinfo, int cmaplen, int mapentrysize)
 /* Read the colormap from a BMP file */
 {
-  int i;
+  int i, gray = 1;
 
   switch (mapentrysize) {
   case 3:
@@ -87,6 +106,9 @@
       sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);
       sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);
       sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);
+      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||
+          sinfo->colormap[1][i] != sinfo->colormap[0][i])
+        gray = 0;
     }
     break;
   case 4:
@@ -96,12 +118,21 @@
       sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);
       sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);
       (void)read_byte(sinfo);
+      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||
+          sinfo->colormap[1][i] != sinfo->colormap[0][i])
+        gray = 0;
     }
     break;
   default:
     ERREXIT(sinfo->cinfo, JERR_BMP_BADCMAP);
     break;
   }
+
+  if (sinfo->cinfo->in_color_space == JCS_UNKNOWN && gray)
+    sinfo->cinfo->in_color_space = JCS_GRAYSCALE;
+
+  if (sinfo->cinfo->in_color_space == JCS_GRAYSCALE && !gray)
+    ERREXIT(sinfo->cinfo, JERR_BAD_IN_COLORSPACE);
 }
 
 /*
@@ -116,31 +147,73 @@
 /* This version is for reading 8-bit colormap indexes */
 {
   bmp_source_ptr source = (bmp_source_ptr)sinfo;
+  register JSAMPARRAY colormap = source->colormap;
+  int cmaplen = source->cmap_length;
   JSAMPARRAY image_ptr;
+  register int t;
   register JSAMPROW inptr, outptr;
-  register JSAMPARRAY colormap;
   register JDIMENSION col;
-  register int t;
-  int cmaplen;
 
-  /* Fetch next row from virtual array */
-  source->source_row--;
-  image_ptr = (*cinfo->mem->access_virt_sarray)(
-      (j_common_ptr)cinfo, source->whole_image, source->source_row,
-      (JDIMENSION)1, FALSE);
+  if (source->use_inversion_array) {
+    /* Fetch next row from virtual array */
+    source->source_row--;
+    image_ptr = (*cinfo->mem->access_virt_sarray)(
+        (j_common_ptr)cinfo, source->whole_image, source->source_row,
+        (JDIMENSION)1, FALSE);
+    inptr = image_ptr[0];
+  } else {
+    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))
+      ERREXIT(cinfo, JERR_INPUT_EOF);
+    inptr = source->iobuffer;
+  }
 
   /* Expand the colormap indexes to real data */
-  inptr = image_ptr[0];
   outptr = source->pub.buffer[0];
-  colormap = source->colormap;
-  cmaplen = source->cmap_length;
-  for (col = cinfo->image_width; col > 0; col--) {
-    t = GETJSAMPLE(*inptr++);
-    if (t >= cmaplen)
-      ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
-    *outptr++ = colormap[0][t]; /* can omit GETJSAMPLE() safely */
-    *outptr++ = colormap[1][t];
-    *outptr++ = colormap[2][t];
+  if (cinfo->in_color_space == JCS_GRAYSCALE) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      t = GETJSAMPLE(*inptr++);
+      if (t >= cmaplen)
+        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
+      *outptr++ = colormap[0][t];
+    }
+  } else if (cinfo->in_color_space == JCS_CMYK) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      t = GETJSAMPLE(*inptr++);
+      if (t >= cmaplen)
+        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
+      rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,
+                  outptr + 1, outptr + 2, outptr + 3);
+      outptr += 4;
+    }
+  } else {
+    register int rindex = rgb_red[cinfo->in_color_space];
+    register int gindex = rgb_green[cinfo->in_color_space];
+    register int bindex = rgb_blue[cinfo->in_color_space];
+    register int aindex = alpha_index[cinfo->in_color_space];
+    register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+    if (aindex >= 0) {
+      for (col = cinfo->image_width; col > 0; col--) {
+        t = GETJSAMPLE(*inptr++);
+        if (t >= cmaplen)
+          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
+        outptr[rindex] = colormap[0][t];
+        outptr[gindex] = colormap[1][t];
+        outptr[bindex] = colormap[2][t];
+        outptr[aindex] = 0xFF;
+        outptr += ps;
+      }
+    } else {
+      for (col = cinfo->image_width; col > 0; col--) {
+        t = GETJSAMPLE(*inptr++);
+        if (t >= cmaplen)
+          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
+        outptr[rindex] = colormap[0][t];
+        outptr[gindex] = colormap[1][t];
+        outptr[bindex] = colormap[2][t];
+        outptr += ps;
+      }
+    }
   }
 
   return 1;
@@ -155,22 +228,55 @@
   register JSAMPROW inptr, outptr;
   register JDIMENSION col;
 
-  /* Fetch next row from virtual array */
-  source->source_row--;
-  image_ptr = (*cinfo->mem->access_virt_sarray)(
-      (j_common_ptr)cinfo, source->whole_image, source->source_row,
-      (JDIMENSION)1, FALSE);
+  if (source->use_inversion_array) {
+    /* Fetch next row from virtual array */
+    source->source_row--;
+    image_ptr = (*cinfo->mem->access_virt_sarray)(
+        (j_common_ptr)cinfo, source->whole_image, source->source_row,
+        (JDIMENSION)1, FALSE);
+    inptr = image_ptr[0];
+  } else {
+    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))
+      ERREXIT(cinfo, JERR_INPUT_EOF);
+    inptr = source->iobuffer;
+  }
 
   /* Transfer data.  Note source values are in BGR order
    * (even though Microsoft's own documents say the opposite).
    */
-  inptr = image_ptr[0];
   outptr = source->pub.buffer[0];
-  for (col = cinfo->image_width; col > 0; col--) {
-    outptr[2] = *inptr++; /* can omit GETJSAMPLE() safely */
-    outptr[1] = *inptr++;
-    outptr[0] = *inptr++;
-    outptr += 3;
+  if (cinfo->in_color_space == JCS_EXT_BGR) {
+    MEMCOPY(outptr, inptr, source->row_width);
+  } else if (cinfo->in_color_space == JCS_CMYK) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      /* can omit GETJSAMPLE() safely */
+      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;
+      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);
+      outptr += 4;
+    }
+  } else {
+    register int rindex = rgb_red[cinfo->in_color_space];
+    register int gindex = rgb_green[cinfo->in_color_space];
+    register int bindex = rgb_blue[cinfo->in_color_space];
+    register int aindex = alpha_index[cinfo->in_color_space];
+    register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+    if (aindex >= 0) {
+      for (col = cinfo->image_width; col > 0; col--) {
+        outptr[bindex] = *inptr++; /* can omit GETJSAMPLE() safely */
+        outptr[gindex] = *inptr++;
+        outptr[rindex] = *inptr++;
+        outptr[aindex] = 0xFF;
+        outptr += ps;
+      }
+    } else {
+      for (col = cinfo->image_width; col > 0; col--) {
+        outptr[bindex] = *inptr++; /* can omit GETJSAMPLE() safely */
+        outptr[gindex] = *inptr++;
+        outptr[rindex] = *inptr++;
+        outptr += ps;
+      }
+    }
   }
 
   return 1;
@@ -185,23 +291,58 @@
   register JSAMPROW inptr, outptr;
   register JDIMENSION col;
 
-  /* Fetch next row from virtual array */
-  source->source_row--;
-  image_ptr = (*cinfo->mem->access_virt_sarray)(
-      (j_common_ptr)cinfo, source->whole_image, source->source_row,
-      (JDIMENSION)1, FALSE);
+  if (source->use_inversion_array) {
+    /* Fetch next row from virtual array */
+    source->source_row--;
+    image_ptr = (*cinfo->mem->access_virt_sarray)(
+        (j_common_ptr)cinfo, source->whole_image, source->source_row,
+        (JDIMENSION)1, FALSE);
+    inptr = image_ptr[0];
+  } else {
+    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))
+      ERREXIT(cinfo, JERR_INPUT_EOF);
+    inptr = source->iobuffer;
+  }
 
   /* Transfer data.  Note source values are in BGR order
    * (even though Microsoft's own documents say the opposite).
    */
-  inptr = image_ptr[0];
   outptr = source->pub.buffer[0];
-  for (col = cinfo->image_width; col > 0; col--) {
-    outptr[2] = *inptr++; /* can omit GETJSAMPLE() safely */
-    outptr[1] = *inptr++;
-    outptr[0] = *inptr++;
-    inptr++; /* skip the 4th byte (Alpha channel) */
-    outptr += 3;
+  if (cinfo->in_color_space == JCS_EXT_BGRX ||
+      cinfo->in_color_space == JCS_EXT_BGRA) {
+    MEMCOPY(outptr, inptr, source->row_width);
+  } else if (cinfo->in_color_space == JCS_CMYK) {
+    for (col = cinfo->image_width; col > 0; col--) {
+      /* can omit GETJSAMPLE() safely */
+      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;
+      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);
+      inptr++; /* skip the 4th byte (Alpha channel) */
+      outptr += 4;
+    }
+  } else {
+    register int rindex = rgb_red[cinfo->in_color_space];
+    register int gindex = rgb_green[cinfo->in_color_space];
+    register int bindex = rgb_blue[cinfo->in_color_space];
+    register int aindex = alpha_index[cinfo->in_color_space];
+    register int ps = rgb_pixelsize[cinfo->in_color_space];
+
+    if (aindex >= 0) {
+      for (col = cinfo->image_width; col > 0; col--) {
+        outptr[bindex] = *inptr++; /* can omit GETJSAMPLE() safely */
+        outptr[gindex] = *inptr++;
+        outptr[rindex] = *inptr++;
+        outptr[aindex] = *inptr++;
+        outptr += ps;
+      }
+    } else {
+      for (col = cinfo->image_width; col > 0; col--) {
+        outptr[bindex] = *inptr++; /* can omit GETJSAMPLE() safely */
+        outptr[gindex] = *inptr++;
+        outptr[rindex] = *inptr++;
+        inptr++; /* skip the 4th byte (Alpha channel) */
+        outptr += ps;
+      }
+    }
   }
 
   return 1;
@@ -217,10 +358,9 @@
 preload_image(j_compress_ptr cinfo, cjpeg_source_ptr sinfo) {
   bmp_source_ptr source = (bmp_source_ptr)sinfo;
   register FILE *infile = source->pub.input_file;
-  register int c;
   register JSAMPROW out_ptr;
   JSAMPARRAY image_ptr;
-  JDIMENSION row, col;
+  JDIMENSION row;
   cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;
 
   /* Read the data into a virtual array in input-file row order. */
@@ -233,11 +373,11 @@
     image_ptr = (*cinfo->mem->access_virt_sarray)(
         (j_common_ptr)cinfo, source->whole_image, row, (JDIMENSION)1, TRUE);
     out_ptr = image_ptr[0];
-    for (col = source->row_width; col > 0; col--) {
-      /* inline copy of read_byte() for speed */
-      if ((c = getc(infile)) == EOF)
+    if (fread(out_ptr, 1, source->row_width, infile) != source->row_width) {
+      if (feof(infile))
         ERREXIT(cinfo, JERR_INPUT_EOF);
-      *out_ptr++ = (JSAMPLE)c;
+      else
+        ERREXIT(cinfo, JERR_FILE_READ);
     }
   }
   if (progress != NULL)
@@ -272,24 +412,27 @@
   bmp_source_ptr source = (bmp_source_ptr)sinfo;
   U_CHAR bmpfileheader[14];
   U_CHAR bmpinfoheader[64];
+
 #define GET_2B(array, offset)                                                  \
-  ((unsigned int)UCH(array[offset]) +                                          \
-   (((unsigned int)UCH(array[offset + 1])) << 8))
+  ((unsigned short)UCH(array[offset]) +                                        \
+   (((unsigned short)UCH(array[offset + 1])) << 8))
 #define GET_4B(array, offset)                                                  \
-  ((INT32)UCH(array[offset]) + (((INT32)UCH(array[offset + 1])) << 8) +        \
-   (((INT32)UCH(array[offset + 2])) << 16) +                                   \
-   (((INT32)UCH(array[offset + 3])) << 24))
-  INT32 bfOffBits;
-  INT32 headerSize;
-  INT32 biWidth;
-  INT32 biHeight;
-  unsigned int biPlanes;
-  INT32 biCompression;
-  INT32 biXPelsPerMeter, biYPelsPerMeter;
-  INT32 biClrUsed = 0;
+  ((unsigned int)UCH(array[offset]) +                                          \
+   (((unsigned int)UCH(array[offset + 1])) << 8) +                             \
+   (((unsigned int)UCH(array[offset + 2])) << 16) +                            \
+   (((unsigned int)UCH(array[offset + 3])) << 24))
+
+  unsigned int bfOffBits;
+  unsigned int headerSize;
+  int biWidth;
+  int biHeight;
+  unsigned short biPlanes;
+  unsigned int biCompression;
+  int biXPelsPerMeter, biYPelsPerMeter;
+  unsigned int biClrUsed = 0;
   int mapentrysize = 0; /* 0 indicates no colormap */
-  INT32 bPad;
-  JDIMENSION row_width;
+  int bPad;
+  JDIMENSION row_width = 0;
 
   /* Read and verify the bitmap file header */
   if (!ReadOK(source->pub.input_file, bmpfileheader, 14))
@@ -310,23 +453,21 @@
   if (!ReadOK(source->pub.input_file, bmpinfoheader + 4, headerSize - 4))
     ERREXIT(cinfo, JERR_INPUT_EOF);
 
-  switch ((int)headerSize) {
+  switch (headerSize) {
   case 12:
     /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */
-    biWidth = (INT32)GET_2B(bmpinfoheader, 4);
-    biHeight = (INT32)GET_2B(bmpinfoheader, 6);
+    biWidth = (int)GET_2B(bmpinfoheader, 4);
+    biHeight = (int)GET_2B(bmpinfoheader, 6);
     biPlanes = GET_2B(bmpinfoheader, 8);
     source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 10);
 
     switch (source->bits_per_pixel) {
     case 8:             /* colormapped image */
       mapentrysize = 3; /* OS/2 uses RGBTRIPLE colormap */
-      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, (int)biWidth, (int)biHeight);
+      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, biWidth, biHeight);
       break;
     case 24: /* RGB image */
-    case 32: /* RGB image + Alpha channel */
-      TRACEMS3(cinfo, 1, JTRC_BMP_OS2, (int)biWidth, (int)biHeight,
-               source->bits_per_pixel);
+      TRACEMS2(cinfo, 1, JTRC_BMP_OS2, biWidth, biHeight);
       break;
     default:
       ERREXIT(cinfo, JERR_BMP_BADDEPTH);
@@ -337,25 +478,26 @@
   case 64:
     /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */
     /* or OS/2 2.x header, which has additional fields that we ignore */
-    biWidth = GET_4B(bmpinfoheader, 4);
-    biHeight = GET_4B(bmpinfoheader, 8);
+    biWidth = (int)GET_4B(bmpinfoheader, 4);
+    biHeight = (int)GET_4B(bmpinfoheader, 8);
     biPlanes = GET_2B(bmpinfoheader, 12);
     source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 14);
     biCompression = GET_4B(bmpinfoheader, 16);
-    biXPelsPerMeter = GET_4B(bmpinfoheader, 24);
-    biYPelsPerMeter = GET_4B(bmpinfoheader, 28);
+    biXPelsPerMeter = (int)GET_4B(bmpinfoheader, 24);
+    biYPelsPerMeter = (int)GET_4B(bmpinfoheader, 28);
     biClrUsed = GET_4B(bmpinfoheader, 32);
     /* biSizeImage, biClrImportant fields are ignored */
 
     switch (source->bits_per_pixel) {
     case 8:             /* colormapped image */
       mapentrysize = 4; /* Windows uses RGBQUAD colormap */
-      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, (int)biWidth, (int)biHeight);
+      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, biWidth, biHeight);
       break;
     case 24: /* RGB image */
+      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);
+      break;
     case 32: /* RGB image + Alpha channel */
-      TRACEMS3(cinfo, 1, JTRC_BMP, (int)biWidth, (int)biHeight,
-               source->bits_per_pixel);
+      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);
       break;
     default:
       ERREXIT(cinfo, JERR_BMP_BADDEPTH);
@@ -373,14 +515,13 @@
     break;
   default:
     ERREXIT(cinfo, JERR_BMP_BADHEADER);
-    return; /* avoid compiler warnings for uninitialized variables */
+    return;
   }
 
+  if (biWidth <= 0 || biHeight <= 0)
+    ERREXIT(cinfo, JERR_BMP_EMPTY);
   if (biPlanes != 1)
     ERREXIT(cinfo, JERR_BMP_BADPLANES);
-  /* Sanity check for buffer allocation below */
-  if (biWidth <= 0 || biHeight <= 0 || (biWidth >> 24) || (biHeight >> 24))
-    ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);
 
   /* Compute distance to bitmap data --- will adjust for colormap below */
   bPad = bfOffBits - (headerSize + 14);
@@ -409,34 +550,90 @@
   }
 
   /* Compute row width in file, including padding to 4-byte boundary */
-  if (source->bits_per_pixel == 24)
+  switch (source->bits_per_pixel) {
+  case 8:
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_EXT_RGB;
+    if (IsExtRGB(cinfo->in_color_space))
+      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];
+    else if (cinfo->in_color_space == JCS_GRAYSCALE)
+      cinfo->input_components = 1;
+    else if (cinfo->in_color_space == JCS_CMYK)
+      cinfo->input_components = 4;
+    else
+      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
+    row_width = (JDIMENSION)biWidth;
+    break;
+  case 24:
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_EXT_BGR;
+    if (IsExtRGB(cinfo->in_color_space))
+      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];
+    else if (cinfo->in_color_space == JCS_CMYK)
+      cinfo->input_components = 4;
+    else
+      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     row_width = (JDIMENSION)(biWidth * 3);
-  else if (source->bits_per_pixel == 32)
+    break;
+  case 32:
+    if (cinfo->in_color_space == JCS_UNKNOWN)
+      cinfo->in_color_space = JCS_EXT_BGRA;
+    if (IsExtRGB(cinfo->in_color_space))
+      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];
+    else if (cinfo->in_color_space == JCS_CMYK)
+      cinfo->input_components = 4;
+    else
+      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     row_width = (JDIMENSION)(biWidth * 4);
-  else
-    row_width = (JDIMENSION)biWidth;
+    break;
+  default:
+    ERREXIT(cinfo, JERR_BMP_BADDEPTH);
+  }
   while ((row_width & 3) != 0)
     row_width++;
   source->row_width = row_width;
 
-  /* Allocate space for inversion array, prepare for preload pass */
-  source->whole_image = (*cinfo->mem->request_virt_sarray)(
-      (j_common_ptr)cinfo, JPOOL_IMAGE, FALSE, row_width, (JDIMENSION)biHeight,
-      (JDIMENSION)1);
-  source->pub.get_pixel_rows = preload_image;
-  if (cinfo->progress != NULL) {
-    cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;
-    progress->total_extra_passes++; /* count file input as separate pass */
+  if (source->use_inversion_array) {
+    /* Allocate space for inversion array, prepare for preload pass */
+    source->whole_image = (*cinfo->mem->request_virt_sarray)(
+        (j_common_ptr)cinfo, JPOOL_IMAGE, FALSE, row_width,
+        (JDIMENSION)biHeight, (JDIMENSION)1);
+    source->pub.get_pixel_rows = preload_image;
+    if (cinfo->progress != NULL) {
+      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;
+      progress->total_extra_passes++; /* count file input as separate pass */
+    }
+  } else {
+    source->iobuffer = (U_CHAR *)(*cinfo->mem->alloc_small)(
+        (j_common_ptr)cinfo, JPOOL_IMAGE, row_width);
+    switch (source->bits_per_pixel) {
+    case 8:
+      source->pub.get_pixel_rows = get_8bit_row;
+      break;
+    case 24:
+      source->pub.get_pixel_rows = get_24bit_row;
+      break;
+    case 32:
+      source->pub.get_pixel_rows = get_32bit_row;
+      break;
+    default:
+      ERREXIT(cinfo, JERR_BMP_BADDEPTH);
+    }
   }
 
+  /* Ensure that biWidth * cinfo->input_components doesn't exceed the maximum
+     value of the JDIMENSION type.  This is only a danger with BMP files, since
+     their width and height fields are 32-bit integers. */
+  if ((unsigned long long)biWidth *
+          (unsigned long long)cinfo->input_components >
+      0xFFFFFFFFULL)
+    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   /* Allocate one-row buffer for returned data */
-  source->pub.buffer =
-      (*cinfo->mem->alloc_sarray)((j_common_ptr)cinfo, JPOOL_IMAGE,
-                                  (JDIMENSION)(biWidth * 3), (JDIMENSION)1);
+  source->pub.buffer = (*cinfo->mem->alloc_sarray)(
+      (j_common_ptr)cinfo, JPOOL_IMAGE,
+      (JDIMENSION)(biWidth * cinfo->input_components), (JDIMENSION)1);
   source->pub.buffer_height = 1;
 
-  cinfo->in_color_space = JCS_RGB;
-  cinfo->input_components = 3;
   cinfo->data_precision = 8;
   cinfo->image_width = (JDIMENSION)biWidth;
   cinfo->image_height = (JDIMENSION)biHeight;
@@ -454,18 +651,20 @@
  */
 
 GLOBAL(cjpeg_source_ptr)
-jinit_read_bmp(j_compress_ptr cinfo) {
+jinit_read_bmp(j_compress_ptr cinfo, boolean use_inversion_array) {
   bmp_source_ptr source;
 
   /* Create module interface object */
   source = (bmp_source_ptr)(*cinfo->mem->alloc_small)(
-      (j_common_ptr)cinfo, JPOOL_IMAGE, SIZEOF(bmp_source_struct));
+      (j_common_ptr)cinfo, JPOOL_IMAGE, sizeof(bmp_source_struct));
   source->cinfo = cinfo; /* make back link for subroutines */
   /* Fill in method ptrs, except get_pixel_rows which start_input sets */
   source->pub.start_input = start_input_bmp;
   source->pub.finish_input = finish_input_bmp;
 
-  return &source->pub;
+  source->use_inversion_array = use_inversion_array;
+
+  return (cjpeg_source_ptr)source;
 }
 
 #endif /* BMP_SUPPORTED */
