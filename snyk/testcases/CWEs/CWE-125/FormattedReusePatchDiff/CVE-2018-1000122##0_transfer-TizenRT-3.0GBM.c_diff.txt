--- /home/V1SCAN/CWE-125/FormattedUsed/transfer-TizenRT-3.0GBM.c	2023-12-10 02:51:51.178368587 +0900
+++ /home/V1SCAN/CWE-125/FormattedPatch/NEW##CVE-2018-1000122##0##curl@@curl##transfer.c	2023-12-10 02:51:51.568365532 +0900
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
@@ -81,11 +81,11 @@
 #include "curl_printf.h"
 #include "memdebug.h"
 
-#if !defined(CONFIG_DISABLE_HTTP) || !defined(CONFIG_DISABLE_SMTP) ||          \
-    !defined(CONFIG_DISABLE_IMAP)
+#if !defined(CURL_DISABLE_HTTP) || !defined(CURL_DISABLE_SMTP) ||              \
+    !defined(CURL_DISABLE_IMAP)
 /*
  * checkheaders() checks the linked list of custom headers for a
- * particular header (prefix).
+ * particular header (prefix). Provide the prefix without colon!
  *
  * Returns a pointer to the first matching header or NULL if none matched.
  */
@@ -96,7 +96,8 @@
   struct Curl_easy *data = conn->data;
 
   for (head = data->set.headers; head; head = head->next) {
-    if (strncasecompare(head->data, thisheader, thislen))
+    if (strncasecompare(head->data, thisheader, thislen) &&
+        Curl_headersep(head->data[thislen]))
       return head->data;
   }
 
@@ -133,8 +134,10 @@
 
   /* this function returns a size_t, so we typecast to int to prevent warnings
      with picky compilers */
+  Curl_set_in_callback(data, true);
   nread = (int)data->state.fread_func(data->req.upload_fromhere, 1, buffersize,
                                       data->state.in);
+  Curl_set_in_callback(data, false);
 
   if (nread == CURL_READFUNC_ABORT) {
     failf(data, "operation aborted by callback");
@@ -293,7 +296,9 @@
     if (data->set.seek_func) {
       int err;
 
+      Curl_set_in_callback(data, true);
       err = (data->set.seek_func)(data->set.seek_client, 0, SEEK_SET);
+      Curl_set_in_callback(data, false);
       if (err) {
         failf(data, "seek callback returned error %d", (int)err);
         return CURLE_SEND_FAIL_REWIND;
@@ -301,8 +306,10 @@
     } else if (data->set.ioctl_func) {
       curlioerr err;
 
+      Curl_set_in_callback(data, true);
       err = (data->set.ioctl_func)(data, CURLIOCMD_RESTARTREAD,
                                    data->set.ioctl_client);
+      Curl_set_in_callback(data, false);
       infof(data, "the ioctl callback returned %d\n", (int)err);
 
       if (err) {
@@ -332,7 +339,7 @@
   /* in the case of libssh2, we can never be really sure that we have emptied
      its internal buffers so we MUST always try until we get EAGAIN back */
   return conn->handler->protocol & (CURLPROTO_SCP | CURLPROTO_SFTP) ||
-#if defined(CONFIG_USE_NGHTTP2)
+#if defined(USE_NGHTTP2)
          Curl_ssl_data_pending(conn, FIRSTSOCKET) ||
          /* For HTTP/2, we may read up everything including responde body
             with header fields in Curl_http_readwrite_headers. If no
@@ -354,7 +361,7 @@
   conn->read_pos -= thismuch;
   conn->bits.stream_was_rewound = TRUE;
 
-#ifdef CONFIG_CURL_DEBUG
+#ifdef DEBUGBUILD
   {
     char buf[512 + 1];
     size_t show;
@@ -431,7 +438,7 @@
     size_t bytestoread = buffersize;
 
     if (
-#if defined(CONFIG_USE_NGHTTP2)
+#if defined(USE_NGHTTP2)
         /* For HTTP/2, read data without caring about the content
            length. This is safe because body in HTTP/2 is always
            segmented thanks to its framing layer. Meanwhile, we have to
@@ -501,7 +508,7 @@
         break;
     }
 
-#ifndef CONFIG_DISABLE_HTTP
+#ifndef CURL_DISABLE_HTTP
     /* Since this is a two-state thing, we check if we are parsing
        headers at the moment or not. */
     if (k->header) {
@@ -541,7 +548,7 @@
         break;
       }
     }
-#endif /* CONFIG_DISABLE_HTTP */
+#endif /* CURL_DISABLE_HTTP */
 
     /* This is not an 'else if' since it may be a rest from the header
        parsing, where the beginning of the buffer is headers and the end
@@ -555,7 +562,7 @@
         return CURLE_WEIRD_SERVER_REPLY;
       }
 
-#ifndef CONFIG_DISABLE_HTTP
+#ifndef CURL_DISABLE_HTTP
       if (0 == k->bodywrites && !is_empty_data) {
         /* These checks are only made the first time we are about to
            write a piece of the body */
@@ -619,7 +626,7 @@
 
         } /* this is HTTP or RTSP */
       }   /* this is the first time we write a body part */
-#endif    /* CONFIG_DISABLE_HTTP */
+#endif    /* CURL_DISABLE_HTTP */
 
       k->bodywrites++;
 
@@ -634,7 +641,7 @@
           Curl_debug(data, CURLINFO_DATA_IN, k->str, (size_t)nread, conn);
       }
 
-#ifndef CONFIG_DISABLE_HTTP
+#ifndef CURL_DISABLE_HTTP
       if (k->chunk) {
         /*
          * Here comes a chunked transfer flying and we need to decode this
@@ -677,7 +684,7 @@
         }
         /* If it returned OK, we just keep going */
       }
-#endif /* CONFIG_DISABLE_HTTP */
+#endif /* CURL_DISABLE_HTTP */
 
       /* Account for body content stored in the header buffer */
       if (k->badheader && !k->ignorebody) {
@@ -748,11 +755,11 @@
              encodings handled here. */
           if (conn->data->set.http_ce_skip || !k->writer_stack) {
             if (!k->ignorebody) {
-#ifndef CONFIG_DISABLE_POP3
+#ifndef CURL_DISABLE_POP3
               if (conn->handler->protocol & PROTO_FAMILY_POP3)
                 result = Curl_pop3_write(conn, k->str, nread);
               else
-#endif /* CONFIG_DISABLE_POP3 */
+#endif /* CURL_DISABLE_POP3 */
                 result =
                     Curl_client_write(conn, CLIENTWRITE_BODY, k->str, nread);
             }
@@ -767,10 +774,15 @@
 
     } /* if(!header and data to read) */
 
-    if (conn->handler->readwrite &&
-        (excess > 0 && !conn->bits.stream_was_rewound)) {
+    if (conn->handler->readwrite && excess && !conn->bits.stream_was_rewound) {
       /* Parse the excess data */
       k->str += nread;
+
+      if (&k->str[excess] > &k->buf[data->set.buffer_size]) {
+        /* the excess amount was too excessive(!), make sure
+           it doesn't read out of buffer */
+        excess = &k->buf[data->set.buffer_size] - k->str;
+      }
       nread = (ssize_t)excess;
 
       result = conn->handler->readwrite(data, conn, &nread, &readmore);
@@ -950,13 +962,13 @@
         }
       }
 
-#ifndef CONFIG_DISABLE_SMTP
+#ifndef CURL_DISABLE_SMTP
       if (conn->handler->protocol & PROTO_FAMILY_SMTP) {
         result = Curl_smtp_escape_eob(conn, nread);
         if (result)
           return result;
       }
-#endif /* CONFIG_DISABLE_SMTP */
+#endif /* CURL_DISABLE_SMTP */
     }  /* if 0 == k->upload_present */
     else {
       /* We have a partial buffer left from a previous "round". Use
@@ -1359,7 +1371,7 @@
   return CURLE_OK;
 }
 
-#ifndef CONFIG_DISABLE_HTTP
+#ifndef CURL_DISABLE_HTTP
 /*
  * Find the separator at the end of the host name, or the '?' in cases like
  * http://www.url.com?id=2380
@@ -1639,7 +1651,7 @@
 
   return newest;
 }
-#endif /* CONFIG_DISABLE_HTTP */
+#endif /* CURL_DISABLE_HTTP */
 
 /*
  * Curl_follow() handles the URL redirect magic. Pass in the 'newurl' string
@@ -1649,7 +1661,7 @@
                      char *newurl,    /* the Location: string */
                      followtype type) /* see transfer.h */
 {
-#ifdef CONFIG_DISABLE_HTTP
+#ifdef CURL_DISABLE_HTTP
   (void)data;
   (void)newurl;
   (void)type;
@@ -1842,7 +1854,7 @@
   Curl_pgrsResetTransferSizes(data);
 
   return CURLE_OK;
-#endif /* CONFIG_DISABLE_HTTP */
+#endif /* CURL_DISABLE_HTTP */
 }
 
 /* Returns CURLE_OK *and* sets '*url' if a request retry is wanted.
