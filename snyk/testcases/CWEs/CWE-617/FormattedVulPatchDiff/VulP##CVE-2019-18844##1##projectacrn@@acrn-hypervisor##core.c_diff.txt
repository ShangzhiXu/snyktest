--- /home/V1SCAN/CWE-617/FormattedVul/OLD##CVE-2019-18844##1##projectacrn@@acrn-hypervisor##core.c	2023-12-12 04:07:13.049436928 +0900
+++ /home/V1SCAN/CWE-617/FormattedPatch/NEW##CVE-2019-18844##1##projectacrn@@acrn-hypervisor##core.c	2023-12-12 04:07:13.579435643 +0900
@@ -397,11 +397,10 @@
   uint64_t offset;
   int bidx = (int)arg2;
 
-  assert(bidx <= PCI_BARMAX);
-  assert(pdi->bar[bidx].type == PCIBAR_MEM32 ||
-         pdi->bar[bidx].type == PCIBAR_MEM64);
-  assert(addr >= pdi->bar[bidx].addr &&
-         addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);
+  if (addr + size > pdi->bar[bidx].addr + pdi->bar[bidx].size) {
+    pr_err("%s, Out of emulated memory range\n", __func__);
+    return -ESRCH;
+  }
 
   offset = addr - pdi->bar[bidx].addr;
 
@@ -436,7 +435,10 @@
                                    uint64_t size, uint64_t *addr) {
   uint64_t base;
 
-  assert((size & (size - 1)) == 0); /* must be a power of 2 */
+  if ((size & (size - 1)) != 0) { /* must be a power of 2 */
+    pr_err("%s: Cannot alloc invalid size %lld resource\n", __func__, size);
+    return -1;
+  }
 
   base = roundup2(*baseptr, size);
 
@@ -457,8 +459,8 @@
  * Register (or unregister) the MMIO or I/O region associated with the BAR
  * register 'idx' of an emulated pci device.
  */
-static void modify_bar_registration(struct pci_vdev *dev, int idx,
-                                    int registration) {
+static int modify_bar_registration(struct pci_vdev *dev, int idx,
+                                   int registration) {
   int error;
   struct inout_port iop;
   struct mem_range mr;
@@ -475,7 +477,7 @@
      * acrn-dm.
      */
     printf("modify_bar_registration: bypass for pci-gvt\n");
-    return;
+    return 0;
   }
   switch (dev->bar[idx].type) {
   case PCIBAR_IO:
@@ -510,7 +512,8 @@
     error = EINVAL;
     break;
   }
-  assert(error == 0);
+
+  return error;
 }
 
 static void unregister_bar(struct pci_vdev *dev, int idx) {
@@ -575,7 +578,8 @@
     dev->bar[idx].addr |= addr;
     break;
   default:
-    assert(0);
+    pr_err("%s: invalid bar type %d\n", __func__, type);
+    return;
   }
 
   if (decode)
@@ -591,8 +595,6 @@
   int error;
   uint64_t *baseptr, limit, addr, mask, lobits, bar;
 
-  assert(idx >= 0 && idx <= PCI_BARMAX);
-
   if ((size & (size - 1)) != 0)
     size = 1UL << flsl(size); /* round up to a power of 2 */
 
@@ -617,6 +619,10 @@
     lobits = PCIM_BAR_IO_SPACE;
     break;
   case PCIBAR_MEM64:
+    if (idx + 1 > PCI_BARMAX) {
+      pr_err("%s: invalid bar number %d for MEM64 type\n", __func__, idx);
+      return -1;
+    }
     /*
      * FIXME
      * Some drivers do not work well if the 64-bit BAR is allocated
@@ -651,8 +657,8 @@
     lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32;
     break;
   default:
-    printf("%s: invalid bar type %d\n", __func__, type);
-    assert(0);
+    pr_err("%s: invalid bar type %d\n", __func__, type);
+    return -1;
   }
 
   if (baseptr != NULL) {
@@ -670,7 +676,6 @@
   pci_set_cfgdata32(pdi, PCIR_BAR(idx), bar);
 
   if (type == PCIBAR_MEM64) {
-    assert(idx + 1 <= PCI_BARMAX);
     pdi->bar[idx + 1].type = PCIBAR_MEMHI64;
     pci_set_cfgdata32(pdi, PCIR_BAR(idx + 1), bar >> 32);
   }
@@ -709,8 +714,6 @@
   int i, capoff, reallen;
   uint16_t sts;
 
-  assert(caplen > 0);
-
   reallen = roundup2(caplen, 4); /* dword aligned */
 
   sts = pci_get_cfgdata16(dev, PCIR_STATUS);
@@ -850,32 +853,34 @@
   }
 }
 
-void pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr) {
+int pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr) {
   int mmc;
 
   /* Number of msi messages must be a power of 2 between 1 and 32 */
-  assert((msgnum & (msgnum - 1)) == 0 && msgnum >= 1 && msgnum <= 32);
+  if (((msgnum & (msgnum - 1)) != 0) || msgnum < 1 || msgnum > 32) {
+    pr_err("%s: invalid number of msi messages!\n", __func__);
+    return -1;
+  }
   mmc = ffs(msgnum) - 1;
 
   bzero(msicap, sizeof(struct msicap));
   msicap->capid = PCIY_MSI;
   msicap->nextptr = nextptr;
   msicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);
+
+  return 0;
 }
 
 int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
   struct msicap msicap;
 
-  pci_populate_msicap(&msicap, msgnum, 0);
-
-  return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
+  return pci_populate_msicap(&msicap, msgnum, 0) ||
+         pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
 }
 
 static void pci_populate_msixcap(struct msixcap *msixcap, int msgnum,
                                  int barnum, uint32_t msix_tab_size) {
 
-  assert(msix_tab_size % 4096 == 0);
-
   bzero(msixcap, sizeof(struct msixcap));
   msixcap->capid = PCIY_MSIX;
 
@@ -895,28 +900,31 @@
   msixcap->pba_info = msix_tab_size | (barnum & PCIM_MSIX_BIR_MASK);
 }
 
-static void pci_msix_table_init(struct pci_vdev *dev, int table_entries) {
+static int pci_msix_table_init(struct pci_vdev *dev, int table_entries) {
   int i, table_size;
 
-  assert(table_entries > 0);
-  assert(table_entries <= MAX_MSIX_TABLE_ENTRIES);
-
   table_size = table_entries * MSIX_TABLE_ENTRY_SIZE;
   dev->msix.table = calloc(1, table_size);
-
-  assert(dev->msix.table != NULL);
+  if (!dev->msix.table) {
+    pr_err("%s: Cannot alloc memory!\n", __func__);
+    return -1;
+  }
 
   /* set mask bit of vector control register */
   for (i = 0; i < table_entries; i++)
     dev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;
+
+  return 0;
 }
 
 int pci_emul_add_msixcap(struct pci_vdev *dev, int msgnum, int barnum) {
   uint32_t tab_size;
   struct msixcap msixcap;
 
-  assert(msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES);
-  assert(barnum >= 0 && barnum <= PCIR_MAX_BAR_0);
+  if (msgnum > MAX_MSIX_TABLE_ENTRIES) {
+    pr_err("%s: Too many entries!\n", __func__);
+    return -1;
+  }
 
   tab_size = msgnum * MSIX_TABLE_ENTRY_SIZE;
 
@@ -930,7 +938,8 @@
   dev->msix.pba_offset = tab_size;
   dev->msix.pba_size = PBA_SIZE(msgnum);
 
-  pci_msix_table_init(dev, msgnum);
+  if (pci_msix_table_init(dev, msgnum) != 0)
+    return -1;
 
   pci_populate_msixcap(&msixcap, msgnum, barnum, tab_size);
 
@@ -1055,7 +1064,6 @@
 
     capoff = nextoff;
   }
-  assert(offset >= capoff);
 
   /*
    * Capability ID and Next Capability Pointer are readonly.
@@ -1168,8 +1176,10 @@
         if (fi->fi_name == NULL)
           continue;
         ops = pci_emul_finddev(fi->fi_name);
-        assert(ops != NULL);
-
+        if (!ops) {
+          pr_warn("No driver for device [%s]\n", fi->fi_name);
+          continue;
+        }
         pr_notice("pci init %s\r\n", fi->fi_name);
         error = pci_emul_init(ctx, ops, bus, slot, func, fi);
         if (error) {
@@ -1250,7 +1260,8 @@
   mr.size = (4ULL * 1024 * 1024 * 1024) - lowmem;
   mr.handler = pci_emul_fallback_handler;
   error = register_mem_fallback(&mr);
-  assert(error == 0);
+  if (error != 0)
+    goto pci_emul_init_fail;
 
   /* ditto for the 64-bit PCI host aperture */
   bzero(&mr, sizeof(struct mem_range));
@@ -1260,7 +1271,8 @@
   mr.size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64;
   mr.handler = pci_emul_fallback_handler;
   error = register_mem_fallback(&mr);
-  assert(error == 0);
+  if (error != 0)
+    goto pci_emul_init_fail;
 
   /* PCI extended config space */
   bzero(&mr, sizeof(struct mem_range));
@@ -1270,7 +1282,8 @@
   mr.size = PCI_EMUL_ECFG_SIZE;
   mr.handler = pci_emul_ecfg_handler;
   error = register_mem(&mr);
-  assert(error == 0);
+  if (error != 0)
+    goto pci_emul_init_fail;
 
   return 0;
 
@@ -1288,7 +1301,10 @@
         if (success_cnt-- <= 0)
           break;
         ops = pci_emul_finddev(fi->fi_name);
-        assert(ops != NULL);
+        if (!ops) {
+          pr_warn("No driver for device [%s]\n", fi->fi_name);
+          continue;
+        }
         pci_emul_deinit(ctx, ops, bus, slot, func, fi);
       }
     }
@@ -1340,8 +1356,10 @@
         if (fi->fi_name == NULL)
           continue;
         ops = pci_emul_finddev(fi->fi_name);
-        assert(ops != NULL);
-
+        if (!ops) {
+          pr_warn("No driver for device [%s]\n", fi->fi_name);
+          continue;
+        }
         pr_notice("pci deinit %s\n", fi->fi_name);
         pci_emul_deinit(ctx, ops, bus, slot, func, fi);
       }
@@ -1451,7 +1469,6 @@
       goto done;
     }
   }
-  assert(bi != NULL);
 
   /* i/o window */
   dsdt_line("      WordIO (ResourceProducer, MinFixed, MaxFixed, "
@@ -1544,10 +1561,7 @@
   dsdt_unindent(1);
 }
 
-int pci_bus_configured(int bus) {
-  assert(bus >= 0 && bus < MAXBUSES);
-  return (pci_businfo[bus] != NULL);
-}
+int pci_bus_configured(int bus) { return (pci_businfo[bus] != NULL); }
 
 int pci_msi_enabled(struct pci_vdev *dev) { return dev->msi.enabled; }
 
@@ -1616,7 +1630,11 @@
   int bestpin, bestcount, pin;
 
   bi = pci_businfo[dev->bus];
-  assert(bi != NULL);
+  if (bi == NULL) {
+    pr_err("%s: pci [%s] has wrong bus %d info!\n", __func__, dev->name,
+           dev->bus);
+    return;
+  }
 
   /*
    * Just allocate a pin from our slot.  The pin will be
@@ -1643,7 +1661,11 @@
   int pin;
 
   bi = pci_businfo[dev->bus];
-  assert(bi != NULL);
+  if (bi == NULL) {
+    pr_err("%s: pci [%s] has wrong bus %d info!\n", __func__, dev->name,
+           dev->bus);
+    return;
+  }
 
   si = &bi->slotinfo[dev->slot];
 
@@ -1662,7 +1684,11 @@
     return;
 
   bi = pci_businfo[dev->bus];
-  assert(bi != NULL);
+  if (bi == NULL) {
+    pr_err("%s: pci [%s] has wrong bus %d info!\n", __func__, dev->name,
+           dev->bus);
+    return;
+  }
   ii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];
 
   /*
@@ -1671,7 +1697,6 @@
    */
   if (ii->ii_ioapic_irq == 0)
     ii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);
-  assert(ii->ii_ioapic_irq > 0);
 
   /*
    * Attempt to allocate a PIRQ pin for this intpin if one is
@@ -1679,7 +1704,6 @@
    */
   if (ii->ii_pirq_pin == 0)
     ii->ii_pirq_pin = pirq_alloc_pin(dev);
-  assert(ii->ii_pirq_pin > 0);
 
   dev->lintr.ioapic_irq = ii->ii_ioapic_irq;
   dev->lintr.pirq_pin = ii->ii_pirq_pin;
@@ -1694,7 +1718,10 @@
  * @return None
  */
 void pci_lintr_assert(struct pci_vdev *dev) {
-  assert(dev->lintr.pin > 0);
+  if (dev->lintr.pin <= 0) {
+    pr_warn("%s: Invalid intr pin on dev [%s]\n", __func__, dev->name);
+    return;
+  }
 
   pthread_mutex_lock(&dev->lintr.lock);
   if (dev->lintr.state == IDLE) {
@@ -1715,7 +1742,10 @@
  * @return None
  */
 void pci_lintr_deassert(struct pci_vdev *dev) {
-  assert(dev->lintr.pin > 0);
+  if (dev->lintr.pin <= 0) {
+    pr_warn("%s: Invalid intr pin on dev [%s]\n", __func__, dev->name);
+    return;
+  }
 
   pthread_mutex_lock(&dev->lintr.lock);
   if (dev->lintr.state == ASSERTED) {
@@ -1876,7 +1906,8 @@
       }
       break;
     default:
-      assert(0);
+      pr_err("%s: invalid bar type %d\n", __func__, dev->bar[i].type);
+      return;
     }
   }
 
@@ -2032,7 +2063,6 @@
         }
         break;
       case PCIBAR_MEMHI64:
-        assert(idx >= 1);
         mask = ~(dev->bar[idx - 1].size - 1);
         addr = ((uint64_t)*eax << 32) & mask;
         bar = addr >> 32;
@@ -2042,7 +2072,8 @@
         }
         break;
       default:
-        assert(0);
+        pr_err("%s: invalid bar type %d\n", __func__, dev->bar[idx].type);
+        return;
       }
       pci_set_cfgdata32(dev, coff, bar);
 
@@ -2132,7 +2163,6 @@
 #define PCI_EMUL_MSIX_MSGS 16
 
 static int pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts) {
-  int error;
   struct pci_emul_dummy *dummy;
 
   dummy = calloc(1, sizeof(struct pci_emul_dummy));
@@ -2143,19 +2173,10 @@
   pci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);
   pci_set_cfgdata8(dev, PCIR_CLASS, 0x02);
 
-  error = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);
-  assert(error == 0);
-
-  error = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);
-  assert(error == 0);
-
-  error = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);
-  assert(error == 0);
-
-  error = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);
-  assert(error == 0);
-
-  return 0;
+  return pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS) ||
+         pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ) ||
+         pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ) ||
+         pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);
 }
 
 static void pci_emul_diow(struct vmctx *ctx, int vcpu, struct pci_vdev *dev,
@@ -2282,7 +2303,8 @@
   struct pci_vdev *dev = NULL;
 
   bi = pci_businfo[0];
-  assert(bi != NULL);
+  if (bi == NULL)
+    return NULL;
 
   si = &bi->slotinfo[slot];
   if (si != NULL)
