--- /home/V1SCAN/CWE-287/FormattedUsed/x509_crt-reactos-0.4.13.c	2023-12-12 04:53:56.829769597 +0900
+++ /home/V1SCAN/CWE-287/FormattedPatch/NEW##CVE-2017-14032##0##ARMmbed@@mbedtls##x509_crt.c	2023-12-12 04:53:56.899769968 +0900
@@ -2,21 +2,19 @@
  *  X.509 certificate parsing and verification
  *
  *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
- *  SPDX-License-Identifier: GPL-2.0
+ *  SPDX-License-Identifier: Apache-2.0
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  *
  *  This file is part of mbed TLS (https://tls.mbed.org)
  */
@@ -42,6 +40,7 @@
 #include "mbedtls/oid.h"
 #include "mbedtls/x509_crt.h"
 
+#include <stdio.h>
 #include <string.h>
 
 #if defined(MBEDTLS_PEM_PARSE_C)
@@ -51,7 +50,6 @@
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
-#include <stdio.h>
 #include <stdlib.h>
 #define mbedtls_free free
 #define mbedtls_calloc calloc
@@ -134,8 +132,7 @@
     MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
         MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384),
     /* Only ECDSA */
-    MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECDSA) |
-        MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECKEY),
+    MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECDSA),
 #if defined(MBEDTLS_ECP_C)
     /* Only NIST P-256 and P-384 */
     MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
@@ -152,9 +149,6 @@
  */
 static int x509_profile_check_md_alg(const mbedtls_x509_crt_profile *profile,
                                      mbedtls_md_type_t md_alg) {
-  if (md_alg == MBEDTLS_MD_NONE)
-    return (-1);
-
   if ((profile->allowed_mds & MBEDTLS_X509_ID_FLAG(md_alg)) != 0)
     return (0);
 
@@ -167,9 +161,6 @@
  */
 static int x509_profile_check_pk_alg(const mbedtls_x509_crt_profile *profile,
                                      mbedtls_pk_type_t pk_alg) {
-  if (pk_alg == MBEDTLS_PK_NONE)
-    return (-1);
-
   if ((profile->allowed_pks & MBEDTLS_X509_ID_FLAG(pk_alg)) != 0)
     return (0);
 
@@ -197,9 +188,6 @@
       pk_alg == MBEDTLS_PK_ECKEY_DH) {
     mbedtls_ecp_group_id gid = mbedtls_pk_ec(*pk)->grp.id;
 
-    if (gid == MBEDTLS_ECP_DP_NONE)
-      return (-1);
-
     if ((profile->allowed_curves & MBEDTLS_X509_ID_FLAG(gid)) != 0)
       return (0);
 
@@ -226,7 +214,7 @@
       return (0);
     }
 
-    return (MBEDTLS_ERR_X509_INVALID_FORMAT + ret);
+    return (ret);
   }
 
   end = *p + len;
@@ -288,7 +276,7 @@
     if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG)
       return (0);
 
-    return (MBEDTLS_ERR_X509_INVALID_FORMAT + ret);
+    return (ret);
   }
 
   uid->p = *p;
@@ -460,10 +448,9 @@
     if ((ret = mbedtls_asn1_get_len(p, end, &tag_len)) != 0)
       return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret);
 
-    if ((tag & MBEDTLS_ASN1_TAG_CLASS_MASK) != MBEDTLS_ASN1_CONTEXT_SPECIFIC) {
+    if ((tag & MBEDTLS_ASN1_CONTEXT_SPECIFIC) != MBEDTLS_ASN1_CONTEXT_SPECIFIC)
       return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
               MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
-    }
 
     /* Skip everything but DNS name */
     if (tag != (MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2)) {
@@ -512,13 +499,13 @@
   size_t len;
   unsigned char *end_ext_data, *end_ext_octet;
 
-  if (*p == end)
-    return (0);
+  if ((ret = mbedtls_x509_get_ext(p, end, &crt->v3_ext, 3)) != 0) {
+    if (ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG)
+      return (0);
 
-  if ((ret = mbedtls_x509_get_ext(p, end, &crt->v3_ext, 3)) != 0)
     return (ret);
+  }
 
-  end = crt->v3_ext.p + crt->v3_ext.len;
   while (*p < end) {
     /*
      * Extension  ::=  SEQUENCE  {
@@ -538,14 +525,19 @@
     end_ext_data = *p + len;
 
     /* Get extension ID */
-    if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &extn_oid.len,
-                                    MBEDTLS_ASN1_OID)) != 0)
+    extn_oid.tag = **p;
+
+    if ((ret = mbedtls_asn1_get_tag(p, end, &extn_oid.len, MBEDTLS_ASN1_OID)) !=
+        0)
       return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret);
 
-    extn_oid.tag = MBEDTLS_ASN1_OID;
     extn_oid.p = *p;
     *p += extn_oid.len;
 
+    if ((end - *p) < 1)
+      return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
+              MBEDTLS_ERR_ASN1_OUT_OF_DATA);
+
     /* Get optional critical */
     if ((ret = mbedtls_asn1_get_bool(p, end_ext_data, &is_critical)) != 0 &&
         (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG))
@@ -719,13 +711,13 @@
     return (ret);
   }
 
-  if (crt->version < 0 || crt->version > 2) {
+  crt->version++;
+
+  if (crt->version > 3) {
     mbedtls_x509_crt_free(crt);
     return (MBEDTLS_ERR_X509_UNKNOWN_VERSION);
   }
 
-  crt->version++;
-
   if ((ret = mbedtls_x509_get_sig_alg(&crt->sig_oid, &sig_params1, &crt->sig_md,
                                       &crt->sig_pk, &crt->sig_opts)) != 0) {
     mbedtls_x509_crt_free(crt);
@@ -1077,10 +1069,8 @@
     w_ret = WideCharToMultiByte(CP_ACP, 0, file_data.cFileName,
                                 lstrlenW(file_data.cFileName), p, (int)len - 1,
                                 NULL, NULL);
-    if (w_ret == 0) {
-      ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
-      goto cleanup;
-    }
+    if (w_ret == 0)
+      return (MBEDTLS_ERR_X509_FILE_IO_ERROR);
 
     w_ret = mbedtls_x509_crt_parse_file(chain, filename);
     if (w_ret < 0)
@@ -1092,7 +1082,6 @@
   if (GetLastError() != ERROR_NO_MORE_FILES)
     ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
 
-cleanup:
   FindClose(hFind);
 #else /* _WIN32 */
   int t_ret;
@@ -1105,12 +1094,12 @@
   if (dir == NULL)
     return (MBEDTLS_ERR_X509_FILE_IO_ERROR);
 
-#if defined(MBEDTLS_THREADING_C)
+#if defined(MBEDTLS_THREADING_PTHREAD)
   if ((ret = mbedtls_mutex_lock(&mbedtls_threading_readdir_mutex)) != 0) {
     closedir(dir);
     return (ret);
   }
-#endif /* MBEDTLS_THREADING_C */
+#endif
 
   while ((entry = readdir(dir)) != NULL) {
     snp_ret = mbedtls_snprintf(entry_name, sizeof entry_name, "%s/%s", path,
@@ -1139,10 +1128,10 @@
 cleanup:
   closedir(dir);
 
-#if defined(MBEDTLS_THREADING_C)
+#if defined(MBEDTLS_THREADING_PTHREAD)
   if (mbedtls_mutex_unlock(&mbedtls_threading_readdir_mutex) != 0)
     ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
-#endif /* MBEDTLS_THREADING_C */
+#endif
 
 #endif /* _WIN32 */
 
@@ -1275,121 +1264,6 @@
 }
 
 /*
- * Like memcmp, but case-insensitive and always returns -1 if different
- */
-static int x509_memcasecmp(const void *s1, const void *s2, size_t len) {
-  size_t i;
-  unsigned char diff;
-  const unsigned char *n1 = s1, *n2 = s2;
-
-  for (i = 0; i < len; i++) {
-    diff = n1[i] ^ n2[i];
-
-    if (diff == 0)
-      continue;
-
-    if (diff == 32 &&
-        ((n1[i] >= 'a' && n1[i] <= 'z') || (n1[i] >= 'A' && n1[i] <= 'Z'))) {
-      continue;
-    }
-
-    return (-1);
-  }
-
-  return (0);
-}
-
-/*
- * Return 0 if name matches wildcard, -1 otherwise
- */
-static int x509_check_wildcard(const char *cn, mbedtls_x509_buf *name) {
-  size_t i;
-  size_t cn_idx = 0, cn_len = strlen(cn);
-
-  if (name->len < 3 || name->p[0] != '*' || name->p[1] != '.')
-    return (0);
-
-  for (i = 0; i < cn_len; ++i) {
-    if (cn[i] == '.') {
-      cn_idx = i;
-      break;
-    }
-  }
-
-  if (cn_idx == 0)
-    return (-1);
-
-  if (cn_len - cn_idx == name->len - 1 &&
-      x509_memcasecmp(name->p + 1, cn + cn_idx, name->len - 1) == 0) {
-    return (0);
-  }
-
-  return (-1);
-}
-
-/*
- * Compare two X.509 strings, case-insensitive, and allowing for some encoding
- * variations (but not all).
- *
- * Return 0 if equal, -1 otherwise.
- */
-static int x509_string_cmp(const mbedtls_x509_buf *a,
-                           const mbedtls_x509_buf *b) {
-  if (a->tag == b->tag && a->len == b->len && memcmp(a->p, b->p, b->len) == 0) {
-    return (0);
-  }
-
-  if ((a->tag == MBEDTLS_ASN1_UTF8_STRING ||
-       a->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
-      (b->tag == MBEDTLS_ASN1_UTF8_STRING ||
-       b->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
-      a->len == b->len && x509_memcasecmp(a->p, b->p, b->len) == 0) {
-    return (0);
-  }
-
-  return (-1);
-}
-
-/*
- * Compare two X.509 Names (aka rdnSequence).
- *
- * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
- * we sometimes return unequal when the full algorithm would return equal,
- * but never the other way. (In particular, we don't do Unicode normalisation
- * or space folding.)
- *
- * Return 0 if equal, -1 otherwise.
- */
-static int x509_name_cmp(const mbedtls_x509_name *a,
-                         const mbedtls_x509_name *b) {
-  /* Avoid recursion, it might not be optimised by the compiler */
-  while (a != NULL || b != NULL) {
-    if (a == NULL || b == NULL)
-      return (-1);
-
-    /* type */
-    if (a->oid.tag != b->oid.tag || a->oid.len != b->oid.len ||
-        memcmp(a->oid.p, b->oid.p, b->oid.len) != 0) {
-      return (-1);
-    }
-
-    /* value */
-    if (x509_string_cmp(&a->val, &b->val) != 0)
-      return (-1);
-
-    /* structure of the list of sets */
-    if (a->next_merged != b->next_merged)
-      return (-1);
-
-    a = a->next;
-    b = b->next;
-  }
-
-  /* a == NULL == b */
-  return (0);
-}
-
-/*
  * Return an informational string about the certificate.
  */
 #define BEFORE_COLON 18
@@ -1664,7 +1538,7 @@
 
 /*
  * Check that the given certificate is not revoked according to the CRL.
- * Skip validation if no CRL for the given CA is present.
+ * Skip validation is no CRL for the given CA is present.
  */
 static int x509_crt_verifycrl(mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
                               mbedtls_x509_crl *crl_list,
@@ -1678,7 +1552,9 @@
 
   while (crl_list != NULL) {
     if (crl_list->version == 0 ||
-        x509_name_cmp(&crl_list->issuer, &ca->subject) != 0) {
+        crl_list->issuer_raw.len != ca->subject_raw.len ||
+        memcmp(crl_list->issuer_raw.p, ca->subject_raw.p,
+               crl_list->issuer_raw.len) != 0) {
       crl_list = crl_list->next;
       continue;
     }
@@ -1703,12 +1579,16 @@
       flags |= MBEDTLS_X509_BADCRL_BAD_PK;
 
     md_info = mbedtls_md_info_from_type(crl_list->sig_md);
-    if (mbedtls_md(md_info, crl_list->tbs.p, crl_list->tbs.len, hash) != 0) {
-      /* Note: this can't happen except after an internal error */
+    if (md_info == NULL) {
+      /*
+       * Cannot check 'unknown' hash
+       */
       flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
       break;
     }
 
+    mbedtls_md(md_info, crl_list->tbs.p, crl_list->tbs.len, hash);
+
     if (x509_profile_check_key(profile, crl_list->sig_pk, &ca->pk) != 0)
       flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 
@@ -1745,6 +1625,121 @@
 #endif /* MBEDTLS_X509_CRL_PARSE_C */
 
 /*
+ * Like memcmp, but case-insensitive and always returns -1 if different
+ */
+static int x509_memcasecmp(const void *s1, const void *s2, size_t len) {
+  size_t i;
+  unsigned char diff;
+  const unsigned char *n1 = s1, *n2 = s2;
+
+  for (i = 0; i < len; i++) {
+    diff = n1[i] ^ n2[i];
+
+    if (diff == 0)
+      continue;
+
+    if (diff == 32 &&
+        ((n1[i] >= 'a' && n1[i] <= 'z') || (n1[i] >= 'A' && n1[i] <= 'Z'))) {
+      continue;
+    }
+
+    return (-1);
+  }
+
+  return (0);
+}
+
+/*
+ * Return 0 if name matches wildcard, -1 otherwise
+ */
+static int x509_check_wildcard(const char *cn, mbedtls_x509_buf *name) {
+  size_t i;
+  size_t cn_idx = 0, cn_len = strlen(cn);
+
+  if (name->len < 3 || name->p[0] != '*' || name->p[1] != '.')
+    return (0);
+
+  for (i = 0; i < cn_len; ++i) {
+    if (cn[i] == '.') {
+      cn_idx = i;
+      break;
+    }
+  }
+
+  if (cn_idx == 0)
+    return (-1);
+
+  if (cn_len - cn_idx == name->len - 1 &&
+      x509_memcasecmp(name->p + 1, cn + cn_idx, name->len - 1) == 0) {
+    return (0);
+  }
+
+  return (-1);
+}
+
+/*
+ * Compare two X.509 strings, case-insensitive, and allowing for some encoding
+ * variations (but not all).
+ *
+ * Return 0 if equal, -1 otherwise.
+ */
+static int x509_string_cmp(const mbedtls_x509_buf *a,
+                           const mbedtls_x509_buf *b) {
+  if (a->tag == b->tag && a->len == b->len && memcmp(a->p, b->p, b->len) == 0) {
+    return (0);
+  }
+
+  if ((a->tag == MBEDTLS_ASN1_UTF8_STRING ||
+       a->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
+      (b->tag == MBEDTLS_ASN1_UTF8_STRING ||
+       b->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
+      a->len == b->len && x509_memcasecmp(a->p, b->p, b->len) == 0) {
+    return (0);
+  }
+
+  return (-1);
+}
+
+/*
+ * Compare two X.509 Names (aka rdnSequence).
+ *
+ * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
+ * we sometimes return unequal when the full algorithm would return equal,
+ * but never the other way. (In particular, we don't do Unicode normalisation
+ * or space folding.)
+ *
+ * Return 0 if equal, -1 otherwise.
+ */
+static int x509_name_cmp(const mbedtls_x509_name *a,
+                         const mbedtls_x509_name *b) {
+  /* Avoid recursion, it might not be optimised by the compiler */
+  while (a != NULL || b != NULL) {
+    if (a == NULL || b == NULL)
+      return (-1);
+
+    /* type */
+    if (a->oid.tag != b->oid.tag || a->oid.len != b->oid.len ||
+        memcmp(a->oid.p, b->oid.p, b->oid.len) != 0) {
+      return (-1);
+    }
+
+    /* value */
+    if (x509_string_cmp(&a->val, &b->val) != 0)
+      return (-1);
+
+    /* structure of the list of sets */
+    if (a->next_merged != b->next_merged)
+      return (-1);
+
+    a = a->next;
+    b = b->next;
+  }
+
+  /* a == NULL == b */
+  return (0);
+}
+
+/*
  * Check if 'parent' is a suitable parent (signing CA) for 'child'.
  * Return 0 if yes, -1 if not.
  *
@@ -1786,27 +1781,6 @@
   return (0);
 }
 
-/*
- * Verify a certificate with no parent inside the chain
- * (either the parent is a trusted root, or there is no parent)
- *
- * See comments for mbedtls_x509_crt_verify_with_profile()
- * (also for notation used below)
- *
- * This function is called in two cases:
- *  - child was found to have a parent in trusted roots, in which case we're
- *    called with trust_ca pointing directly to that parent (not the full list)
- *      - this is cases 1, 2 and 3 of the comment on verify_with_profile()
- *      - case 1 is special as child and trust_ca point to copies of the same
- *        certificate then
- *  - child was found to have no parent either in the chain or in trusted CAs
- *      - this is cases 4 and 5 of the comment on verify_with_profile()
- *
- * For historical reasons, the function currently does not assume that
- * trust_ca points directly to the right root in the first case, and it
- * doesn't know in which case it starts, so it always starts by searching for
- * a parent in trust_ca.
- */
 static int x509_crt_verify_top(
     mbedtls_x509_crt *child, mbedtls_x509_crt *trust_ca,
     mbedtls_x509_crl *ca_crl, const mbedtls_x509_crt_profile *profile,
@@ -1837,11 +1811,13 @@
   *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
 
   md_info = mbedtls_md_info_from_type(child->sig_md);
-  if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
-    /* Note: this can't happen except after an internal error */
-    /* Cannot check signature, no need to try any CA */
+  if (md_info == NULL) {
+    /*
+     * Cannot check 'unknown', no need to try any CA
+     */
     trust_ca = NULL;
-  }
+  } else
+    mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash);
 
   for (/* trust_ca */; trust_ca != NULL; trust_ca = trust_ca->next) {
     if (x509_crt_check_parent(child, trust_ca, 1, path_cnt == 0) != 0)
@@ -1855,7 +1831,7 @@
      */
     if (child->subject_raw.len == trust_ca->subject_raw.len &&
         memcmp(child->subject_raw.p, trust_ca->subject_raw.p,
-               child->subject_raw.len) == 0) {
+               child->issuer_raw.len) == 0) {
       check_path_cnt--;
     }
 
@@ -1900,7 +1876,7 @@
   if (trust_ca != NULL &&
       (child->subject_raw.len != trust_ca->subject_raw.len ||
        memcmp(child->subject_raw.p, trust_ca->subject_raw.p,
-              child->subject_raw.len) != 0)) {
+              child->issuer_raw.len) != 0)) {
 #if defined(MBEDTLS_X509_CRL_PARSE_C)
     /* Check trusted CA's CRL for the chain's top crt */
     *flags |= x509_crt_verifycrl(child, trust_ca, ca_crl, profile);
@@ -1932,11 +1908,6 @@
   return (0);
 }
 
-/*
- * Verify a certificate with a parent inside the chain
- *
- * See comments for mbedtls_x509_crt_verify_with_profile()
- */
 static int x509_crt_verify_child(
     mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
     mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
@@ -1955,8 +1926,8 @@
 
   /* path_cnt is 0 for the first intermediate CA */
   if (1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA) {
-    /* return immediately as the goal is to avoid unbounded recursion */
-    return (MBEDTLS_ERR_X509_FATAL_ERROR);
+    *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
+    return (MBEDTLS_ERR_X509_CERT_VERIFY_FAILED);
   }
 
   if (mbedtls_x509_time_is_past(&child->valid_to))
@@ -1972,10 +1943,14 @@
     *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
 
   md_info = mbedtls_md_info_from_type(child->sig_md);
-  if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
-    /* Note: this can't happen except after an internal error */
+  if (md_info == NULL) {
+    /*
+     * Cannot check 'unknown' hash
+     */
     *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
   } else {
+    mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash);
+
     if (x509_profile_check_key(profile, child->sig_pk, &parent->pk) != 0)
       *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 
@@ -2059,34 +2034,6 @@
 
 /*
  * Verify the certificate validity, with profile
- *
- * The chain building/verification is spread accross 4 functions:
- *  - this one
- *  - x509_crt_verify_child()
- *  - x509_crt_verify_top()
- *  - x509_crt_check_parent()
- *
- * There are five main cases to consider. Let's introduce some notation:
- *  - E means the end-entity certificate
- *  - I an intermediate CA
- *  - R the trusted root CA this chain anchors to
- *  - T the list of trusted roots (R and possible some others)
- *
- * The main cases with the calling sequence of the crt_verify_xxx() are:
- *  1. E = R (explicitly trusted EE cert)
- *      verify(E, T) -> verify_top(E, R)
- *  2. E -> R (EE signed by trusted root)
- *      verify(E, T) -> verify_top(E, R)
- *  3. E -> I -> R (EE signed by intermediate signed by trusted root)
- *      verify(E, T) -> verify_child(E, I, T) -> verify_top(I, R)
- *      (plus variant with multiple intermediates)
- *  4. E -> I (EE signed by intermediate that's not trusted)
- *      verify(E, T) -> verify_child(E, I, T) -> verify_top(I, T)
- *      (plus variant with multiple intermediates)
- *  5. E (EE not trusted)
- *      verify(E, T) -> verify_top(E, T)
- *
- * Note: this notation and case numbering is also used in x509_crt_verify_top()
  */
 int mbedtls_x509_crt_verify_with_profile(
     mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
@@ -2190,12 +2137,6 @@
   }
 
 exit:
-  /* prevent misuse of the vrfy callback - VERIFY_FAILED would be ignored by
-   * the SSL module for authmode optional, but non-zero return from the
-   * callback means a fatal error so it shouldn't be ignored */
-  if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED)
-    ret = MBEDTLS_ERR_X509_FATAL_ERROR;
-
   if (ret != 0) {
     *flags = (uint32_t)-1;
     return (ret);
