--- /home/V1SCAN/CWE-287/FormattedUsed/x509_crt-TizenRT-3.0GBM.c	2023-12-12 04:54:04.929859939 +0900
+++ /home/V1SCAN/CWE-287/FormattedVul/OLD##CVE-2017-14032##0##ARMmbed@@mbedtls##x509_crt.c	2023-12-12 04:54:05.079862809 +0900
@@ -1,21 +1,3 @@
-/****************************************************************************
- *
- * Copyright 2016 Samsung Electronics All Rights Reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific
- * language governing permissions and limitations under the License.
- *
- ****************************************************************************/
-
 /*
  *  X.509 certificate parsing and verification
  *
@@ -58,6 +40,7 @@
 #include "mbedtls/oid.h"
 #include "mbedtls/x509_crt.h"
 
+#include <stdio.h>
 #include <string.h>
 
 #if defined(MBEDTLS_PEM_PARSE_C)
@@ -67,7 +50,6 @@
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
 #else
-#include <stdio.h>
 #include <stdlib.h>
 #define mbedtls_free free
 #define mbedtls_calloc calloc
@@ -80,9 +62,6 @@
 
 #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
 #include <windows.h>
-#if defined(MBEDTLS_OCF_PATCH)
-#include <intsafe.h>
-#endif
 #else
 #include <time.h>
 #endif
@@ -153,8 +132,7 @@
     MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA256) |
         MBEDTLS_X509_ID_FLAG(MBEDTLS_MD_SHA384),
     /* Only ECDSA */
-    MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECDSA) |
-        MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECKEY),
+    MBEDTLS_X509_ID_FLAG(MBEDTLS_PK_ECDSA),
 #if defined(MBEDTLS_ECP_C)
     /* Only NIST P-256 and P-384 */
     MBEDTLS_X509_ID_FLAG(MBEDTLS_ECP_DP_SECP256R1) |
@@ -171,9 +149,6 @@
  */
 static int x509_profile_check_md_alg(const mbedtls_x509_crt_profile *profile,
                                      mbedtls_md_type_t md_alg) {
-  if (md_alg == MBEDTLS_MD_NONE)
-    return (-1);
-
   if ((profile->allowed_mds & MBEDTLS_X509_ID_FLAG(md_alg)) != 0)
     return (0);
 
@@ -186,9 +161,6 @@
  */
 static int x509_profile_check_pk_alg(const mbedtls_x509_crt_profile *profile,
                                      mbedtls_pk_type_t pk_alg) {
-  if (pk_alg == MBEDTLS_PK_NONE)
-    return (-1);
-
   if ((profile->allowed_pks & MBEDTLS_X509_ID_FLAG(pk_alg)) != 0)
     return (0);
 
@@ -216,9 +188,6 @@
       pk_alg == MBEDTLS_PK_ECKEY_DH) {
     mbedtls_ecp_group_id gid = mbedtls_pk_ec(*pk)->grp.id;
 
-    if (gid == MBEDTLS_ECP_DP_NONE)
-      return (-1);
-
     if ((profile->allowed_curves & MBEDTLS_X509_ID_FLAG(gid)) != 0)
       return (0);
 
@@ -450,30 +419,14 @@
  *
  * NOTE: we only parse and use dNSName at this point.
  */
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-static int
-x509_get_subject_alt_name(unsigned char **p, const unsigned char *end,
-                          mbedtls_x509_general_names *subject_alt_name)
-
-#else
 static int x509_get_subject_alt_name(unsigned char **p,
                                      const unsigned char *end,
-                                     mbedtls_x509_sequence *subject_alt_name)
-#endif
-{
+                                     mbedtls_x509_sequence *subject_alt_name) {
   int ret;
   size_t len, tag_len;
-  unsigned char tag;
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-  mbedtls_x509_general_names *cur = subject_alt_name;
-  mbedtls_x509_general_name general_name;
-  size_t name_len;
-#else
   mbedtls_asn1_buf *buf;
+  unsigned char tag;
   mbedtls_asn1_sequence *cur = subject_alt_name;
-#endif
 
   /* Get main sequence tag */
   if ((ret = mbedtls_asn1_get_tag(
@@ -495,57 +448,10 @@
     if ((ret = mbedtls_asn1_get_len(p, end, &tag_len)) != 0)
       return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret);
 
-    if ((tag & MBEDTLS_ASN1_TAG_CLASS_MASK) != MBEDTLS_ASN1_CONTEXT_SPECIFIC)
+    if ((tag & MBEDTLS_ASN1_CONTEXT_SPECIFIC) != MBEDTLS_ASN1_CONTEXT_SPECIFIC)
       return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
               MBEDTLS_ERR_ASN1_UNEXPECTED_TAG);
 
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-    memset(&general_name, 0, sizeof(general_name));
-    switch (tag) {
-    case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2): /* dNSName */
-      general_name.name_type = MBEDTLS_X509_GENERALNAME_DNSNAME;
-      general_name.dns_name.tag = tag;
-      general_name.dns_name.p = *p;
-      general_name.dns_name.len = tag_len;
-      *p += tag_len;
-      break;
-    case (MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED |
-          4): /* directoryName */
-      general_name.name_type = MBEDTLS_X509_GENERALNAME_DIRECTORYNAME;
-      if ((ret = mbedtls_asn1_get_tag(p, end, &name_len,
-                                      MBEDTLS_ASN1_CONSTRUCTED |
-                                          MBEDTLS_ASN1_SEQUENCE)) != 0)
-        return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret);
-      general_name.directory_name =
-          mbedtls_calloc(1, sizeof(mbedtls_x509_name));
-      if (general_name.directory_name == NULL)
-        return (MBEDTLS_ERR_X509_ALLOC_FAILED);
-      if ((ret = mbedtls_x509_get_name(p, *p + name_len,
-                                       general_name.directory_name)) != 0)
-        return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret);
-      break;
-    default:
-      *p += tag_len;
-      continue;
-    }
-
-    if (cur->general_name.name_type != 0) {
-      if (cur->next != NULL)
-        return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS);
-
-      cur->next = mbedtls_calloc(1, sizeof(mbedtls_x509_general_names));
-
-      if (cur->next == NULL)
-        return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
-                MBEDTLS_ERR_ASN1_ALLOC_FAILED);
-
-      cur = cur->next;
-    }
-
-    memcpy(&cur->general_name, &general_name, sizeof(general_name));
-#else
-
     /* Skip everything but DNS name */
     if (tag != (MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2)) {
       *p += tag_len;
@@ -571,8 +477,6 @@
     buf->p = *p;
     buf->len = tag_len;
     *p += buf->len;
-#endif /* defined(MBEDTLS_OCF_PATCH) &&                                        \
-          defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT) */
   }
 
   /* Set final sequence entry's next pointer to NULL */
@@ -621,14 +525,19 @@
     end_ext_data = *p + len;
 
     /* Get extension ID */
-    if ((ret = mbedtls_asn1_get_tag(p, end_ext_data, &extn_oid.len,
-                                    MBEDTLS_ASN1_OID)) != 0)
+    extn_oid.tag = **p;
+
+    if ((ret = mbedtls_asn1_get_tag(p, end, &extn_oid.len, MBEDTLS_ASN1_OID)) !=
+        0)
       return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret);
 
-    extn_oid.tag = MBEDTLS_ASN1_OID;
     extn_oid.p = *p;
     *p += extn_oid.len;
 
+    if ((end - *p) < 1)
+      return (MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
+              MBEDTLS_ERR_ASN1_OUT_OF_DATA);
+
     /* Get optional critical */
     if ((ret = mbedtls_asn1_get_bool(p, end_ext_data, &is_critical)) != 0 &&
         (ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG))
@@ -802,13 +711,13 @@
     return (ret);
   }
 
-  if (crt->version < 0 || crt->version > 2) {
+  crt->version++;
+
+  if (crt->version > 3) {
     mbedtls_x509_crt_free(crt);
     return (MBEDTLS_ERR_X509_UNKNOWN_VERSION);
   }
 
-  crt->version++;
-
   if ((ret = mbedtls_x509_get_sig_alg(&crt->sig_oid, &sig_params1, &crt->sig_md,
                                       &crt->sig_pk, &crt->sig_opts)) != 0) {
     mbedtls_x509_crt_free(crt);
@@ -1141,16 +1050,8 @@
   p = filename + len;
   filename[len++] = '*';
 
-#if defined(MBEDTLS_OCF_PATCH)
-  if (FAILED(SizeTToInt(len, &lengthAsInt)))
-    return (MBEDTLS_ERR_X509_FILE_IO_ERROR);
-
-  w_ret = MultiByteToWideChar(CP_ACP, 0, filename, lengthAsInt, szDir,
-                              MAX_PATH - 3);
-#else
   w_ret =
       MultiByteToWideChar(CP_ACP, 0, filename, (int)len, szDir, MAX_PATH - 3);
-#endif
   if (w_ret == 0)
     return (MBEDTLS_ERR_X509_BAD_INPUT_DATA);
 
@@ -1165,21 +1066,11 @@
     if (file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
       continue;
 
-#if defined(MBEDTLS_OCF_PATCH)
-    if (FAILED(SizeTToInt(wcslen(file_data.cFileName), &lengthAsInt)))
-      return (MBEDTLS_ERR_X509_FILE_IO_ERROR);
-
-    w_ret = WideCharToMultiByte(CP_ACP, 0, file_data.cFileName, lengthAsInt, p,
-                                (int)len - 1, NULL, NULL);
-#else
     w_ret = WideCharToMultiByte(CP_ACP, 0, file_data.cFileName,
                                 lstrlenW(file_data.cFileName), p, (int)len - 1,
                                 NULL, NULL);
-#endif
-    if (w_ret == 0) {
-      ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
-      goto cleanup;
-    }
+    if (w_ret == 0)
+      return (MBEDTLS_ERR_X509_FILE_IO_ERROR);
 
     w_ret = mbedtls_x509_crt_parse_file(chain, filename);
     if (w_ret < 0)
@@ -1191,7 +1082,6 @@
   if (GetLastError() != ERROR_NO_MORE_FILES)
     ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
 
-cleanup:
   FindClose(hFind);
 #else /* _WIN32 */
   int t_ret;
@@ -1204,12 +1094,12 @@
   if (dir == NULL)
     return (MBEDTLS_ERR_X509_FILE_IO_ERROR);
 
-#if defined(MBEDTLS_THREADING_C)
+#if defined(MBEDTLS_THREADING_PTHREAD)
   if ((ret = mbedtls_mutex_lock(&mbedtls_threading_readdir_mutex)) != 0) {
     closedir(dir);
     return (ret);
   }
-#endif /* MBEDTLS_THREADING_C */
+#endif
 
   while ((entry = readdir(dir)) != NULL) {
     snp_ret = mbedtls_snprintf(entry_name, sizeof entry_name, "%s/%s", path,
@@ -1238,10 +1128,10 @@
 cleanup:
   closedir(dir);
 
-#if defined(MBEDTLS_THREADING_C)
+#if defined(MBEDTLS_THREADING_PTHREAD)
   if (mbedtls_mutex_unlock(&mbedtls_threading_readdir_mutex) != 0)
     ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
-#endif /* MBEDTLS_THREADING_C */
+#endif
 
 #endif /* _WIN32 */
 
@@ -1249,93 +1139,6 @@
 }
 #endif /* MBEDTLS_FS_IO */
 
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-static const char x509_directory_name_label[] = "directoryName=(";
-static const char x509_directory_name_epilogue[] = ")";
-
-/* Length of label constant excluding terminating null. */
-#define LABEL_LEN(label) (sizeof(label) - 1)
-
-static int
-x509_info_subject_alt_name(char **buf, size_t *size,
-                           const mbedtls_x509_general_names *subject_alt_name) {
-  int ret;
-  size_t i;
-  size_t n = *size;
-  char *p = *buf;
-  const mbedtls_x509_general_names *cur = subject_alt_name;
-  const char *sep = "";
-  size_t sep_len = 0;
-
-  while (cur != NULL) {
-    switch (cur->general_name.name_type) {
-    case MBEDTLS_X509_GENERALNAME_DNSNAME:
-      i = cur->general_name.dns_name.len + sep_len;
-
-      if (i >= n) {
-        *p = '\0';
-        return (MBEDTLS_ERR_X509_BUFFER_TOO_SMALL);
-      }
-
-      n -= i;
-      for (i = 0; i < sep_len; i++)
-        *p++ = sep[i];
-      for (i = 0; i < cur->general_name.dns_name.len; i++)
-        *p++ = cur->general_name.dns_name.p[i];
-
-      break;
-
-    case MBEDTLS_X509_GENERALNAME_DIRECTORYNAME:
-      i = sep_len + LABEL_LEN(x509_directory_name_label);
-      if (i >= n) {
-        *p = '\0';
-        return (MBEDTLS_ERR_X509_BUFFER_TOO_SMALL);
-      }
-
-      n -= i;
-      for (i = 0; i < sep_len; i++)
-        *p++ = sep[i];
-      for (i = 0; i < LABEL_LEN(x509_directory_name_label); i++)
-        *p++ = x509_directory_name_label[i];
-
-      ret = mbedtls_x509_dn_gets(p, n, cur->general_name.directory_name);
-      if (ret < 0 || ((size_t)ret) >= n) {
-        *p = '\0';
-        return (MBEDTLS_ERR_X509_BUFFER_TOO_SMALL);
-      }
-
-      n -= ret;
-      p += ret;
-
-      i = LABEL_LEN(x509_directory_name_epilogue);
-
-      if (i >= n) {
-        *p = '\0';
-        return (MBEDTLS_ERR_X509_BUFFER_TOO_SMALL);
-      }
-
-      n -= i;
-      for (i = 0; i < LABEL_LEN(x509_directory_name_epilogue); i++)
-        *p++ = x509_directory_name_epilogue[i];
-
-      break;
-    }
-
-    sep = ", ";
-    sep_len = 2;
-
-    cur = cur->next;
-  }
-
-  *p = '\0';
-
-  *size = n;
-  *buf = p;
-
-  return (0);
-}
-#else
 static int
 x509_info_subject_alt_name(char **buf, size_t *size,
                            const mbedtls_x509_sequence *subject_alt_name) {
@@ -1371,7 +1174,6 @@
 
   return (0);
 }
-#endif /* MBEDTLS_OCF_PATCH */
 
 #define PRINT_ITEM(i)                                                          \
   {                                                                            \
@@ -1462,121 +1264,6 @@
 }
 
 /*
- * Like memcmp, but case-insensitive and always returns -1 if different
- */
-static int x509_memcasecmp(const void *s1, const void *s2, size_t len) {
-  size_t i;
-  unsigned char diff;
-  const unsigned char *n1 = s1, *n2 = s2;
-
-  for (i = 0; i < len; i++) {
-    diff = n1[i] ^ n2[i];
-
-    if (diff == 0)
-      continue;
-
-    if (diff == 32 &&
-        ((n1[i] >= 'a' && n1[i] <= 'z') || (n1[i] >= 'A' && n1[i] <= 'Z'))) {
-      continue;
-    }
-
-    return (-1);
-  }
-
-  return (0);
-}
-
-/*
- * Return 0 if name matches wildcard, -1 otherwise
- */
-static int x509_check_wildcard(const char *cn, mbedtls_x509_buf *name) {
-  size_t i;
-  size_t cn_idx = 0, cn_len = strlen(cn);
-
-  if (name->len < 3 || name->p[0] != '*' || name->p[1] != '.')
-    return (0);
-
-  for (i = 0; i < cn_len; ++i) {
-    if (cn[i] == '.') {
-      cn_idx = i;
-      break;
-    }
-  }
-
-  if (cn_idx == 0)
-    return (-1);
-
-  if (cn_len - cn_idx == name->len - 1 &&
-      x509_memcasecmp(name->p + 1, cn + cn_idx, name->len - 1) == 0) {
-    return (0);
-  }
-
-  return (-1);
-}
-
-/*
- * Compare two X.509 strings, case-insensitive, and allowing for some encoding
- * variations (but not all).
- *
- * Return 0 if equal, -1 otherwise.
- */
-static int x509_string_cmp(const mbedtls_x509_buf *a,
-                           const mbedtls_x509_buf *b) {
-  if (a->tag == b->tag && a->len == b->len && memcmp(a->p, b->p, b->len) == 0) {
-    return (0);
-  }
-
-  if ((a->tag == MBEDTLS_ASN1_UTF8_STRING ||
-       a->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
-      (b->tag == MBEDTLS_ASN1_UTF8_STRING ||
-       b->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
-      a->len == b->len && x509_memcasecmp(a->p, b->p, b->len) == 0) {
-    return (0);
-  }
-
-  return (-1);
-}
-
-/*
- * Compare two X.509 Names (aka rdnSequence).
- *
- * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
- * we sometimes return unequal when the full algorithm would return equal,
- * but never the other way. (In particular, we don't do Unicode normalisation
- * or space folding.)
- *
- * Return 0 if equal, -1 otherwise.
- */
-static int x509_name_cmp(const mbedtls_x509_name *a,
-                         const mbedtls_x509_name *b) {
-  /* Avoid recursion, it might not be optimised by the compiler */
-  while (a != NULL || b != NULL) {
-    if (a == NULL || b == NULL)
-      return (-1);
-
-    /* type */
-    if (a->oid.tag != b->oid.tag || a->oid.len != b->oid.len ||
-        memcmp(a->oid.p, b->oid.p, b->oid.len) != 0) {
-      return (-1);
-    }
-
-    /* value */
-    if (x509_string_cmp(&a->val, &b->val) != 0)
-      return (-1);
-
-    /* structure of the list of sets */
-    if (a->next_merged != b->next_merged)
-      return (-1);
-
-    a = a->next;
-    b = b->next;
-  }
-
-  /* a == NULL == b */
-  return (0);
-}
-
-/*
  * Return an informational string about the certificate.
  */
 #define BEFORE_COLON 18
@@ -1851,7 +1538,7 @@
 
 /*
  * Check that the given certificate is not revoked according to the CRL.
- * Skip validation if no CRL for the given CA is present.
+ * Skip validation is no CRL for the given CA is present.
  */
 static int x509_crt_verifycrl(mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
                               mbedtls_x509_crl *crl_list,
@@ -1865,7 +1552,9 @@
 
   while (crl_list != NULL) {
     if (crl_list->version == 0 ||
-        x509_name_cmp(&crl_list->issuer, &ca->subject) != 0) {
+        crl_list->issuer_raw.len != ca->subject_raw.len ||
+        memcmp(crl_list->issuer_raw.p, ca->subject_raw.p,
+               crl_list->issuer_raw.len) != 0) {
       crl_list = crl_list->next;
       continue;
     }
@@ -1890,12 +1579,16 @@
       flags |= MBEDTLS_X509_BADCRL_BAD_PK;
 
     md_info = mbedtls_md_info_from_type(crl_list->sig_md);
-    if (mbedtls_md(md_info, crl_list->tbs.p, crl_list->tbs.len, hash) != 0) {
-      /* Note: this can't happen except after an internal error */
+    if (md_info == NULL) {
+      /*
+       * Cannot check 'unknown' hash
+       */
       flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
       break;
     }
 
+    mbedtls_md(md_info, crl_list->tbs.p, crl_list->tbs.len, hash);
+
     if (x509_profile_check_key(profile, crl_list->sig_pk, &ca->pk) != 0)
       flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 
@@ -1932,6 +1625,121 @@
 #endif /* MBEDTLS_X509_CRL_PARSE_C */
 
 /*
+ * Like memcmp, but case-insensitive and always returns -1 if different
+ */
+static int x509_memcasecmp(const void *s1, const void *s2, size_t len) {
+  size_t i;
+  unsigned char diff;
+  const unsigned char *n1 = s1, *n2 = s2;
+
+  for (i = 0; i < len; i++) {
+    diff = n1[i] ^ n2[i];
+
+    if (diff == 0)
+      continue;
+
+    if (diff == 32 &&
+        ((n1[i] >= 'a' && n1[i] <= 'z') || (n1[i] >= 'A' && n1[i] <= 'Z'))) {
+      continue;
+    }
+
+    return (-1);
+  }
+
+  return (0);
+}
+
+/*
+ * Return 0 if name matches wildcard, -1 otherwise
+ */
+static int x509_check_wildcard(const char *cn, mbedtls_x509_buf *name) {
+  size_t i;
+  size_t cn_idx = 0, cn_len = strlen(cn);
+
+  if (name->len < 3 || name->p[0] != '*' || name->p[1] != '.')
+    return (0);
+
+  for (i = 0; i < cn_len; ++i) {
+    if (cn[i] == '.') {
+      cn_idx = i;
+      break;
+    }
+  }
+
+  if (cn_idx == 0)
+    return (-1);
+
+  if (cn_len - cn_idx == name->len - 1 &&
+      x509_memcasecmp(name->p + 1, cn + cn_idx, name->len - 1) == 0) {
+    return (0);
+  }
+
+  return (-1);
+}
+
+/*
+ * Compare two X.509 strings, case-insensitive, and allowing for some encoding
+ * variations (but not all).
+ *
+ * Return 0 if equal, -1 otherwise.
+ */
+static int x509_string_cmp(const mbedtls_x509_buf *a,
+                           const mbedtls_x509_buf *b) {
+  if (a->tag == b->tag && a->len == b->len && memcmp(a->p, b->p, b->len) == 0) {
+    return (0);
+  }
+
+  if ((a->tag == MBEDTLS_ASN1_UTF8_STRING ||
+       a->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
+      (b->tag == MBEDTLS_ASN1_UTF8_STRING ||
+       b->tag == MBEDTLS_ASN1_PRINTABLE_STRING) &&
+      a->len == b->len && x509_memcasecmp(a->p, b->p, b->len) == 0) {
+    return (0);
+  }
+
+  return (-1);
+}
+
+/*
+ * Compare two X.509 Names (aka rdnSequence).
+ *
+ * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
+ * we sometimes return unequal when the full algorithm would return equal,
+ * but never the other way. (In particular, we don't do Unicode normalisation
+ * or space folding.)
+ *
+ * Return 0 if equal, -1 otherwise.
+ */
+static int x509_name_cmp(const mbedtls_x509_name *a,
+                         const mbedtls_x509_name *b) {
+  /* Avoid recursion, it might not be optimised by the compiler */
+  while (a != NULL || b != NULL) {
+    if (a == NULL || b == NULL)
+      return (-1);
+
+    /* type */
+    if (a->oid.tag != b->oid.tag || a->oid.len != b->oid.len ||
+        memcmp(a->oid.p, b->oid.p, b->oid.len) != 0) {
+      return (-1);
+    }
+
+    /* value */
+    if (x509_string_cmp(&a->val, &b->val) != 0)
+      return (-1);
+
+    /* structure of the list of sets */
+    if (a->next_merged != b->next_merged)
+      return (-1);
+
+    a = a->next;
+    b = b->next;
+  }
+
+  /* a == NULL == b */
+  return (0);
+}
+
+/*
  * Check if 'parent' is a suitable parent (signing CA) for 'child'.
  * Return 0 if yes, -1 if not.
  *
@@ -1973,27 +1781,6 @@
   return (0);
 }
 
-/*
- * Verify a certificate with no parent inside the chain
- * (either the parent is a trusted root, or there is no parent)
- *
- * See comments for mbedtls_x509_crt_verify_with_profile()
- * (also for notation used below)
- *
- * This function is called in two cases:
- *  - child was found to have a parent in trusted roots, in which case we're
- *    called with trust_ca pointing directly to that parent (not the full list)
- *      - this is cases 1, 2 and 3 of the comment on verify_with_profile()
- *      - case 1 is special as child and trust_ca point to copies of the same
- *        certificate then
- *  - child was found to have no parent either in the chain or in trusted CAs
- *      - this is cases 4 and 5 of the comment on verify_with_profile()
- *
- * For historical reasons, the function currently does not assume that
- * trust_ca points directly to the right root in the first case, and it
- * doesn't know in which case it starts, so it always starts by searching for
- * a parent in trust_ca.
- */
 static int x509_crt_verify_top(
     mbedtls_x509_crt *child, mbedtls_x509_crt *trust_ca,
     mbedtls_x509_crl *ca_crl, const mbedtls_x509_crt_profile *profile,
@@ -2024,11 +1811,13 @@
   *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
 
   md_info = mbedtls_md_info_from_type(child->sig_md);
-  if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
-    /* Note: this can't happen except after an internal error */
-    /* Cannot check signature, no need to try any CA */
+  if (md_info == NULL) {
+    /*
+     * Cannot check 'unknown', no need to try any CA
+     */
     trust_ca = NULL;
-  }
+  } else
+    mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash);
 
   for (/* trust_ca */; trust_ca != NULL; trust_ca = trust_ca->next) {
     if (x509_crt_check_parent(child, trust_ca, 1, path_cnt == 0) != 0)
@@ -2042,7 +1831,7 @@
      */
     if (child->subject_raw.len == trust_ca->subject_raw.len &&
         memcmp(child->subject_raw.p, trust_ca->subject_raw.p,
-               child->subject_raw.len) == 0) {
+               child->issuer_raw.len) == 0) {
       check_path_cnt--;
     }
 
@@ -2087,7 +1876,7 @@
   if (trust_ca != NULL &&
       (child->subject_raw.len != trust_ca->subject_raw.len ||
        memcmp(child->subject_raw.p, trust_ca->subject_raw.p,
-              child->subject_raw.len) != 0)) {
+              child->issuer_raw.len) != 0)) {
 #if defined(MBEDTLS_X509_CRL_PARSE_C)
     /* Check trusted CA's CRL for the chain's top crt */
     *flags |= x509_crt_verifycrl(child, trust_ca, ca_crl, profile);
@@ -2119,11 +1908,6 @@
   return (0);
 }
 
-/*
- * Verify a certificate with a parent inside the chain
- *
- * See comments for mbedtls_x509_crt_verify_with_profile()
- */
 static int x509_crt_verify_child(
     mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
     mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
@@ -2142,8 +1926,8 @@
 
   /* path_cnt is 0 for the first intermediate CA */
   if (1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA) {
-    /* return immediately as the goal is to avoid unbounded recursion */
-    return (MBEDTLS_ERR_X509_FATAL_ERROR);
+    *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
+    return (MBEDTLS_ERR_X509_CERT_VERIFY_FAILED);
   }
 
   if (mbedtls_x509_time_is_past(&child->valid_to))
@@ -2159,10 +1943,14 @@
     *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
 
   md_info = mbedtls_md_info_from_type(child->sig_md);
-  if (mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash) != 0) {
-    /* Note: this can't happen except after an internal error */
+  if (md_info == NULL) {
+    /*
+     * Cannot check 'unknown' hash
+     */
     *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
   } else {
+    mbedtls_md(md_info, child->tbs.p, child->tbs.len, hash);
+
     if (x509_profile_check_key(profile, child->sig_pk, &parent->pk) != 0)
       *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 
@@ -2246,34 +2034,6 @@
 
 /*
  * Verify the certificate validity, with profile
- *
- * The chain building/verification is spread accross 4 functions:
- *  - this one
- *  - x509_crt_verify_child()
- *  - x509_crt_verify_top()
- *  - x509_crt_check_parent()
- *
- * There are five main cases to consider. Let's introduce some notation:
- *  - E means the end-entity certificate
- *  - I an intermediate CA
- *  - R the trusted root CA this chain anchors to
- *  - T the list of trusted roots (R and possible some others)
- *
- * The main cases with the calling sequence of the crt_verify_xxx() are:
- *  1. E = R (explicitly trusted EE cert)
- *      verify(E, T) -> verify_top(E, R)
- *  2. E -> R (EE signed by trusted root)
- *      verify(E, T) -> verify_top(E, R)
- *  3. E -> I -> R (EE signed by intermediate signed by trusted root)
- *      verify(E, T) -> verify_child(E, I, T) -> verify_top(I, R)
- *      (plus variant with multiple intermediates)
- *  4. E -> I (EE signed by intermediate that's not trusted)
- *      verify(E, T) -> verify_child(E, I, T) -> verify_top(I, T)
- *      (plus variant with multiple intermediates)
- *  5. E (EE not trusted)
- *      verify(E, T) -> verify_top(E, T)
- *
- * Note: this notation and case numbering is also used in x509_crt_verify_top()
  */
 int mbedtls_x509_crt_verify_with_profile(
     mbedtls_x509_crt *crt, mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
@@ -2284,20 +2044,13 @@
   int pathlen = 0, selfsigned = 0;
   mbedtls_x509_crt *parent;
   mbedtls_x509_name *name;
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-  mbedtls_x509_general_names *cur = NULL;
-#else
   mbedtls_x509_sequence *cur = NULL;
-#endif
   mbedtls_pk_type_t pk_type;
 
-  *flags = 0;
+  if (profile == NULL)
+    return (MBEDTLS_ERR_X509_BAD_INPUT_DATA);
 
-  if (profile == NULL) {
-    ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
-    goto exit;
-  }
+  *flags = 0;
 
   if (cn != NULL) {
     name = &crt->subject;
@@ -2307,22 +2060,6 @@
       cur = &crt->subject_alt_names;
 
       while (cur != NULL) {
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-        /* Only consider dNSName subject alternative names for this check;
-         * ignore other types. */
-        if (cur->general_name.name_type == MBEDTLS_X509_GENERALNAME_DNSNAME) {
-          if (cur->general_name.dns_name.len == cn_len &&
-              x509_memcasecmp(cn, cur->general_name.dns_name.p, cn_len) == 0)
-            break;
-
-          if (cur->general_name.dns_name.len > 2 &&
-              memcmp(cur->general_name.dns_name.p, "*.", 2) == 0 &&
-              x509_check_wildcard(cn, &cur->general_name.dns_name) == 0) {
-            break;
-          }
-        }
-#else
         if (cur->buf.len == cn_len &&
             x509_memcasecmp(cn, cur->buf.p, cn_len) == 0)
           break;
@@ -2331,7 +2068,7 @@
             x509_check_wildcard(cn, &cur->buf) == 0) {
           break;
         }
-#endif
+
         cur = cur->next;
       }
 
@@ -2376,7 +2113,7 @@
     ret = x509_crt_verify_top(crt, parent, ca_crl, profile, pathlen, selfsigned,
                               flags, f_vrfy, p_vrfy);
     if (ret != 0)
-      goto exit;
+      return (ret);
   } else {
     /* Look for a parent upwards the chain */
     for (parent = crt->next; parent != NULL; parent = parent->next)
@@ -2388,27 +2125,15 @@
       ret = x509_crt_verify_child(crt, parent, trust_ca, ca_crl, profile,
                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy);
       if (ret != 0)
-        goto exit;
+        return (ret);
     } else {
       ret = x509_crt_verify_top(crt, trust_ca, ca_crl, profile, pathlen,
                                 selfsigned, flags, f_vrfy, p_vrfy);
       if (ret != 0)
-        goto exit;
+        return (ret);
     }
   }
 
-exit:
-  /* prevent misuse of the vrfy callback - VERIFY_FAILED would be ignored by
-   * the SSL module for authmode optional, but non-zero return from the
-   * callback means a fatal error so it shouldn't be ignored */
-  if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED)
-    ret = MBEDTLS_ERR_X509_FATAL_ERROR;
-
-  if (ret != 0) {
-    *flags = (uint32_t)-1;
-    return (ret);
-  }
-
   if (*flags != 0)
     return (MBEDTLS_ERR_X509_CERT_VERIFY_FAILED);
 
@@ -2430,11 +2155,6 @@
   mbedtls_x509_crt *cert_prv;
   mbedtls_x509_name *name_cur;
   mbedtls_x509_name *name_prv;
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-  mbedtls_x509_general_names *san_cur;
-  mbedtls_x509_general_names *san_prv;
-#endif
   mbedtls_x509_sequence *seq_cur;
   mbedtls_x509_sequence *seq_prv;
 
@@ -2472,36 +2192,6 @@
       mbedtls_free(seq_prv);
     }
 
-#if defined(MBEDTLS_OCF_PATCH) &&                                              \
-    defined(MBEDTLS_X509_EXPANDED_SUBJECT_ALT_NAME_SUPPORT)
-    if (cert_cur->subject_alt_names.general_name.name_type ==
-        MBEDTLS_X509_GENERALNAME_DIRECTORYNAME) {
-      name_cur = cert_cur->subject_alt_names.general_name.directory_name;
-      while (name_cur != NULL) {
-        name_prv = name_cur;
-        name_cur = name_cur->next;
-        mbedtls_zeroize(name_prv, sizeof(mbedtls_x509_name));
-        mbedtls_free(name_prv);
-      }
-    }
-    san_cur = cert_cur->subject_alt_names.next;
-    while (san_cur != NULL) {
-      san_prv = san_cur;
-      san_cur = san_cur->next;
-      if (san_prv->general_name.name_type ==
-          MBEDTLS_X509_GENERALNAME_DIRECTORYNAME) {
-        name_cur = san_prv->general_name.directory_name;
-        while (name_cur != NULL) {
-          name_prv = name_cur;
-          name_cur = name_cur->next;
-          mbedtls_zeroize(name_prv, sizeof(mbedtls_x509_name));
-          mbedtls_free(name_prv);
-        }
-      }
-      mbedtls_zeroize(san_prv, sizeof(mbedtls_x509_general_names));
-      mbedtls_free(san_prv);
-    }
-#else
     seq_cur = cert_cur->subject_alt_names.next;
     while (seq_cur != NULL) {
       seq_prv = seq_cur;
@@ -2509,7 +2199,6 @@
       mbedtls_zeroize(seq_prv, sizeof(mbedtls_x509_sequence));
       mbedtls_free(seq_prv);
     }
-#endif
 
     if (cert_cur->raw.p != NULL) {
       mbedtls_zeroize(cert_cur->raw.p, cert_cur->raw.len);
