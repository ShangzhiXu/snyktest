--- /home/V1SCAN/CWE-119/FormattedUsed/parser-turicreate-6.4.1.c	2023-12-10 02:44:54.440072921 +0900
+++ /home/V1SCAN/CWE-119/FormattedVul/OLD##CVE-2017-16931##0##GNOME@@libxml2##parser.c	2023-12-10 02:44:55.280078009 +0900
@@ -53,6 +53,7 @@
 #include <libxml/xmlmemory.h>
 #include <limits.h>
 #include <stdarg.h>
+#include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #ifdef LIBXML_CATALOG_ENABLED
@@ -94,6 +95,8 @@
 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
                                   const xmlChar *base, xmlParserCtxtPtr pctx);
 
+static void xmlHaltParser(xmlParserCtxtPtr ctxt);
+
 /************************************************************************
  *									*
  *	Arbitrary limits set in the parser. See XML_PARSE_HUGE		*
@@ -128,6 +131,35 @@
     return (0);
   if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
     return (1);
+
+  /*
+   * This may look absurd but is needed to detect
+   * entities problems
+   */
+  if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
+      (ent->content != NULL) && (ent->checked == 0) &&
+      (ctxt->errNo != XML_ERR_ENTITY_LOOP)) {
+    unsigned long oldnbent = ctxt->nbentities;
+    xmlChar *rep;
+
+    ent->checked = 1;
+
+    ++ctxt->depth;
+    rep = xmlStringDecodeEntities(ctxt, ent->content, XML_SUBSTITUTE_REF, 0, 0,
+                                  0);
+    --ctxt->depth;
+    if (ctxt->errNo == XML_ERR_ENTITY_LOOP) {
+      ent->content[0] = 0;
+    }
+
+    ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+    if (rep != NULL) {
+      if (xmlStrchr(rep, '<'))
+        ent->checked |= 1;
+      xmlFree(rep);
+      rep = NULL;
+    }
+  }
   if (replacement != 0) {
     if (replacement < XML_MAX_TEXT_LENGTH)
       return (0);
@@ -184,9 +216,12 @@
       return (0);
   } else {
     /*
-     * strange we got no data for checking just return
+     * strange we got no data for checking
      */
-    return (0);
+    if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&
+         (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||
+        (ctxt->nbentities <= 10000))
+      return (0);
   }
   xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
   return (1);
@@ -298,7 +333,6 @@
 static void xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
                         const char *info) {
   const char *errmsg;
-  char errstr[129] = "";
 
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
@@ -483,15 +517,17 @@
   default:
     errmsg = "Unregistered error message";
   }
-  if (info == NULL)
-    snprintf(errstr, 128, "%s\n", errmsg);
-  else
-    snprintf(errstr, 128, "%s: %%s\n", errmsg);
   if (ctxt != NULL)
     ctxt->errNo = error;
-  __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
-                  XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, &errstr[0],
-                  info);
+  if (info == NULL) {
+    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
+                    XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
+                    errmsg);
+  } else {
+    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
+                    XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
+                    errmsg, info);
+  }
   if (ctxt != NULL) {
     ctxt->wellFormed = 0;
     if (ctxt->recovery == 0)
@@ -507,8 +543,9 @@
  *
  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  */
-static void xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                           const char *msg) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
+                   const char *msg) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -533,9 +570,9 @@
  *
  * Handle a warning.
  */
-static void xmlWarningMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                          const char *msg, const xmlChar *str1,
-                          const xmlChar *str2) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlWarningMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *msg,
+                  const xmlChar *str1, const xmlChar *str2) {
   xmlStructuredErrorFunc schannel = NULL;
 
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
@@ -567,9 +604,10 @@
  *
  * Handle a validity error.
  */
-static void xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                             const char *msg, const xmlChar *str1,
-                             const xmlChar *str2) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
+                     const char *msg, const xmlChar *str1,
+                     const xmlChar *str2) {
   xmlStructuredErrorFunc schannel = NULL;
 
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
@@ -603,8 +641,9 @@
  *
  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  */
-static void xmlFatalErrMsgInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                              const char *msg, int val) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlFatalErrMsgInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,
+                      const char *msg, int val) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -630,10 +669,10 @@
  *
  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  */
-static void xmlFatalErrMsgStrIntStr(xmlParserCtxtPtr ctxt,
-                                    xmlParserErrors error, const char *msg,
-                                    const xmlChar *str1, int val,
-                                    const xmlChar *str2) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlFatalErrMsgStrIntStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
+                            const char *msg, const xmlChar *str1, int val,
+                            const xmlChar *str2) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -658,8 +697,9 @@
  *
  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  */
-static void xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                              const char *msg, const xmlChar *val) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
+                      const char *msg, const xmlChar *val) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -684,8 +724,9 @@
  *
  * Handle a non fatal parser error
  */
-static void xmlErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                         const char *msg, const xmlChar *val) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *msg,
+                 const xmlChar *val) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -706,9 +747,9 @@
  *
  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  */
-static void xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                     const char *msg, const xmlChar *info1,
-                     const xmlChar *info2, const xmlChar *info3) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *msg,
+             const xmlChar *info1, const xmlChar *info2, const xmlChar *info3) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -732,9 +773,10 @@
  *
  * Handle a namespace warning error
  */
-static void xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
-                      const char *msg, const xmlChar *info1,
-                      const xmlChar *info2, const xmlChar *info3) {
+static void LIBXML_ATTR_FORMAT(3, 0)
+    xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *msg,
+              const xmlChar *info1, const xmlChar *info2,
+              const xmlChar *info3) {
   if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
       (ctxt->instate == XML_PARSER_EOF))
     return;
@@ -1002,9 +1044,14 @@
 typedef struct _xmlDefAttrs xmlDefAttrs;
 typedef xmlDefAttrs *xmlDefAttrsPtr;
 struct _xmlDefAttrs {
-  int nbAttrs;              /* number of defaulted attributes on that element */
-  int maxAttrs;             /* the size of the array */
-  const xmlChar *values[5]; /* array of localname/prefix/values/external */
+  int nbAttrs;  /* number of defaulted attributes on that element */
+  int maxAttrs; /* the size of the array */
+#if __STDC_VERSION__ >= 199901L
+  /* Using a C99 flexible array member avoids UBSan errors. */
+  const xmlChar *values[]; /* array of localname/prefix/values/external */
+#else
+  const xmlChar *values[5];
+#endif
 };
 
 /**
@@ -1677,7 +1724,7 @@
         ctxt, XML_ERR_INTERNAL_ERROR,
         "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
         xmlParserMaxDepth);
-    ctxt->instate = XML_PARSER_EOF;
+    xmlHaltParser(ctxt);
     return (-1);
   }
   ctxt->nodeTab[ctxt->nodeNr] = value;
@@ -1903,6 +1950,7 @@
 #define CUR (*ctxt->input->cur)
 #define NXT(val) ctxt->input->cur[(val)]
 #define CUR_PTR ctxt->input->cur
+#define BASE_PTR ctxt->input->base
 
 #define CMP4(s, c1, c2, c3, c4)                                                \
   (((unsigned char *)s)[0] == c1 && ((unsigned char *)s)[1] == c2 &&           \
@@ -1970,15 +2018,25 @@
     xmlGROW(ctxt);
 
 static void xmlGROW(xmlParserCtxtPtr ctxt) {
-  if ((((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
-       ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&
+  unsigned long curEnd = ctxt->input->end - ctxt->input->cur;
+  unsigned long curBase = ctxt->input->cur - ctxt->input->base;
+
+  if (((curEnd > (unsigned long)XML_MAX_LOOKUP_LIMIT) ||
+       (curBase > (unsigned long)XML_MAX_LOOKUP_LIMIT)) &&
       ((ctxt->input->buf) &&
        (ctxt->input->buf->readcallback != (xmlInputReadCallback)xmlNop)) &&
       ((ctxt->options & XML_PARSE_HUGE) == 0)) {
     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
-    ctxt->instate = XML_PARSER_EOF;
+    xmlHaltParser(ctxt);
+    return;
   }
   xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+  if ((ctxt->input->cur > ctxt->input->end) ||
+      (ctxt->input->cur < ctxt->input->base)) {
+    xmlHaltParser(ctxt);
+    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "cur index out of bound");
+    return;
+  }
   if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&
       (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
     xmlPopInput(ctxt);
@@ -2045,6 +2103,8 @@
       if (*cur == '\n') {
         ctxt->input->line++;
         ctxt->input->col = 1;
+      } else {
+        ctxt->input->col++;
       }
       cur++;
       res++;
@@ -2059,7 +2119,8 @@
     int cur;
     do {
       cur = CUR;
-      while (IS_BLANK_CH(cur)) { /* CHECKED tstblanks.xml */
+      while ((IS_BLANK_CH(cur) && /* CHECKED tstblanks.xml */
+              (ctxt->instate != XML_PARSER_EOF))) {
         NEXT;
         cur = CUR;
         res++;
@@ -2074,7 +2135,8 @@
        */
       if (*ctxt->input->cur == '%')
         xmlParserHandlePEReference(ctxt);
-    } while (IS_BLANK(cur)); /* CHECKED tstblanks.xml */
+    } while ((IS_BLANK(cur)) && /* CHECKED tstblanks.xml */
+             (ctxt->instate != XML_PARSER_EOF));
   }
   return (res);
 }
@@ -2515,6 +2577,7 @@
                           "PEReference: %%%s; not found\n", name, NULL);
           ctxt->valid = 0;
         }
+        xmlParserEntityCheck(ctxt, 0, NULL, 0);
       } else if (ctxt->input->free != deallocblankswrapper) {
         input = xmlNewBlanksWrapperInputStream(ctxt, entity);
         if (xmlPushInput(ctxt, input) < 0)
@@ -2526,6 +2589,22 @@
           xmlCharEncoding enc;
 
           /*
+           * Note: external parameter entities will not be loaded, it
+           * is not required for a non-validating parser, unless the
+           * option of validating, or substituting entities were
+           * given. Doing so is far more secure as the parser will
+           * only process data coming from the document entity by
+           * default.
+           */
+          if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+              ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+              ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+              ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+              ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+              (ctxt->replaceEntities == 0) && (ctxt->validate == 0))
+            return;
+
+          /*
            * handle the extra spaces added before and after
            * c.f. http://www.w3.org/TR/REC-xml#as-PE
            * this is done independently.
@@ -2669,6 +2748,7 @@
       if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
           (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
         goto int_error;
+      xmlParserEntityCheck(ctxt, 0, ent, 0);
       if (ent != NULL)
         ctxt->nbentities += ent->checked / 2;
       if ((ent != NULL) && (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
@@ -2686,6 +2766,10 @@
         rep = xmlStringDecodeEntities(ctxt, ent->content, what, 0, 0, 0);
         ctxt->depth--;
 
+        if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
+            (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
+          goto int_error;
+
         if (rep != NULL) {
           current = rep;
           while (*current != 0) { /* non input consuming loop */
@@ -2718,11 +2802,27 @@
       ent = xmlParseStringPEReference(ctxt, &str);
       if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
         goto int_error;
+      xmlParserEntityCheck(ctxt, 0, ent, 0);
       if (ent != NULL)
         ctxt->nbentities += ent->checked / 2;
       if (ent != NULL) {
         if (ent->content == NULL) {
-          xmlLoadEntityContent(ctxt, ent);
+          /*
+           * Note: external parsed entities will not be loaded,
+           * it is not required for a non-validating parser to
+           * complete external PEreferences coming from the
+           * internal subset
+           */
+          if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+              ((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+              (ctxt->validate != 0)) {
+            xmlLoadEntityContent(ctxt, ent);
+          } else {
+            xmlWarningMsg(
+                ctxt, XML_ERR_ENTITY_PROCESSING,
+                "not validating will not read content for PE entity %s\n",
+                ent->name, NULL);
+          }
         }
         ctxt->depth++;
         rep = xmlStringDecodeEntities(ctxt, ent->content, what, 0, 0, 0);
@@ -3299,6 +3399,7 @@
   int len = 0, l;
   int c;
   int count = 0;
+  size_t startPosition = 0;
 
 #ifdef DEBUG
   nbParseNCNameComplex++;
@@ -3308,6 +3409,7 @@
    * Handler for more complex cases
    */
   GROW;
+  startPosition = CUR_PTR - BASE_PTR;
   c = CUR_CHAR(l);
   if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
       (!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
@@ -3332,7 +3434,14 @@
     c = CUR_CHAR(l);
     if (c == 0) {
       count = 0;
+      /*
+       * when shrinking to extend the buffer we really need to preserve
+       * the part of the name we already parsed. Hence rolling back
+       * by current lenght.
+       */
+      ctxt->input->cur -= l;
       GROW;
+      ctxt->input->cur += l;
       if (ctxt->instate == XML_PARSER_EOF)
         return (NULL);
       c = CUR_CHAR(l);
@@ -3342,7 +3451,7 @@
     xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
     return (NULL);
   }
-  return (xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
+  return (xmlDictLookup(ctxt->dict, (BASE_PTR + startPosition), len));
 }
 
 /**
@@ -3361,7 +3470,7 @@
  */
 
 static const xmlChar *xmlParseNCName(xmlParserCtxtPtr ctxt) {
-  const xmlChar *in;
+  const xmlChar *in, *e;
   const xmlChar *ret;
   int count = 0;
 
@@ -3373,14 +3482,19 @@
    * Accelerator for simple ASCII names
    */
   in = ctxt->input->cur;
-  if (((*in >= 0x61) && (*in <= 0x7A)) || ((*in >= 0x41) && (*in <= 0x5A)) ||
-      (*in == '_')) {
+  e = ctxt->input->end;
+  if ((((*in >= 0x61) && (*in <= 0x7A)) || ((*in >= 0x41) && (*in <= 0x5A)) ||
+       (*in == '_')) &&
+      (in < e)) {
     in++;
-    while (((*in >= 0x61) && (*in <= 0x7A)) ||
-           ((*in >= 0x41) && (*in <= 0x5A)) ||
-           ((*in >= 0x30) && (*in <= 0x39)) || (*in == '_') || (*in == '-') ||
-           (*in == '.'))
+    while ((((*in >= 0x61) && (*in <= 0x7A)) ||
+            ((*in >= 0x41) && (*in <= 0x5A)) ||
+            ((*in >= 0x30) && (*in <= 0x39)) || (*in == '_') || (*in == '-') ||
+            (*in == '.')) &&
+           (in < e))
       in++;
+    if (in >= e)
+      goto complex;
     if ((*in > 0) && (*in < 0x80)) {
       count = in - ctxt->input->cur;
       if ((count > XML_MAX_NAME_LENGTH) &&
@@ -3398,6 +3512,7 @@
       return (ret);
     }
   }
+complex:
   return (xmlParseNCNameComplex(ctxt));
 }
 
@@ -3435,7 +3550,7 @@
   }
   /* failure (or end of input buffer), check with full function */
   ret = xmlParseName(ctxt);
-  /* strings coming from the dictionnary direct compare possible */
+  /* strings coming from the dictionary direct compare possible */
   if (ret == other) {
     return (const xmlChar *)1;
   }
@@ -3772,7 +3887,9 @@
      * an entity declaration, it is bypassed and left as is.
      * so XML_SUBSTITUTE_REF is not set here.
      */
+    ++ctxt->depth;
     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF, 0, 0, 0);
+    --ctxt->depth;
     if (orig != NULL)
       *orig = buf;
     else
@@ -3896,8 +4013,10 @@
           }
         } else if ((ent != NULL) && (ctxt->replaceEntities != 0)) {
           if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
+            ++ctxt->depth;
             rep = xmlStringDecodeEntities(ctxt, ent->content,
                                           XML_SUBSTITUTE_REF, 0, 0, 0);
+            --ctxt->depth;
             if (rep != NULL) {
               current = rep;
               while (*current != 0) { /* non input consuming */
@@ -3933,8 +4052,10 @@
               (ent->content != NULL) && (ent->checked == 0)) {
             unsigned long oldnbent = ctxt->nbentities;
 
+            ++ctxt->depth;
             rep = xmlStringDecodeEntities(ctxt, ent->content,
                                           XML_SUBSTITUTE_REF, 0, 0, 0);
+            --ctxt->depth;
 
             ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
             if (rep != NULL) {
@@ -4939,8 +5060,8 @@
                   "xmlParsePITarget: invalid name prefix 'xml'\n", NULL, NULL);
   }
   if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {
-    xmlNsErr(ctxt, XML_NS_ERR_COLON, "colon are forbidden from PI names '%s'\n",
-             name, NULL, NULL);
+    xmlNsErr(ctxt, XML_NS_ERR_COLON,
+             "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
   }
   return (name);
 }
@@ -5208,7 +5329,7 @@
     }
     if (xmlStrchr(name, ':') != NULL) {
       xmlNsErr(ctxt, XML_NS_ERR_COLON,
-               "colon are forbidden from notation names '%s'\n", name, NULL,
+               "colons are forbidden from notation names '%s'\n", name, NULL,
                NULL);
     }
     SKIP_BLANKS;
@@ -5286,7 +5407,7 @@
       skipped = SKIP_BLANKS;
       if (skipped == 0) {
         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
-                       "Space required after '%'\n");
+                       "Space required after '%%'\n");
       }
       isParameter = 1;
     }
@@ -5299,7 +5420,7 @@
     }
     if (xmlStrchr(name, ':') != NULL) {
       xmlNsErr(ctxt, XML_NS_ERR_COLON,
-               "colon are forbidden from entities names '%s'\n", name, NULL,
+               "colons are forbidden from entities names '%s'\n", name, NULL,
                NULL);
     }
     skipped = SKIP_BLANKS;
@@ -5464,6 +5585,7 @@
     if (RAW != '>') {
       xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
                         "xmlParseEntityDecl: entity %s not terminated\n", name);
+      xmlHaltParser(ctxt);
     } else {
       if (input != ctxt->input) {
         xmlFatalErrMsg(
@@ -6035,7 +6157,7 @@
       if (elem == NULL) {
         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
                        "xmlParseElementMixedContentDecl : Name expected\n");
-        xmlFreeDocElementContent(ctxt->myDoc, cur);
+        xmlFreeDocElementContent(ctxt->myDoc, ret);
         return (NULL);
       }
       SKIP_BLANKS;
@@ -6477,6 +6599,7 @@
     if (!IS_BLANK_CH(CUR)) {
       xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
                      "Space required after 'ELEMENT'\n");
+      return (-1);
     }
     SKIP_BLANKS;
     name = xmlParseName(ctxt);
@@ -6585,6 +6708,8 @@
     SKIP_BLANKS;
     if (RAW != '[') {
       xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+      xmlHaltParser(ctxt);
+      return;
     } else {
       if (ctxt->input->id != id) {
         xmlValidityError(
@@ -6625,6 +6750,7 @@
 
       if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {
         xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
+        xmlHaltParser(ctxt);
         break;
       }
     }
@@ -6645,6 +6771,8 @@
     SKIP_BLANKS;
     if (RAW != '[') {
       xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
+      xmlHaltParser(ctxt);
+      return;
     } else {
       if (ctxt->input->id != id) {
         xmlValidityError(
@@ -6700,6 +6828,8 @@
 
   } else {
     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
+    xmlHaltParser(ctxt);
+    return;
   }
 
   if (RAW == 0)
@@ -6714,7 +6844,9 @@
           "All markup of the conditional section is not in the same entity\n",
           NULL, NULL);
     }
-    SKIP(3);
+    if ((ctxt->instate != XML_PARSER_EOF) &&
+        ((ctxt->input->cur + 3) <= ctxt->input->end))
+      SKIP(3);
   }
 }
 
@@ -6768,6 +6900,14 @@
       xmlParsePI(ctxt);
     }
   }
+
+  /*
+   * detect requirement to exit there and act accordingly
+   * and avoid having instate overriden later on
+   */
+  if (ctxt->instate == XML_PARSER_EOF)
+    return;
+
   /*
    * This is only for internal subset. On external entities,
    * the replacement is done before parsing stage
@@ -6895,7 +7035,7 @@
       /*
        * The XML REC instructs us to stop parsing right here
        */
-      ctxt->instate = XML_PARSER_EOF;
+      xmlHaltParser(ctxt);
       return;
     }
   }
@@ -7045,7 +7185,8 @@
    * far more secure as the parser will only process data coming from
    * the document entity by default.
    */
-  if ((ent->checked == 0) &&
+  if (((ent->checked == 0) ||
+       ((ent->children == NULL) && (ctxt->options & XML_PARSE_NOENT))) &&
       ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
        (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
     unsigned long oldnbent = ctxt->nbentities;
@@ -7149,6 +7290,7 @@
     } else if ((ret != XML_ERR_OK) && (ret != XML_WAR_UNDECLARED_ENTITY)) {
       xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
                         "Entity '%s' failed to parse\n", ent->name);
+      xmlParserEntityCheck(ctxt, 0, ent, 0);
     } else if (list != NULL) {
       xmlFreeNodeList(list);
       list = NULL;
@@ -7254,7 +7396,7 @@
         /*
          * We are copying here, make sure there is no abuse
          */
-        ctxt->sizeentcopy += ent->length;
+        ctxt->sizeentcopy += ent->length + 5;
         if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
           return;
 
@@ -7299,7 +7441,7 @@
         /*
          * We are copying here, make sure there is no abuse
          */
-        ctxt->sizeentcopy += ent->length;
+        ctxt->sizeentcopy += ent->length + 5;
         if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))
           return;
 
@@ -7478,6 +7620,7 @@
         ctxt->sax->reference(ctxt->userData, name);
       }
     }
+    xmlParserEntityCheck(ctxt, 0, ent, 0);
     ctxt->valid = 0;
   }
 
@@ -7509,8 +7652,8 @@
    */
   else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) && (ent != NULL) &&
            (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
-    if ((ent->checked & 1) || ((ent->checked == 0) && (ent->content != NULL) &&
-                               (xmlStrchr(ent->content, '<')))) {
+    if (((ent->checked & 1) || (ent->checked == 0)) && (ent->content != NULL) &&
+        (xmlStrchr(ent->content, '<'))) {
       xmlFatalErrMsgStr(
           ctxt, XML_ERR_LT_IN_ATTRIBUTE,
           "'<' in entity '%s' is not allowed in attributes values\n", name);
@@ -7604,7 +7747,7 @@
   ptr++;
 
   /*
-   * Predefined entites override any extra definition
+   * Predefined entities override any extra definition
    */
   if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
     ent = xmlGetPredefinedEntity(name);
@@ -7668,6 +7811,7 @@
       xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY, "Entity '%s' not defined\n",
                    name);
     }
+    xmlParserEntityCheck(ctxt, 0, ent, 0);
     /* TODO ? check regressions ctxt->valid = 0; */
   }
 
@@ -7821,6 +7965,7 @@
                     "PEReference: %%%s; not found\n", name, NULL);
       ctxt->valid = 0;
     }
+    xmlParserEntityCheck(ctxt, 0, NULL, 0);
   } else {
     /*
      * Internal checking in case the entity quest barfed
@@ -7834,6 +7979,14 @@
       if (xmlPushInput(ctxt, input) < 0)
         return;
     } else {
+      if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+          ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+          ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+          ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+          ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+          (ctxt->replaceEntities == 0) && (ctxt->validate == 0))
+        return;
+
       /*
        * TODO !!!
        * handle the extra spaces added before and after
@@ -7850,7 +8003,7 @@
            * The XML REC instructs us to stop parsing
            * right here
            */
-          ctxt->instate = XML_PARSER_EOF;
+          xmlHaltParser(ctxt);
           return;
         }
       }
@@ -8054,6 +8207,7 @@
                     "PEReference: %%%s; not found\n", name, NULL);
       ctxt->valid = 0;
     }
+    xmlParserEntityCheck(ctxt, 0, NULL, 0);
   } else {
     /*
      * Internal checking in case the entity quest barfed
@@ -8199,6 +8353,7 @@
    */
   if (RAW != '>') {
     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
+    return;
   }
   NEXT;
 }
@@ -8543,7 +8698,7 @@
  * @prefix:  the prefix to lookup
  *
  * Lookup the namespace name for the @prefix (which ca be NULL)
- * The prefix must come from the @ctxt->dict dictionnary
+ * The prefix must come from the @ctxt->dict dictionary
  *
  * Returns the namespace name or NULL if not bound
  */
@@ -8738,9 +8893,12 @@
   xmlChar limit = 0;
   const xmlChar *in = NULL, *start, *end, *last;
   xmlChar *ret = NULL;
+  int line, col;
 
   GROW;
   in = (xmlChar *)CUR_PTR;
+  line = ctxt->input->line;
+  col = ctxt->input->col;
   if (*in != '"' && *in != '\'') {
     xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
     return (NULL);
@@ -8753,6 +8911,7 @@
    * pure ASCII.
    */
   limit = *in++;
+  col++;
   end = ctxt->input->end;
   start = in;
   if (in >= end) {
@@ -8771,6 +8930,12 @@
      */
     while ((in < end) && (*in != limit) &&
            ((*in == 0x20) || (*in == 0x9) || (*in == 0xA) || (*in == 0xD))) {
+      if (*in == 0xA) {
+        line++;
+        col = 1;
+      } else {
+        col++;
+      }
       in++;
       start = in;
       if (in >= end) {
@@ -8794,6 +8959,7 @@
     }
     while ((in < end) && (*in != limit) && (*in >= 0x20) && (*in <= 0x7f) &&
            (*in != '&') && (*in != '<')) {
+      col++;
       if ((*in++ == 0x20) && (*in == 0x20))
         break;
       if (in >= end) {
@@ -8823,6 +8989,11 @@
       last--;
     while ((in < end) && (*in != limit) &&
            ((*in == 0x20) || (*in == 0x9) || (*in == 0xA) || (*in == 0xD))) {
+      if (*in == 0xA) {
+        line++, col = 1;
+      } else {
+        col++;
+      }
       in++;
       if (in >= end) {
         const xmlChar *oldbase = ctxt->input->base;
@@ -8856,6 +9027,7 @@
     while ((in < end) && (*in != limit) && (*in >= 0x20) && (*in <= 0x7f) &&
            (*in != '&') && (*in != '<')) {
       in++;
+      col++;
       if (in >= end) {
         const xmlChar *oldbase = ctxt->input->base;
         GROW;
@@ -8886,6 +9058,7 @@
       goto need_complex;
   }
   in++;
+  col++;
   if (len != NULL) {
     *len = last - start;
     ret = (xmlChar *)start;
@@ -8895,6 +9068,8 @@
     ret = xmlStrndup(start, last - start);
   }
   CUR_PTR = in;
+  ctxt->input->line = line;
+  ctxt->input->col = col;
   if (alloc)
     *alloc = 0;
   return ret;
@@ -9060,8 +9235,7 @@
   const xmlChar **atts = ctxt->atts;
   int maxatts = ctxt->maxatts;
   int nratts, nbatts, nbdef;
-  int i, j, nbNs, attval, oldline, oldcol;
-  const xmlChar *base;
+  int i, j, nbNs, attval;
   unsigned long cur;
   int nsNr = ctxt->nsNr;
 
@@ -9076,12 +9250,8 @@
    *       The Shrinking is only possible once the full set of attribute
    *       callbacks have been done.
    */
-reparse:
   SHRINK;
-  base = ctxt->input->base;
   cur = ctxt->input->cur - ctxt->input->base;
-  oldline = ctxt->input->line;
-  oldcol = ctxt->input->col;
   nbatts = 0;
   nratts = 0;
   nbdef = 0;
@@ -9105,8 +9275,6 @@
    */
   SKIP_BLANKS;
   GROW;
-  if (ctxt->input->base != base)
-    goto base_changed;
 
   while (((RAW != '>') && ((RAW != '/') || (NXT(1) != '>')) &&
           (IS_BYTE_CHAR(RAW))) &&
@@ -9117,146 +9285,133 @@
 
     attname = xmlParseAttribute2(ctxt, prefix, localname, &aprefix, &attvalue,
                                  &len, &alloc);
-    if (ctxt->input->base != base) {
-      if ((attvalue != NULL) && (alloc != 0))
-        xmlFree(attvalue);
-      attvalue = NULL;
-      goto base_changed;
-    }
-    if ((attname != NULL) && (attvalue != NULL)) {
-      if (len < 0)
-        len = xmlStrlen(attvalue);
-      if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
-        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);
-        xmlURIPtr uri;
-
-        if (*URL != 0) {
-          uri = xmlParseURI((const char *)URL);
-          if (uri == NULL) {
-            xmlNsErr(ctxt, XML_WAR_NS_URI, "xmlns: '%s' is not a valid URI\n",
-                     URL, NULL, NULL);
-          } else {
-            if (uri->scheme == NULL) {
-              xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
-                        "xmlns: URI %s is not absolute\n", URL, NULL, NULL);
-            }
-            xmlFreeURI(uri);
-          }
-          if (URL == ctxt->str_xml_ns) {
-            if (attname != ctxt->str_xml) {
-              xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
-                       "xml namespace URI cannot be the default namespace\n",
-                       NULL, NULL, NULL);
-            }
-            goto skip_default_ns;
-          }
-          if ((len == 29) &&
-              (xmlStrEqual(URL, BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
-            xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
-                     "reuse of the xmlns namespace name is forbidden\n", NULL,
-                     NULL, NULL);
-            goto skip_default_ns;
-          }
-        }
-        /*
-         * check that it's not a defined namespace
-         */
-        for (j = 1; j <= nbNs; j++)
-          if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)
-            break;
-        if (j <= nbNs)
-          xmlErrAttributeDup(ctxt, NULL, attname);
-        else if (nsPush(ctxt, NULL, URL) > 0)
-          nbNs++;
-      skip_default_ns:
-        if (alloc != 0)
+    if ((attname == NULL) || (attvalue == NULL))
+      goto next_attr;
+    if (len < 0)
+      len = xmlStrlen(attvalue);
+
+    if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
+      const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);
+      xmlURIPtr uri;
+
+      if (URL == NULL) {
+        xmlErrMemory(ctxt, "dictionary allocation failure");
+        if ((attvalue != NULL) && (alloc != 0))
           xmlFree(attvalue);
-        SKIP_BLANKS;
-        continue;
+        return (NULL);
       }
-      if (aprefix == ctxt->str_xmlns) {
-        const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);
-        xmlURIPtr uri;
-
-        if (attname == ctxt->str_xml) {
-          if (URL != ctxt->str_xml_ns) {
-            xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
-                     "xml namespace prefix mapped to wrong URI\n", NULL, NULL,
-                     NULL);
+      if (*URL != 0) {
+        uri = xmlParseURI((const char *)URL);
+        if (uri == NULL) {
+          xmlNsErr(ctxt, XML_WAR_NS_URI, "xmlns: '%s' is not a valid URI\n",
+                   URL, NULL, NULL);
+        } else {
+          if (uri->scheme == NULL) {
+            xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
+                      "xmlns: URI %s is not absolute\n", URL, NULL, NULL);
           }
-          /*
-           * Do not keep a namespace definition node
-           */
-          goto skip_ns;
+          xmlFreeURI(uri);
         }
         if (URL == ctxt->str_xml_ns) {
           if (attname != ctxt->str_xml) {
             xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
-                     "xml namespace URI mapped to wrong prefix\n", NULL, NULL,
-                     NULL);
+                     "xml namespace URI cannot be the default namespace\n",
+                     NULL, NULL, NULL);
           }
-          goto skip_ns;
-        }
-        if (attname == ctxt->str_xmlns) {
-          xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
-                   "redefinition of the xmlns prefix is forbidden\n", NULL,
-                   NULL, NULL);
-          goto skip_ns;
+          goto next_attr;
         }
         if ((len == 29) &&
             (xmlStrEqual(URL, BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
           xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                    "reuse of the xmlns namespace name is forbidden\n", NULL,
                    NULL, NULL);
-          goto skip_ns;
+          goto next_attr;
         }
-        if ((URL == NULL) || (URL[0] == 0)) {
+      }
+      /*
+       * check that it's not a defined namespace
+       */
+      for (j = 1; j <= nbNs; j++)
+        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)
+          break;
+      if (j <= nbNs)
+        xmlErrAttributeDup(ctxt, NULL, attname);
+      else if (nsPush(ctxt, NULL, URL) > 0)
+        nbNs++;
+
+    } else if (aprefix == ctxt->str_xmlns) {
+      const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);
+      xmlURIPtr uri;
+
+      if (attname == ctxt->str_xml) {
+        if (URL != ctxt->str_xml_ns) {
           xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
-                   "xmlns:%s: Empty XML namespace is not allowed\n", attname,
-                   NULL, NULL);
-          goto skip_ns;
-        } else {
-          uri = xmlParseURI((const char *)URL);
-          if (uri == NULL) {
-            xmlNsErr(ctxt, XML_WAR_NS_URI,
-                     "xmlns:%s: '%s' is not a valid URI\n", attname, URL, NULL);
-          } else {
-            if ((ctxt->pedantic) && (uri->scheme == NULL)) {
-              xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
-                        "xmlns:%s: URI %s is not absolute\n", attname, URL,
-                        NULL);
-            }
-            xmlFreeURI(uri);
-          }
+                   "xml namespace prefix mapped to wrong URI\n", NULL, NULL,
+                   NULL);
         }
-
         /*
-         * check that it's not a defined namespace
+         * Do not keep a namespace definition node
          */
-        for (j = 1; j <= nbNs; j++)
-          if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)
-            break;
-        if (j <= nbNs)
-          xmlErrAttributeDup(ctxt, aprefix, attname);
-        else if (nsPush(ctxt, attname, URL) > 0)
-          nbNs++;
-      skip_ns:
-        if (alloc != 0)
-          xmlFree(attvalue);
-        SKIP_BLANKS;
-        if (ctxt->input->base != base)
-          goto base_changed;
-        continue;
+        goto next_attr;
+      }
+      if (URL == ctxt->str_xml_ns) {
+        if (attname != ctxt->str_xml) {
+          xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
+                   "xml namespace URI mapped to wrong prefix\n", NULL, NULL,
+                   NULL);
+        }
+        goto next_attr;
+      }
+      if (attname == ctxt->str_xmlns) {
+        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
+                 "redefinition of the xmlns prefix is forbidden\n", NULL, NULL,
+                 NULL);
+        goto next_attr;
+      }
+      if ((len == 29) &&
+          (xmlStrEqual(URL, BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
+        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
+                 "reuse of the xmlns namespace name is forbidden\n", NULL, NULL,
+                 NULL);
+        goto next_attr;
+      }
+      if ((URL == NULL) || (URL[0] == 0)) {
+        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
+                 "xmlns:%s: Empty XML namespace is not allowed\n", attname,
+                 NULL, NULL);
+        goto next_attr;
+      } else {
+        uri = xmlParseURI((const char *)URL);
+        if (uri == NULL) {
+          xmlNsErr(ctxt, XML_WAR_NS_URI, "xmlns:%s: '%s' is not a valid URI\n",
+                   attname, URL, NULL);
+        } else {
+          if ((ctxt->pedantic) && (uri->scheme == NULL)) {
+            xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
+                      "xmlns:%s: URI %s is not absolute\n", attname, URL, NULL);
+          }
+          xmlFreeURI(uri);
+        }
       }
 
       /*
+       * check that it's not a defined namespace
+       */
+      for (j = 1; j <= nbNs; j++)
+        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)
+          break;
+      if (j <= nbNs)
+        xmlErrAttributeDup(ctxt, aprefix, attname);
+      else if (nsPush(ctxt, attname, URL) > 0)
+        nbNs++;
+
+    } else {
+      /*
        * Add the pair to atts
        */
       if ((atts == NULL) || (nbatts + 5 > maxatts)) {
         if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
-          if (attvalue[len] == 0)
-            xmlFree(attvalue);
-          goto failed;
+          goto next_attr;
         }
         maxatts = ctxt->maxatts;
         atts = ctxt->atts;
@@ -9264,7 +9419,16 @@
       ctxt->attallocs[nratts++] = alloc;
       atts[nbatts++] = attname;
       atts[nbatts++] = aprefix;
-      atts[nbatts++] = NULL; /* the URI will be fetched later */
+      /*
+       * The namespace URI field is used temporarily to point at the
+       * base of the current input buffer for non-alloced attributes.
+       * When the input buffer is reallocated, all the pointers become
+       * invalid, but they can be reconstructed later.
+       */
+      if (alloc)
+        atts[nbatts++] = NULL;
+      else
+        atts[nbatts++] = ctxt->input->base;
       atts[nbatts++] = attvalue;
       attvalue += len;
       atts[nbatts++] = attvalue;
@@ -9273,16 +9437,16 @@
        */
       if (alloc != 0)
         attval = 1;
-    } else {
-      if ((attvalue != NULL) && (attvalue[len] == 0))
-        xmlFree(attvalue);
+      attvalue = NULL; /* moved into atts */
     }
 
-  failed:
+  next_attr:
+    if ((attvalue != NULL) && (alloc != 0)) {
+      xmlFree(attvalue);
+      attvalue = NULL;
+    }
 
     GROW if (ctxt->instate == XML_PARSER_EOF) break;
-    if (ctxt->input->base != base)
-      goto base_changed;
     if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
       break;
     if (!IS_BLANK_CH(RAW)) {
@@ -9298,8 +9462,20 @@
       break;
     }
     GROW;
-    if (ctxt->input->base != base)
-      goto base_changed;
+  }
+
+  /* Reconstruct attribute value pointers. */
+  for (i = 0, j = 0; j < nratts; i += 5, j++) {
+    if (atts[i + 2] != NULL) {
+      /*
+       * Arithmetic on dangling pointers is technically undefined
+       * behavior, but well...
+       */
+      ptrdiff_t offset = ctxt->input->base - atts[i + 2];
+      atts[i + 2] = NULL;    /* Reset repurposed namespace URI */
+      atts[i + 3] += offset; /* value */
+      atts[i + 4] += offset; /* valuend */
+    }
   }
 
   /*
@@ -9458,23 +9634,6 @@
   }
 
   return (localname);
-
-base_changed:
-  /*
-   * the attribute strings are valid iif the base didn't changed
-   */
-  if (attval != 0) {
-    for (i = 3, j = 0; j < nratts; i += 5, j++)
-      if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))
-        xmlFree((xmlChar *)atts[i]);
-  }
-  ctxt->input->cur = ctxt->input->base + cur;
-  ctxt->input->line = oldline;
-  ctxt->input->col = oldcol;
-  if (ctxt->wellFormed == 1) {
-    goto reparse;
-  }
-  return (NULL);
 }
 
 /**
@@ -9495,6 +9654,7 @@
 static void xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
                             const xmlChar *URI, int line, int nsNr, int tlen) {
   const xmlChar *name;
+  size_t curLength;
 
   GROW;
   if ((RAW != '<') || (NXT(1) != '/')) {
@@ -9503,12 +9663,16 @@
   }
   SKIP(2);
 
-  if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
-    if (ctxt->input->cur[tlen] == '>') {
+  curLength = ctxt->input->end - ctxt->input->cur;
+  if ((tlen > 0) && (curLength >= (size_t)tlen) &&
+      (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+    if ((curLength >= (size_t)(tlen + 1)) && (ctxt->input->cur[tlen] == '>')) {
       ctxt->input->cur += tlen + 1;
+      ctxt->input->col += tlen + 1;
       goto done;
     }
     ctxt->input->cur += tlen;
+    ctxt->input->col += tlen;
     name = (xmlChar *)1;
   } else {
     if (prefix == NULL)
@@ -9744,7 +9908,7 @@
     if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {
       xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                   "detected an error in element content\n");
-      ctxt->instate = XML_PARSER_EOF;
+      xmlHaltParser(ctxt);
       break;
     }
   }
@@ -9779,7 +9943,7 @@
         ctxt, XML_ERR_INTERNAL_ERROR,
         "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
         xmlParserMaxDepth);
-    ctxt->instate = XML_PARSER_EOF;
+    xmlHaltParser(ctxt);
     return;
   }
 
@@ -10120,6 +10284,8 @@
       encoding = xmlParseEncName(ctxt);
       if (RAW != '"') {
         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+        xmlFree((xmlChar *)encoding);
+        return (NULL);
       } else
         NEXT;
     } else if (RAW == '\'') {
@@ -10127,6 +10293,8 @@
       encoding = xmlParseEncName(ctxt);
       if (RAW != '\'') {
         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+        xmlFree((xmlChar *)encoding);
+        return (NULL);
       } else
         NEXT;
     } else {
@@ -10136,8 +10304,10 @@
     /*
      * Non standard parsing, allowing the user to ignore encoding
      */
-    if (ctxt->options & XML_PARSE_IGNORE_ENC)
-      return (encoding);
+    if (ctxt->options & XML_PARSE_IGNORE_ENC) {
+      xmlFree((xmlChar *)encoding);
+      return (NULL);
+    }
 
     /*
      * UTF-16 encoding stwich has already taken place at this stage,
@@ -10178,7 +10348,11 @@
 
       handler = xmlFindCharEncodingHandler((const char *)encoding);
       if (handler != NULL) {
-        xmlSwitchToEncoding(ctxt, handler);
+        if (xmlSwitchToEncoding(ctxt, handler) < 0) {
+          /* failed to convert */
+          ctxt->errNo = XML_ERR_UNSUPPORTED_ENCODING;
+          return (NULL);
+        }
       } else {
         xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
                           "Unsupported encoding %s\n", encoding);
@@ -10340,7 +10514,8 @@
     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
   }
   xmlParseEncodingDecl(ctxt);
-  if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
+  if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
+      (ctxt->instate == XML_PARSER_EOF)) {
     /*
      * The XML REC instructs us to stop parsing right here
      */
@@ -10460,6 +10635,7 @@
 
   if (CUR == 0) {
     xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
+    return (-1);
   }
 
   /*
@@ -10477,7 +10653,8 @@
      * Note that we will switch encoding on the fly.
      */
     xmlParseXMLDecl(ctxt);
-    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
+    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
+        (ctxt->instate == XML_PARSER_EOF)) {
       /*
        * The XML REC instructs us to stop parsing right here
        */
@@ -10492,6 +10669,10 @@
     ctxt->sax->startDocument(ctxt->userData);
   if (ctxt->instate == XML_PARSER_EOF)
     return (-1);
+  if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
+      (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {
+    ctxt->myDoc->compression = ctxt->input->buf->compressed;
+  }
 
   /*
    * The Misc part of the Prolog
@@ -10846,15 +11027,16 @@
 }
 /**
  * xmlCheckCdataPush:
- * @cur: pointer to the bock of characters
+ * @cur: pointer to the block of characters
  * @len: length of the block in bytes
+ * @complete: 1 if complete CDATA block is passed in, 0 if partial block
  *
  * Check that the block of characters is okay as SCdata content [20]
  *
  * Returns the number of bytes to pass if okay, a negative index where an
  *         UTF-8 error occured otherwise
  */
-static int xmlCheckCdataPush(const xmlChar *utf, int len) {
+static int xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {
   int ix;
   unsigned char c;
   int codepoint;
@@ -10873,7 +11055,7 @@
         return (-ix);
     } else if ((c & 0xe0) == 0xc0) { /* 2-byte code, starts with 110 */
       if (ix + 2 > len)
-        return (ix);
+        return (complete ? -ix : ix);
       if ((utf[ix + 1] & 0xc0) != 0x80)
         return (-ix);
       codepoint = (utf[ix] & 0x1f) << 6;
@@ -10883,7 +11065,7 @@
       ix += 2;
     } else if ((c & 0xf0) == 0xe0) { /* 3-byte code, starts with 1110 */
       if (ix + 3 > len)
-        return (ix);
+        return (complete ? -ix : ix);
       if (((utf[ix + 1] & 0xc0) != 0x80) || ((utf[ix + 2] & 0xc0) != 0x80))
         return (-ix);
       codepoint = (utf[ix] & 0xf) << 12;
@@ -10894,7 +11076,7 @@
       ix += 3;
     } else if ((c & 0xf8) == 0xf0) { /* 4-byte code, starts with 11110 */
       if (ix + 4 > len)
-        return (ix);
+        return (complete ? -ix : ix);
       if (((utf[ix + 1] & 0xc0) != 0x80) || ((utf[ix + 2] & 0xc0) != 0x80) ||
           ((utf[ix + 3] & 0xc0) != 0x80))
         return (-ix);
@@ -11066,7 +11248,7 @@
         if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
           ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
-        ctxt->instate = XML_PARSER_EOF;
+        xmlHaltParser(ctxt);
 #ifdef DEBUG_PUSH
         xmlGenericError(xmlGenericErrorContext, "PP: entering EOF\n");
 #endif
@@ -11095,7 +11277,7 @@
              * The XML REC instructs us to stop parsing right
              * here
              */
-            ctxt->instate = XML_PARSER_EOF;
+            xmlHaltParser(ctxt);
             return (0);
           }
           ctxt->standalone = ctxt->input->standalone;
@@ -11143,7 +11325,7 @@
       cur = ctxt->input->cur[0];
       if (cur != '<') {
         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
-        ctxt->instate = XML_PARSER_EOF;
+        xmlHaltParser(ctxt);
         if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
           ctxt->sax->endDocument(ctxt->userData);
         goto done;
@@ -11175,7 +11357,7 @@
         goto done;
       if (name == NULL) {
         spacePop(ctxt);
-        ctxt->instate = XML_PARSER_EOF;
+        xmlHaltParser(ctxt);
         if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
           ctxt->sax->endDocument(ctxt->userData);
         goto done;
@@ -11328,7 +11510,7 @@
       if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {
         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                     "detected an error in element content\n");
-        ctxt->instate = XML_PARSER_EOF;
+        xmlHaltParser(ctxt);
         break;
       }
       break;
@@ -11375,7 +11557,8 @@
         if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {
           int tmp;
 
-          tmp = xmlCheckCdataPush(ctxt->input->cur, XML_PARSER_BIG_BUFFER_SIZE);
+          tmp = xmlCheckCdataPush(ctxt->input->cur, XML_PARSER_BIG_BUFFER_SIZE,
+                                  0);
           if (tmp < 0) {
             tmp = -tmp;
             ctxt->input->cur += tmp;
@@ -11396,7 +11579,7 @@
       } else {
         int tmp;
 
-        tmp = xmlCheckCdataPush(ctxt->input->cur, base);
+        tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);
         if ((tmp < 0) || (tmp != base)) {
           tmp = -tmp;
           ctxt->input->cur += tmp;
@@ -11612,7 +11795,7 @@
         goto done;
       } else {
         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
-        ctxt->instate = XML_PARSER_EOF;
+        xmlHaltParser(ctxt);
 #ifdef DEBUG_PUSH
         xmlGenericError(xmlGenericErrorContext, "PP: entering EOF\n");
 #endif
@@ -11961,7 +12144,7 @@
     res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
     if (res < 0) {
       ctxt->errNo = XML_PARSER_EOF;
-      ctxt->disableSAX = 1;
+      xmlHaltParser(ctxt);
       return (XML_PARSER_EOF);
     }
     xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
@@ -12014,7 +12197,7 @@
        ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&
       ((ctxt->options & XML_PARSE_HUGE) == 0)) {
     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
-    ctxt->instate = XML_PARSER_EOF;
+    xmlHaltParser(ctxt);
   }
   if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
     return (ctxt->errNo);
@@ -12199,24 +12382,45 @@
 #endif /* LIBXML_PUSH_ENABLED */
 
 /**
- * xmlStopParser:
+ * xmlHaltParser:
  * @ctxt:  an XML parser context
  *
- * Blocks further parser processing
+ * Blocks further parser processing don't override error
+ * for internal use
  */
-void xmlStopParser(xmlParserCtxtPtr ctxt) {
+static void xmlHaltParser(xmlParserCtxtPtr ctxt) {
   if (ctxt == NULL)
     return;
   ctxt->instate = XML_PARSER_EOF;
-  ctxt->errNo = XML_ERR_USER_STOP;
   ctxt->disableSAX = 1;
   if (ctxt->input != NULL) {
+    /*
+     * in case there was a specific allocation deallocate before
+     * overriding base
+     */
+    if (ctxt->input->free != NULL) {
+      ctxt->input->free((xmlChar *)ctxt->input->base);
+      ctxt->input->free = NULL;
+    }
     ctxt->input->cur = BAD_CAST "";
     ctxt->input->base = ctxt->input->cur;
   }
 }
 
 /**
+ * xmlStopParser:
+ * @ctxt:  an XML parser context
+ *
+ * Blocks further parser processing
+ */
+void xmlStopParser(xmlParserCtxtPtr ctxt) {
+  if (ctxt == NULL)
+    return;
+  xmlHaltParser(ctxt);
+  ctxt->errNo = XML_ERR_USER_STOP;
+}
+
+/**
  * xmlCreateIOParserCtxt:
  * @sax:  a SAX handler
  * @user_data:  The user data returned on SAX callbacks
@@ -12318,6 +12522,9 @@
     return (NULL);
   }
 
+  /* We are loading a DTD */
+  ctxt->options |= XML_PARSE_DTDLOAD;
+
   /*
    * Set-up the SAX context
    */
@@ -12448,6 +12655,9 @@
     return (NULL);
   }
 
+  /* We are loading a DTD */
+  ctxt->options |= XML_PARSE_DTDLOAD;
+
   /*
    * Set-up the SAX context
    */
@@ -12959,7 +13169,7 @@
   /*
    * Also record the size of the entity parsed
    */
-  if (ctxt->input != NULL) {
+  if (ctxt->input != NULL && oldctxt != NULL) {
     oldctxt->sizeentities += ctxt->input->consumed;
     oldctxt->sizeentities += (ctxt->input->cur - ctxt->input->base);
   }
@@ -12971,9 +13181,11 @@
 
   if (sax != NULL)
     ctxt->sax = oldsax;
-  oldctxt->node_seq.maximum = ctxt->node_seq.maximum;
-  oldctxt->node_seq.length = ctxt->node_seq.length;
-  oldctxt->node_seq.buffer = ctxt->node_seq.buffer;
+  if (oldctxt != NULL) {
+    oldctxt->node_seq.maximum = ctxt->node_seq.maximum;
+    oldctxt->node_seq.length = ctxt->node_seq.length;
+    oldctxt->node_seq.buffer = ctxt->node_seq.buffer;
+  }
   ctxt->node_seq.maximum = 0;
   ctxt->node_seq.length = 0;
   ctxt->node_seq.buffer = NULL;
@@ -13339,7 +13551,7 @@
       xmlFree((xmlChar *)ctxt->encoding);
     ctxt->encoding = xmlStrdup((const xmlChar *)doc->encoding);
 
-    hdlr = xmlFindCharEncodingHandler(doc->encoding);
+    hdlr = xmlFindCharEncodingHandler((const char *)doc->encoding);
     if (hdlr != NULL) {
       xmlSwitchToEncoding(ctxt, hdlr);
     } else {
@@ -13350,6 +13562,8 @@
   xmlCtxtUseOptionsInternal(ctxt, options, NULL);
   xmlDetectSAX2(ctxt);
   ctxt->myDoc = doc;
+  /* parsing in context, i.e. as within existing content */
+  ctxt->instate = XML_PARSER_CONTENT;
 
   fake = xmlNewComment(NULL);
   if (fake == NULL) {
@@ -13385,7 +13599,6 @@
       }
       cur = cur->parent;
     }
-    ctxt->instate = XML_PARSER_CONTENT;
   }
 
   if ((ctxt->validate) || (ctxt->replaceEntities != 0)) {
@@ -14471,8 +14684,8 @@
   xmlSchemaCleanupTypes();
   xmlRelaxNGCleanupTypes();
 #endif
-  xmlCleanupGlobals();
   xmlResetLastError();
+  xmlCleanupGlobals();
   xmlCleanupThreads(); /* must be last if called not from the main thread */
   xmlCleanupMemory();
   xmlParserInitialized = 0;
@@ -14488,7 +14701,7 @@
  * DICT_FREE:
  * @str:  a string
  *
- * Free a string if it is not owned by the "dict" dictionnary in the
+ * Free a string if it is not owned by the "dict" dictionary in the
  * current scope
  */
 #define DICT_FREE(str)                                                         \
@@ -14797,6 +15010,10 @@
     ctxt->options |= XML_PARSE_NONET;
     options -= XML_PARSE_NONET;
   }
+  if (options & XML_PARSE_NOXXE) {
+    ctxt->options |= XML_PARSE_NOXXE;
+    options -= XML_PARSE_NOXXE;
+  }
   if (options & XML_PARSE_COMPACT) {
     ctxt->options |= XML_PARSE_COMPACT;
     options -= XML_PARSE_COMPACT;
@@ -14905,6 +15122,7 @@
 
   if (cur == NULL)
     return (NULL);
+  xmlInitParser();
 
   ctxt = xmlCreateDocParserCtxt(cur);
   if (ctxt == NULL)
@@ -14925,6 +15143,7 @@
 xmlDocPtr xmlReadFile(const char *filename, const char *encoding, int options) {
   xmlParserCtxtPtr ctxt;
 
+  xmlInitParser();
   ctxt = xmlCreateURLParserCtxt(filename, options);
   if (ctxt == NULL)
     return (NULL);
@@ -14947,6 +15166,7 @@
                         const char *encoding, int options) {
   xmlParserCtxtPtr ctxt;
 
+  xmlInitParser();
   ctxt = xmlCreateMemoryParserCtxt(buffer, size);
   if (ctxt == NULL)
     return (NULL);
@@ -14974,6 +15194,7 @@
 
   if (fd < 0)
     return (NULL);
+  xmlInitParser();
 
   input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
   if (input == NULL)
@@ -15016,6 +15237,7 @@
 
   if (ioread == NULL)
     return (NULL);
+  xmlInitParser();
 
   input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
                                        XML_CHAR_ENCODING_NONE);
@@ -15060,6 +15282,7 @@
     return (NULL);
   if (ctxt == NULL)
     return (NULL);
+  xmlInitParser();
 
   xmlCtxtReset(ctxt);
 
@@ -15091,6 +15314,7 @@
     return (NULL);
   if (ctxt == NULL)
     return (NULL);
+  xmlInitParser();
 
   xmlCtxtReset(ctxt);
 
@@ -15126,6 +15350,7 @@
     return (NULL);
   if (buffer == NULL)
     return (NULL);
+  xmlInitParser();
 
   xmlCtxtReset(ctxt);
 
@@ -15168,6 +15393,7 @@
     return (NULL);
   if (ctxt == NULL)
     return (NULL);
+  xmlInitParser();
 
   xmlCtxtReset(ctxt);
 
@@ -15209,6 +15435,7 @@
     return (NULL);
   if (ctxt == NULL)
     return (NULL);
+  xmlInitParser();
 
   xmlCtxtReset(ctxt);
 
