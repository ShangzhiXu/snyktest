--- /home/V1SCAN/CWE-119/FormattedUsed/d1_pkt-turicreate-6.4.1.c	2023-12-10 02:45:00.670136658 +0900
+++ /home/V1SCAN/CWE-119/FormattedPatch/NEW##CVE-2015-0206##0##openssl@@openssl##d1_pkt.c	2023-12-10 02:45:01.440175621 +0900
@@ -4,7 +4,7 @@
  * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.
  */
 /* ====================================================================
- * Copyright (c) 1998-2019 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -124,7 +124,7 @@
 
 /* mod 128 saturating subtract of two 64-bit values in big-endian order */
 static int satsub64be(const unsigned char *v1, const unsigned char *v2) {
-  int ret, i;
+  int ret, sat, brw, i;
 
   if (sizeof(long) == 8)
     do {
@@ -137,10 +137,8 @@
       if (is_endian.little)
         break;
       /* not reached on little-endians */
-      /*
-       * following test is redundant, because input is always aligned,
-       * but I take no chances...
-       */
+      /* following test is redundant, because input is
+       * always aligned, but I take no chances... */
       if (((size_t)v1 | (size_t)v2) & 0x7)
         break;
 
@@ -154,51 +152,28 @@
         return (int)l;
     } while (0);
 
-  ret = 0;
-  for (i = 0; i < 7; i++) {
-    if (v1[i] > v2[i]) {
-      /* v1 is larger... but by how much? */
-      if (v1[i] != v2[i] + 1)
-        return 128;
-      while (++i <= 6) {
-        if (v1[i] != 0x00 || v2[i] != 0xff)
-          return 128; /* too much */
-      }
-      /* We checked all the way to the penultimate byte,
-       * so despite higher bytes changing we actually
-       * know that it only changed from (e.g.)
-       *       ... (xx)  ff ff ff ??
-       * to   ... (xx+1) 00 00 00 ??
-       * so we add a 'bias' of 256 for the carry that
-       * happened, and will eventually return
-       * 256 + v1[7] - v2[7]. */
-      ret = 256;
-      break;
-    } else if (v2[i] > v1[i]) {
-      /* v2 is larger... but by how much? */
-      if (v2[i] != v1[i] + 1)
-        return -128;
-      while (++i <= 6) {
-        if (v2[i] != 0x00 || v1[i] != 0xff)
-          return -128; /* too much */
-      }
-      /* Similar to the case above, we know it changed
-       * from    ... (xx)  00 00 00 ??
-       * to     ... (xx-1) ff ff ff ??
-       * so we add a 'bias' of -256 for the borrow,
-       * to return -256 + v1[7] - v2[7]. */
-      ret = -256;
+  ret = (int)v1[7] - (int)v2[7];
+  sat = 0;
+  brw = ret >> 8; /* brw is either 0 or -1 */
+  if (ret & 0x80) {
+    for (i = 6; i >= 0; i--) {
+      brw += (int)v1[i] - (int)v2[i];
+      sat |= ~brw;
+      brw >>= 8;
+    }
+  } else {
+    for (i = 6; i >= 0; i--) {
+      brw += (int)v1[i] - (int)v2[i];
+      sat |= brw;
+      brw >>= 8;
     }
   }
+  brw <<= 8; /* brw is either 0 or -256 */
 
-  ret += (int)v1[7] - (int)v2[7];
-
-  if (ret > 128)
-    return 128;
-  else if (ret < -128)
-    return -128;
+  if (sat & 0xff)
+    return brw | 0x80;
   else
-    return ret;
+    return brw + (ret & 0xFF);
 }
 
 static int have_handshake_fragment(SSL *s, int type, unsigned char *buf,
@@ -209,12 +184,11 @@
                                       unsigned int *is_next_epoch);
 #if 0
 static int dtls1_record_needs_buffering(SSL *s, SSL3_RECORD *rr,
-                                        unsigned short *priority,
-                                        unsigned long *offset);
+	unsigned short *priority, unsigned long *offset);
 #endif
 static int dtls1_buffer_record(SSL *s, record_pqueue *q,
                                unsigned char *priority);
-static int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap);
+static int dtls1_process_record(SSL *s);
 
 /* copy buffered record into SSL structure */
 static int dtls1_copy_record(SSL *s, pitem *item) {
@@ -254,7 +228,7 @@
       pitem_free(item);
 
     SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
-    return -1;
+    return (0);
   }
 
   rdata->packet = s->packet;
@@ -288,12 +262,14 @@
     return (-1);
   }
 
+  /* insert should not fail, since duplicates are dropped */
   if (pqueue_insert(queue->q, item) == NULL) {
-    /* Must be a duplicate so ignore it */
+    SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
     if (rdata->rbuf.buf != NULL)
       OPENSSL_free(rdata->rbuf.buf);
     OPENSSL_free(rdata);
     pitem_free(item);
+    return (-1);
   }
 
   return (1);
@@ -315,169 +291,114 @@
   return (0);
 }
 
-/*
- * retrieve a buffered record that belongs to the new epoch, i.e., not
- * processed yet
- */
+/* retrieve a buffered record that belongs to the new epoch, i.e., not processed
+ * yet */
 #define dtls1_get_unprocessed_record(s)                                        \
   dtls1_retrieve_buffered_record((s), &((s)->d1->unprocessed_rcds))
 
-/*
- * retrieve a buffered record that belongs to the current epoch, ie,
- * processed
+/* retrieve a buffered record that belongs to the current epoch, ie, processed
  */
 #define dtls1_get_processed_record(s)                                          \
   dtls1_retrieve_buffered_record((s), &((s)->d1->processed_rcds))
 
 static int dtls1_process_buffered_records(SSL *s) {
   pitem *item;
-  SSL3_BUFFER *rb;
-  SSL3_RECORD *rr;
-  DTLS1_BITMAP *bitmap;
-  unsigned int is_next_epoch;
-  int replayok = 1;
 
   item = pqueue_peek(s->d1->unprocessed_rcds.q);
   if (item) {
     /* Check if epoch is current. */
     if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
-      return 1; /* Nothing to do. */
-
-    rr = &s->s3->rrec;
-    rb = &s->s3->rbuf;
-
-    if (rb->left > 0) {
-      /*
-       * We've still got data from the current packet to read. There could
-       * be a record from the new epoch in it - so don't overwrite it
-       * with the unprocessed records yet (we'll do it when we've
-       * finished reading the current packet).
-       */
-      return 1;
-    }
+      return (1); /* Nothing to do. */
 
     /* Process all the records. */
     while (pqueue_peek(s->d1->unprocessed_rcds.q)) {
       dtls1_get_unprocessed_record(s);
-      bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
-      if (bitmap == NULL) {
-        /*
-         * Should not happen. This will only ever be NULL when the
-         * current record is from a different epoch. But that cannot
-         * be the case because we already checked the epoch above
-         */
-        SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS, ERR_R_INTERNAL_ERROR);
-        return 0;
-      }
-#ifndef OPENSSL_NO_SCTP
-      /* Only do replay check if no SCTP bio */
-      if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
-#endif
-      {
-        /*
-         * Check whether this is a repeat, or aged record. We did this
-         * check once already when we first received the record - but
-         * we might have updated the window since then due to
-         * records we subsequently processed.
-         */
-        replayok = dtls1_record_replay_check(s, bitmap);
-      }
-
-      if (!replayok || !dtls1_process_record(s, bitmap)) {
-        /* dump this record */
-        rr->length = 0;
-        s->packet_length = 0;
-        continue;
-      }
-
+      if (!dtls1_process_record(s))
+        return (0);
       if (dtls1_buffer_record(s, &(s->d1->processed_rcds),
                               s->s3->rrec.seq_num) < 0)
-        return 0;
+        return -1;
     }
   }
 
-  /*
-   * sync epoch numbers once all the unprocessed records have been
-   * processed
-   */
+  /* sync epoch numbers once all the unprocessed records
+   * have been processed */
   s->d1->processed_rcds.epoch = s->d1->r_epoch;
   s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;
 
-  return 1;
+  return (1);
 }
 
 #if 0
 
-static int dtls1_get_buffered_record(SSL *s)
-{
-    pitem *item;
-    PQ_64BIT priority =
-        (((PQ_64BIT) s->d1->handshake_read_seq) << 32) |
-        ((PQ_64BIT) s->d1->r_msg_hdr.frag_off);
-
-    /* if we're not (re)negotiating, nothing buffered */
-    if (!SSL_in_init(s))
-        return 0;
-
-    item = pqueue_peek(s->d1->rcvd_records);
-    if (item && item->priority == priority) {
-        /*
-         * Check if we've received the record of interest.  It must be a
-         * handshake record, since data records as passed up without
-         * buffering
-         */
-        DTLS1_RECORD_DATA *rdata;
-        item = pqueue_pop(s->d1->rcvd_records);
-        rdata = (DTLS1_RECORD_DATA *)item->data;
-
-        if (s->s3->rbuf.buf != NULL)
-            OPENSSL_free(s->s3->rbuf.buf);
-
-        s->packet = rdata->packet;
-        s->packet_length = rdata->packet_length;
-        memcpy(&(s->s3->rbuf), &(rdata->rbuf), sizeof(SSL3_BUFFER));
-        memcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));
-
-        OPENSSL_free(item->data);
-        pitem_free(item);
-
-        /* s->d1->next_expected_seq_num++; */
-        return (1);
-    }
-
-    return 0;
-}
+static int
+dtls1_get_buffered_record(SSL *s)
+	{
+	pitem *item;
+	PQ_64BIT priority = 
+		(((PQ_64BIT)s->d1->handshake_read_seq) << 32) | 
+		((PQ_64BIT)s->d1->r_msg_hdr.frag_off);
+	
+	if ( ! SSL_in_init(s))  /* if we're not (re)negotiating, 
+							   nothing buffered */
+		return 0;
+
+
+	item = pqueue_peek(s->d1->rcvd_records);
+	if (item && item->priority == priority)
+		{
+		/* Check if we've received the record of interest.  It must be
+		 * a handshake record, since data records as passed up without
+		 * buffering */
+		DTLS1_RECORD_DATA *rdata;
+		item = pqueue_pop(s->d1->rcvd_records);
+		rdata = (DTLS1_RECORD_DATA *)item->data;
+		
+		if (s->s3->rbuf.buf != NULL)
+			OPENSSL_free(s->s3->rbuf.buf);
+		
+		s->packet = rdata->packet;
+		s->packet_length = rdata->packet_length;
+		memcpy(&(s->s3->rbuf), &(rdata->rbuf), sizeof(SSL3_BUFFER));
+		memcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));
+		
+		OPENSSL_free(item->data);
+		pitem_free(item);
+		
+		/* s->d1->next_expected_seq_num++; */
+		return(1);
+		}
+	
+	return 0;
+	}
 
 #endif
 
-static int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap) {
+static int dtls1_process_record(SSL *s) {
   int i, al;
   int enc_err;
   SSL_SESSION *sess;
   SSL3_RECORD *rr;
-  unsigned int mac_size, orig_len;
+  unsigned int mac_size;
   unsigned char md[EVP_MAX_MD_SIZE];
 
   rr = &(s->s3->rrec);
   sess = s->session;
 
-  /*
-   * At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
+  /* At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
    * and we have that many bytes in s->packet
    */
   rr->input = &(s->packet[DTLS1_RT_HEADER_LENGTH]);
 
-  /*
-   * ok, we can now read from 's->packet' data into 'rr' rr->input points
-   * at rr->length bytes, which need to be copied into rr->data by either
-   * the decryption or by the decompression When the data is 'copied' into
-   * the rr->data buffer, rr->input will be pointed at the new buffer
-   */
+  /* ok, we can now read from 's->packet' data into 'rr'
+   * rr->input points at rr->length bytes, which
+   * need to be copied into rr->data by either
+   * the decryption or by the decompression
+   * When the data is 'copied' into the rr->data buffer,
+   * rr->input will be pointed at the new buffer */
 
-  /*
-   * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length
-   * bytes of encrypted compressed stuff.
-   */
+  /* We now have - encrypted [ MAC [ compressed [ plain ] ] ]
+   * rr->length bytes of encrypted compressed stuff. */
 
   /* check is not needed I believe */
   if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
@@ -488,20 +409,20 @@
 
   /* decrypt in place in 'rr->input' */
   rr->data = rr->input;
+  rr->orig_len = rr->length;
 
   enc_err = s->method->ssl3_enc->enc(s, 0);
-  /*-
-   * enc_err is:
+  /* enc_err is:
    *    0: (in non-constant time) if the record is publically invalid.
    *    1: if the padding is valid
-   *   -1: if the padding is invalid
-   */
+   *    -1: if the padding is invalid */
   if (enc_err == 0) {
     /* For DTLS we simply ignore bad packets. */
     rr->length = 0;
     s->packet_length = 0;
     goto err;
   }
+
 #ifdef TLS_DEBUG
   printf("dec %d\n", rr->length);
   {
@@ -521,42 +442,33 @@
     mac_size = EVP_MD_CTX_size(s->read_hash);
     OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
 
-    /*
-     * kludge: *_cbc_remove_padding passes padding length in rr->type
-     */
-    orig_len = rr->length + ((unsigned int)rr->type >> 8);
-
-    /*
-     * orig_len is the length of the record before any padding was
+    /* orig_len is the length of the record before any padding was
      * removed. This is public information, as is the MAC in use,
-     * therefore we can safely process the record in a different amount
-     * of time if it's too short to possibly contain a MAC.
+     * therefore we can safely process the record in a different
+     * amount of time if it's too short to possibly contain a MAC.
      */
-    if (orig_len < mac_size ||
+    if (rr->orig_len < mac_size ||
         /* CBC records must have a padding length byte too. */
         (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
-         orig_len < mac_size + 1)) {
+         rr->orig_len < mac_size + 1)) {
       al = SSL_AD_DECODE_ERROR;
       SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
       goto f_err;
     }
 
     if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
-      /*
-       * We update the length so that the TLS header bytes can be
-       * constructed correctly but we need to extract the MAC in
-       * constant time from within the record, without leaking the
-       * contents of the padding bytes.
-       */
+      /* We update the length so that the TLS header bytes
+       * can be constructed correctly but we need to extract
+       * the MAC in constant time from within the record,
+       * without leaking the contents of the padding bytes.
+       * */
       mac = mac_tmp;
-      ssl3_cbc_copy_mac(mac_tmp, rr, mac_size, orig_len);
+      ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
       rr->length -= mac_size;
     } else {
-      /*
-       * In this case there's no padding, so |orig_len| equals
-       * |rec->length| and we checked that there's enough bytes for
-       * |mac_size| above.
-       */
+      /* In this case there's no padding, so |rec->orig_len|
+       * equals |rec->length| and we checked that there's
+       * enough bytes for |mac_size| above. */
       rr->length -= mac_size;
       mac = &rr->data[rr->length];
     }
@@ -598,19 +510,15 @@
   rr->off = 0;
   /*-
    * So at this point the following is true
-   * ssl->s3->rrec.type   is the type of record
-   * ssl->s3->rrec.length == number of bytes in record
-   * ssl->s3->rrec.off    == offset to first valid byte
-   * ssl->s3->rrec.data   == where to take bytes from, increment
-   *                         after use :-).
+   * ssl->s3->rrec.type 	is the type of record
+   * ssl->s3->rrec.length	== number of bytes in record
+   * ssl->s3->rrec.off	== offset to first valid byte
+   * ssl->s3->rrec.data	== where to take bytes from, increment
+   *			   after use :-).
    */
 
   /* we have pulled in a full packet so zero things */
   s->packet_length = 0;
-
-  /* Mark receipt of record. */
-  dtls1_record_bitmap_update(s, bitmap);
-
   return (1);
 
 f_err:
@@ -625,7 +533,7 @@
  * or non-blocking IO.
  * When it finishes, one packet has been decoded and can be found in
  * ssl->s3->rrec.type    - is the type of record
- * ssl->s3->rrec.data,   - data
+ * ssl->s3->rrec.data, 	 - data
  * ssl->s3->rrec.length, - number of bytes
  */
 /* used only by dtls1_read_bytes */
@@ -640,12 +548,9 @@
 
   rr = &(s->s3->rrec);
 
-again:
-  /*
-   * The epoch may have changed.  If so, process all the pending records.
-   * This is a non-blocking operation.
-   */
-  if (!dtls1_process_buffered_records(s))
+  /* The epoch may have changed.  If so, process all the
+   * pending records.  This is a non-blocking operation. */
+  if (dtls1_process_buffered_records(s) < 0)
     return -1;
 
   /* if we're renegotiating, then there may be buffered records */
@@ -653,6 +558,7 @@
     return 1;
 
   /* get something from the wire */
+again:
   /* check if we have the header */
   if ((s->rstate != SSL_ST_READ_BODY) ||
       (s->packet_length < DTLS1_RT_HEADER_LENGTH)) {
@@ -689,11 +595,8 @@
 
     n2s(p, rr->length);
 
-    /*
-     * Lets check the version. We tolerate alerts that don't have the exact
-     * version number (e.g. because of protocol version errors)
-     */
-    if (!s->first_packet && rr->type != SSL3_RT_ALERT) {
+    /* Lets check version */
+    if (!s->first_packet) {
       if (version != s->version) {
         /* unexpected version, silently discard */
         rr->length = 0;
@@ -732,10 +635,8 @@
       goto again;
     }
 
-    /*
-     * now n == rr->length, and s->packet_length ==
-     * DTLS1_RT_HEADER_LENGTH + rr->length
-     */
+    /* now n == rr->length,
+     * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */
   }
   s->rstate = SSL_ST_READ_HEADER; /* set state for later operations */
 
@@ -746,15 +647,16 @@
     s->packet_length = 0; /* dump this record */
     goto again;           /* get another record */
   }
+
 #ifndef OPENSSL_NO_SCTP
   /* Only do replay check if no SCTP bio */
   if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
 #endif
-    /*
-     * Check whether this is a repeat, or aged record. Don't check if
-     * we're listening and this message is a ClientHello. They can look
-     * as if they're replayed, since they arrive from different
-     * connections and would be dropped unnecessarily.
+    /* Check whether this is a repeat, or aged record.
+     * Don't check if we're listening and this message is
+     * a ClientHello. They can look as if they're replayed,
+     * since they arrive from different connections and
+     * would be dropped unnecessarily.
      */
     if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
           s->packet_length > DTLS1_RT_HEADER_LENGTH &&
@@ -772,27 +674,28 @@
   if (rr->length == 0)
     goto again;
 
-  /*
-   * If this record is from the next epoch (either HM or ALERT), and a
-   * handshake is currently in progress, buffer it since it cannot be
-   * processed at this time. However, do not buffer anything while
-   * listening.
+  /* If this record is from the next epoch (either HM or ALERT),
+   * and a handshake is currently in progress, buffer it since it
+   * cannot be processed at this time. However, do not buffer
+   * anything while listening.
    */
   if (is_next_epoch) {
     if ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen) {
       if (dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num) < 0)
         return -1;
+      dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */
     }
     rr->length = 0;
     s->packet_length = 0;
     goto again;
   }
 
-  if (!dtls1_process_record(s, bitmap)) {
+  if (!dtls1_process_record(s)) {
     rr->length = 0;
     s->packet_length = 0; /* dump this record */
     goto again;           /* get another record */
   }
+  dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */
 
   return (1);
 }
@@ -835,28 +738,22 @@
     if (!ssl3_setup_buffers(s))
       return (-1);
 
-  /* XXX: check what the second '&& type' is about */
   if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
-       (type != SSL3_RT_HANDSHAKE) && type) ||
+       (type != SSL3_RT_HANDSHAKE)) ||
       (peek && (type != SSL3_RT_APPLICATION_DATA))) {
     SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
     return -1;
   }
 
-  /*
-   * check whether there's a handshake message (client hello?) waiting
-   */
+  /* check whether there's a handshake message (client hello?) waiting */
   if ((ret = have_handshake_fragment(s, type, buf, len, peek)))
     return ret;
 
-    /*
-     * Now s->d1->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.
-     */
+    /* Now s->d1->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */
 
 #ifndef OPENSSL_NO_SCTP
-  /*
-   * Continue handshake if it had to be interrupted to read app data with
-   * SCTP.
+  /* Continue handshake if it had to be interrupted to read
+   * app data with SCTP.
    */
   if ((!s->in_handshake && SSL_in_init(s)) ||
       (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
@@ -881,16 +778,16 @@
   s->rwstate = SSL_NOTHING;
 
   /*-
-   * s->s3->rrec.type         - is the type of record
+   * s->s3->rrec.type	    - is the type of record
    * s->s3->rrec.data,    - data
    * s->s3->rrec.off,     - offset into 'data' for next read
    * s->s3->rrec.length,  - number of bytes.
    */
   rr = &(s->s3->rrec);
 
-  /*
-   * We are not handshaking and have no data yet, so process data buffered
-   * during the last handshake in advance, if any.
+  /* We are not handshaking and have no data yet,
+   * so process data buffered during the last handshake
+   * in advance, if any.
    */
   if (s->state == SSL_ST_OK && rr->length == 0) {
     pitem *item;
@@ -934,22 +831,15 @@
     goto start;
   }
 
-  /*
-   * Reset the count of consecutive warning alerts if we've got a non-empty
-   * record that isn't an alert.
-   */
-  if (rr->type != SSL3_RT_ALERT && rr->length != 0)
-    s->cert->alert_count = 0;
-
   /* we now have a packet which can be read and processed */
 
   if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
                                  * reset by ssl3_get_finished */
       && (rr->type != SSL3_RT_HANDSHAKE)) {
-    /*
-     * We now have application data between CCS and Finished. Most likely
-     * the packets were reordered on their way, so buffer the application
-     * data for later processing rather than dropping the connection.
+    /* We now have application data between CCS and Finished.
+     * Most likely the packets were reordered on their way, so
+     * buffer the application data for later processing rather
+     * than dropping the connection.
      */
     if (dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num) < 0) {
       SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
@@ -959,22 +849,18 @@
     goto start;
   }
 
-  /*
-   * If the other end has shut down, throw anything we read away (even in
-   * 'peek' mode)
-   */
+  /* If the other end has shut down, throw anything we read away
+   * (even in 'peek' mode) */
   if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {
     rr->length = 0;
     s->rwstate = SSL_NOTHING;
     return (0);
   }
 
-  if (type == rr->type) { /* SSL3_RT_APPLICATION_DATA or
-                           * SSL3_RT_HANDSHAKE */
-    /*
-     * make sure that we are not getting application data when we are
-     * doing a handshake for the first time
-     */
+  if (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */
+  {
+    /* make sure that we are not getting application data when we
+     * are doing a handshake for the first time */
     if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
         (s->enc_read_ctx == NULL)) {
       al = SSL_AD_UNEXPECTED_MESSAGE;
@@ -999,10 +885,10 @@
         rr->off = 0;
       }
     }
+
 #ifndef OPENSSL_NO_SCTP
-    /*
-     * We were about to renegotiate but had to read belated application
-     * data first, so retry.
+    /* We were about to renegotiate but had to read
+     * belated application data first, so retry.
      */
     if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
         rr->type == SSL3_RT_APPLICATION_DATA &&
@@ -1013,10 +899,9 @@
       BIO_set_retry_read(SSL_get_rbio(s));
     }
 
-    /*
-     * We might had to delay a close_notify alert because of reordered
-     * app data. If there was an alert and there is no message to read
-     * anymore, finally set shutdown.
+    /* We might had to delay a close_notify alert because
+     * of reordered app data. If there was an alert and there
+     * is no message to read anymore, finally set shutdown.
      */
     if (BIO_dgram_is_sctp(SSL_get_rbio(s)) && s->d1->shutdown_received &&
         !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
@@ -1027,14 +912,11 @@
     return (n);
   }
 
-  /*
-   * If we get here, then type != rr->type; if we have a handshake message,
-   * then it was unexpected (Hello Request or Client Hello).
-   */
+  /* If we get here, then type != rr->type; if we have a handshake
+   * message, then it was unexpected (Hello Request or Client Hello). */
 
-  /*
-   * In case of record types for which we have 'fragment' storage, fill
-   * that so that we can process the data at a fixed place.
+  /* In case of record types for which we have 'fragment' storage,
+   * fill that so that we can process the data at a fixed place.
    */
   {
     unsigned int k, dest_maxlen = 0;
@@ -1042,7 +924,7 @@
     unsigned int *dest_len = NULL;
 
     if (rr->type == SSL3_RT_HANDSHAKE) {
-      dest_maxlen = sizeof(s->d1->handshake_fragment);
+      dest_maxlen = sizeof s->d1->handshake_fragment;
       dest = s->d1->handshake_fragment;
       dest_len = &s->d1->handshake_fragment_len;
     } else if (rr->type == SSL3_RT_ALERT) {
@@ -1064,9 +946,8 @@
 #endif
     /* else it's a CCS message, or application data or wrong */
     else if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC) {
-      /*
-       * Application data while renegotiating is allowed. Try again
-       * reading.
+      /* Application data while renegotiating
+       * is allowed. Try again reading.
        */
       if (rr->type == SSL3_RT_APPLICATION_DATA) {
         BIO *bio;
@@ -1085,10 +966,8 @@
     }
 
     if (dest_maxlen > 0) {
-      /*
-       * XDTLS: In a pathalogical case, the Client Hello may be
-       * fragmented--don't always expect dest_maxlen bytes
-       */
+      /* XDTLS:  In a pathalogical case, the Client Hello
+       *  may be fragmented--don't always expect dest_maxlen bytes */
       if (rr->length < dest_maxlen) {
 #ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
         /*
@@ -1112,11 +991,9 @@
     }
   }
 
-  /*-
-   * s->d1->handshake_fragment_len == 12  iff  rr->type == SSL3_RT_HANDSHAKE;
+  /* s->d1->handshake_fragment_len == 12  iff  rr->type == SSL3_RT_HANDSHAKE;
    * s->d1->alert_fragment_len == 7      iff  rr->type == SSL3_RT_ALERT.
-   * (Possibly rr is 'empty' now, i.e. rr->length may be 0.)
-   */
+   * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */
 
   /* If we are a client, check for an incoming 'Hello Request': */
   if ((!s->server) &&
@@ -1130,12 +1007,10 @@
         (s->d1->handshake_fragment[3] != 0)) {
       al = SSL_AD_DECODE_ERROR;
       SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);
-      goto f_err;
+      goto err;
     }
 
-    /*
-     * no need to check sequence number on HELLO REQUEST messages
-     */
+    /* no need to check sequence number on HELLO REQUEST messages */
 
     if (s->msg_callback)
       s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
@@ -1157,14 +1032,13 @@
         }
 
         if (!(s->mode & SSL_MODE_AUTO_RETRY)) {
-          if (s->s3->rbuf.left == 0) { /* no read-ahead left? */
+          if (s->s3->rbuf.left == 0) /* no read-ahead left? */
+          {
             BIO *bio;
-            /*
-             * In the case where we try to read application data,
+            /* In the case where we try to read application data,
              * but we trigger an SSL handshake, we return -1 with
              * the retry option set.  Otherwise renegotiation may
-             * cause nasty problems in the blocking world
-             */
+             * cause nasty problems in the blocking world */
             s->rwstate = SSL_READING;
             bio = SSL_get_rbio(s);
             BIO_clear_retry_flags(bio);
@@ -1174,25 +1048,8 @@
         }
       }
     }
-    /*
-     * we either finished a handshake or ignored the request, now try
-     * again to obtain the (application) data we were asked for
-     */
-    goto start;
-  }
-
-  /*
-   * If we are a server and get a client hello when renegotiation isn't
-   * allowed send back a no renegotiation alert and carry on.
-   */
-  if (s->server && SSL_is_init_finished(s) && !s->s3->send_connection_binding &&
-      s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH &&
-      s->d1->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO &&
-      s->s3->previous_client_finished_len != 0 &&
-      (s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) == 0) {
-    s->d1->handshake_fragment_len = 0;
-    rr->length = 0;
-    ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
+    /* we either finished a handshake or ignored the request,
+     * now try again to obtain the (application) data we were asked for */
     goto start;
   }
 
@@ -1216,22 +1073,14 @@
       cb(s, SSL_CB_READ_ALERT, j);
     }
 
-    if (alert_level == SSL3_AL_WARNING) {
+    if (alert_level == 1) /* warning */
+    {
       s->s3->warn_alert = alert_descr;
-
-      s->cert->alert_count++;
-      if (s->cert->alert_count == MAX_WARN_ALERT_COUNT) {
-        al = SSL_AD_UNEXPECTED_MESSAGE;
-        SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);
-        goto f_err;
-      }
-
       if (alert_descr == SSL_AD_CLOSE_NOTIFY) {
 #ifndef OPENSSL_NO_SCTP
-        /*
-         * With SCTP and streams the socket may deliver app data
-         * after a close_notify alert. We have to check this first so
-         * that nothing gets discarded.
+        /* With SCTP and streams the socket may deliver app data
+         * after a close_notify alert. We have to check this
+         * first so that nothing gets discarded.
          */
         if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
             BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
@@ -1247,43 +1096,40 @@
       }
 #if 0
             /* XXX: this is a possible improvement in the future */
-            /* now check if it's a missing record */
-            if (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
-                unsigned short seq;
-                unsigned int frag_off;
-                unsigned char *p = &(s->d1->alert_fragment[2]);
-
-                n2s(p, seq);
-                n2l3(p, frag_off);
-
-                dtls1_retransmit_message(s,
-                                         dtls1_get_queue_priority
-                                         (frag->msg_header.seq, 0), frag_off,
-                                         &found);
-                if (!found && SSL_in_init(s)) {
-                    /*
-                     * fprintf( stderr,"in init = %d\n", SSL_in_init(s));
-                     */
-                    /*
-                     * requested a message not yet sent, send an alert
-                     * ourselves
-                     */
-                    ssl3_send_alert(s, SSL3_AL_WARNING,
-                                    DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
-                }
-            }
+			/* now check if it's a missing record */
+			if (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)
+				{
+				unsigned short seq;
+				unsigned int frag_off;
+				unsigned char *p = &(s->d1->alert_fragment[2]);
+
+				n2s(p, seq);
+				n2l3(p, frag_off);
+
+				dtls1_retransmit_message(s,
+										 dtls1_get_queue_priority(frag->msg_header.seq, 0),
+										 frag_off, &found);
+				if ( ! found  && SSL_in_init(s))
+					{
+					/* fprintf( stderr,"in init = %d\n", SSL_in_init(s)); */
+					/* requested a message not yet sent, 
+					   send an alert ourselves */
+					ssl3_send_alert(s,SSL3_AL_WARNING,
+						DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
+					}
+				}
 #endif
-    } else if (alert_level == SSL3_AL_FATAL) {
+    } else if (alert_level == 2) /* fatal */
+    {
       char tmp[16];
 
       s->rwstate = SSL_NOTHING;
       s->s3->fatal_alert = alert_descr;
       SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);
-      BIO_snprintf(tmp, sizeof(tmp), "%d", alert_descr);
+      BIO_snprintf(tmp, sizeof tmp, "%d", alert_descr);
       ERR_add_error_data(2, "SSL alert number ", tmp);
       s->shutdown |= SSL_RECEIVED_SHUTDOWN;
-      SSL_CTX_remove_session(s->session_ctx, s->session);
-      s->state = SSL_ST_ERR;
+      SSL_CTX_remove_session(s->ctx, s->session);
       return (0);
     } else {
       al = SSL_AD_ILLEGAL_PARAMETER;
@@ -1294,8 +1140,8 @@
     goto start;
   }
 
-  if (s->shutdown & SSL_SENT_SHUTDOWN) { /* but we have not received a
-                                          * shutdown */
+  if (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */
+  {
     s->rwstate = SSL_NOTHING;
     rr->length = 0;
     return (0);
@@ -1310,16 +1156,14 @@
     if (s->version == DTLS1_BAD_VER)
       ccs_hdr_len = 3;
 
-    /*
-     * 'Change Cipher Spec' is just a single byte, so we know exactly
-     * what the record payload has to look like
-     */
+    /* 'Change Cipher Spec' is just a single byte, so we know
+     * exactly what the record payload has to look like */
     /* XDTLS: check that epoch is consistent */
     if ((rr->length != ccs_hdr_len) || (rr->off != 0) ||
         (rr->data[0] != SSL3_MT_CCS)) {
-      al = SSL_AD_ILLEGAL_PARAMETER;
+      i = SSL_AD_ILLEGAL_PARAMETER;
       SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_BAD_CHANGE_CIPHER_SPEC);
-      goto f_err;
+      goto err;
     }
 
     rr->length = 0;
@@ -1328,9 +1172,8 @@
       s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s,
                       s->msg_callback_arg);
 
-    /*
-     * We can't process a CCS now, because previous handshake messages
-     * are still missing, so just drop it.
+    /* We can't process a CCS now, because previous handshake
+     * messages are still missing, so just drop it.
      */
     if (!s->d1->change_cipher_spec_ok) {
       goto start;
@@ -1349,10 +1192,10 @@
       s->d1->handshake_read_seq++;
 
 #ifndef OPENSSL_NO_SCTP
-    /*
-     * Remember that a CCS has been received, so that an old key of
-     * SCTP-Auth can be deleted when a CCS is sent. Will be ignored if no
-     * SCTP is used
+    /* Remember that a CCS has been received,
+     * so that an old key of SCTP-Auth can be
+     * deleted when a CCS is sent. Will be ignored
+     * if no SCTP is used
      */
     BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);
 #endif
@@ -1360,9 +1203,7 @@
     goto start;
   }
 
-  /*
-   * Unexpected handshake message (Client Hello, or protocol violation)
-   */
+  /* Unexpected handshake message (Client Hello, or protocol violation) */
   if ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&
       !s->in_handshake) {
     struct hm_header_st msg_hdr;
@@ -1374,9 +1215,8 @@
       goto start;
     }
 
-    /*
-     * If we are server, we may have a repeated FINISHED of the client
-     * here, then retransmit our CCS and FINISHED.
+    /* If we are server, we may have a repeated FINISHED of the
+     * client here, then retransmit our CCS and FINISHED.
      */
     if (msg_hdr.type == SSL3_MT_FINISHED) {
       if (dtls1_check_timeout_num(s) < 0)
@@ -1389,12 +1229,12 @@
 
     if (((s->state & SSL_ST_MASK) == SSL_ST_OK) &&
         !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {
-#if 0 /* worked only because C operator preferences                            \
-       * are not as expected (and because this is                              \
-       * not really needed for clients except for                              \
-       * detecting protocol violations): */
-            s->state = SSL_ST_BEFORE | (s->server)
-                ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
+#if 0 /* worked only because C operator preferences are not as expected (and   \
+       * because this is not really needed for clients except for detecting    \
+       * protocol violations): */
+			s->state=SSL_ST_BEFORE|(s->server)
+				?SSL_ST_ACCEPT
+				:SSL_ST_CONNECT;
 #else
       s->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
 #endif
@@ -1410,14 +1250,13 @@
     }
 
     if (!(s->mode & SSL_MODE_AUTO_RETRY)) {
-      if (s->s3->rbuf.left == 0) { /* no read-ahead left? */
+      if (s->s3->rbuf.left == 0) /* no read-ahead left? */
+      {
         BIO *bio;
-        /*
-         * In the case where we try to read application data, but we
-         * trigger an SSL handshake, we return -1 with the retry
-         * option set.  Otherwise renegotiation may cause nasty
-         * problems in the blocking world
-         */
+        /* In the case where we try to read application data,
+         * but we trigger an SSL handshake, we return -1 with
+         * the retry option set.  Otherwise renegotiation may
+         * cause nasty problems in the blocking world */
         s->rwstate = SSL_READING;
         bio = SSL_get_rbio(s);
         BIO_clear_retry_flags(bio);
@@ -1443,21 +1282,19 @@
   case SSL3_RT_CHANGE_CIPHER_SPEC:
   case SSL3_RT_ALERT:
   case SSL3_RT_HANDSHAKE:
-    /*
-     * we already handled all of these, with the possible exception of
-     * SSL3_RT_HANDSHAKE when s->in_handshake is set, but that should not
-     * happen when type != rr->type
-     */
+    /* we already handled all of these, with the possible exception
+     * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that
+     * should not happen when type != rr->type */
     al = SSL_AD_UNEXPECTED_MESSAGE;
     SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
     goto f_err;
   case SSL3_RT_APPLICATION_DATA:
-    /*
-     * At this point, we were expecting handshake data, but have
-     * application data.  If the library was running inside ssl3_read()
-     * (i.e. in_read_app_data is set) and it makes sense to read
-     * application data at this point (session renegotiation not yet
-     * started), we will indulge it.
+    /* At this point, we were expecting handshake data,
+     * but have application data.  If the library was
+     * running inside ssl3_read() (i.e. in_read_app_data
+     * is set) and it makes sense to read application data
+     * at this point (session renegotiation not yet started),
+     * we will indulge it.
      */
     if (s->s3->in_read_app_data && (s->s3->total_renegotiations != 0) &&
         (((s->state & SSL_ST_CONNECT) &&
@@ -1485,9 +1322,8 @@
   int i;
 
 #ifndef OPENSSL_NO_SCTP
-  /*
-   * Check if we have to continue an interrupted handshake for reading
-   * belated app data with SCTP.
+  /* Check if we have to continue an interrupted handshake
+   * for reading belated app data with SCTP.
    */
   if ((SSL_in_init(s) && !s->in_handshake) ||
       (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
@@ -1515,10 +1351,8 @@
   return i;
 }
 
-/*
- * this only happens when a client hello is received and a handshake
- * is started.
- */
+/* this only happens when a client hello is received and a handshake
+ * is started. */
 static int have_handshake_fragment(SSL *s, int type, unsigned char *buf,
                                    int len, int peek) {
 
@@ -1546,9 +1380,8 @@
   return 0;
 }
 
-/*
- * Call this to write data in records of type 'type' It will return <= 0 if
- * not all data has been sent or non-blocking IO.
+/* Call this to write data in records of type 'type'
+ * It will return <= 0 if not all data has been sent or non-blocking IO.
  */
 int dtls1_write_bytes(SSL *s, int type, const void *buf, int len) {
   int i;
@@ -1569,12 +1402,10 @@
   SSL3_BUFFER *wb;
   SSL_SESSION *sess;
 
-  /*
-   * first check if there is a SSL3_BUFFER still being written out.  This
-   * will happen with non blocking IO
-   */
+  /* first check if there is a SSL3_BUFFER still being written
+   * out.  This will happen with non blocking IO */
   if (s->s3->wbuf.left != 0) {
-    OPENSSL_assert(0); /* XDTLS: want to see if we ever get here */
+    OPENSSL_assert(0); /* XDTLS:  want to see if we ever get here */
     return (ssl3_write_pending(s, type, buf, len));
   }
 
@@ -1607,38 +1438,34 @@
 
   /* DTLS implements explicit IV, so no need for empty fragments */
 #if 0
-    /*
-     * 'create_empty_fragment' is true only when this function calls itself
-     */
-    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done
-        && SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
-    {
-        /*
-         * countermeasure against known-IV weakness in CBC ciphersuites (see
-         * http://www.openssl.org/~bodo/tls-cbc.txt)
-         */
-
-        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {
-            /*
-             * recursive function call with 'create_empty_fragment' set; this
-             * prepares and buffers the data for an empty fragment (these
-             * 'prefix_len' bytes are sent out later together with the actual
-             * payload)
-             */
-            prefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);
-            if (prefix_len <= 0)
-                goto err;
-
-            if (s->s3->wbuf.len <
-                (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE) {
-                /* insufficient space */
-                SSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);
-                goto err;
-            }
-        }
-
-        s->s3->empty_fragment_done = 1;
-    }
+	/* 'create_empty_fragment' is true only when this function calls itself */
+	if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done
+	    && SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)
+		{
+		/* countermeasure against known-IV weakness in CBC ciphersuites
+		 * (see http://www.openssl.org/~bodo/tls-cbc.txt) 
+		 */
+
+		if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)
+			{
+			/* recursive function call with 'create_empty_fragment' set;
+			 * this prepares and buffers the data for an empty fragment
+			 * (these 'prefix_len' bytes are sent out later
+			 * together with the actual payload) */
+			prefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);
+			if (prefix_len <= 0)
+				goto err;
+
+			if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)
+				{
+				/* insufficient space */
+				SSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);
+				goto err;
+				}
+			}
+		
+		s->s3->empty_fragment_done = 1;
+		}
 #endif
   p = wb->buf + prefix_len;
 
@@ -1646,10 +1473,9 @@
 
   *(p++) = type & 0xff;
   wr->type = type;
-  /*
-   * Special case: for hello verify request, client version 1.0 and we
-   * haven't decided which version to use yet send back using version 1.0
-   * header: otherwise some clients will ignore it.
+  /* Special case: for hello verify request, client version 1.0 and
+   * we haven't decided which version to use yet send back using
+   * version 1.0 header: otherwise some clients will ignore it.
    */
   if (s->method->version == DTLS_ANY_VERSION) {
     *(p++) = DTLS1_VERSION >> 8;
@@ -1684,9 +1510,8 @@
   wr->length = (int)len;
   wr->input = (unsigned char *)buf;
 
-  /*
-   * we now 'read' from wr->input, wr->length bytes into wr->data
-   */
+  /* we now 'read' from wr->input, wr->length bytes into
+   * wr->data */
 
   /* first we compress */
   if (s->compress != NULL) {
@@ -1699,11 +1524,9 @@
     wr->input = wr->data;
   }
 
-  /*
-   * we should still have the output to wr->data and the input from
-   * wr->input.  Length should be wr->length. wr->data still points in the
-   * wb->buf
-   */
+  /* we should still have the output to wr->data and the input
+   * from wr->input.  Length should be wr->length.
+   * wr->data still points in the wb->buf */
 
   if (mac_size != 0) {
     if (s->method->ssl3_enc->mac(s, &(p[wr->length + eivlen]), 1) < 0)
@@ -1722,19 +1545,16 @@
     goto err;
 
   /* record length after mac and block padding */
-  /*
-   * if (type == SSL3_RT_APPLICATION_DATA || (type == SSL3_RT_ALERT && !
-   * SSL_in_init(s)))
-   */
+  /*	if (type == SSL3_RT_APPLICATION_DATA ||
+          (type == SSL3_RT_ALERT && ! SSL_in_init(s))) */
 
   /* there's only one epoch between handshake and app data */
 
   s2n(s->d1->w_epoch, pseq);
 
   /* XDTLS: ?? */
-  /*
-   * else s2n(s->d1->handshake_epoch, pseq);
-   */
+  /*	else
+          s2n(s->d1->handshake_epoch, pseq); */
 
   memcpy(pseq, &(s->s3->write_sequence[2]), 6);
   pseq += 6;
@@ -1744,26 +1564,24 @@
     s->msg_callback(1, 0, SSL3_RT_HEADER, pseq - DTLS1_RT_HEADER_LENGTH,
                     DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);
 
-  /*
-   * we should now have wr->data pointing to the encrypted data, which is
-   * wr->length long
-   */
+  /* we should now have
+   * wr->data pointing to the encrypted data, which is
+   * wr->length long */
   wr->type = type; /* not needed but helps for debugging */
   wr->length += DTLS1_RT_HEADER_LENGTH;
 
 #if 0 /* this is now done at the message layer */
-    /* buffer the record, making it easy to handle retransmits */
-    if (type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)
-        dtls1_buffer_record(s, wr->data, wr->length,
-                            *((PQ_64BIT *) & (s->s3->write_sequence[0])));
+	/* buffer the record, making it easy to handle retransmits */
+	if ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)
+		dtls1_buffer_record(s, wr->data, wr->length, 
+			*((PQ_64BIT *)&(s->s3->write_sequence[0])));
 #endif
 
   ssl3_record_sequence_update(&(s->s3->write_sequence[0]));
 
   if (create_empty_fragment) {
-    /*
-     * we are in a recursive call; just return the length, don't write
-     * out anything here
+    /* we are in a recursive call;
+     * just return the length, don't write out anything here
      */
     return wr->length;
   }
@@ -1772,10 +1590,8 @@
   wb->left = prefix_len + wr->length;
   wb->offset = 0;
 
-  /*
-   * memorize arguments so that ssl3_write_pending can detect bad write
-   * retries later
-   */
+  /* memorize arguments so that ssl3_write_pending can detect bad write retries
+   * later */
   s->s3->wpend_tot = len;
   s->s3->wpend_buf = buf;
   s->s3->wpend_type = type;
@@ -1843,18 +1659,14 @@
   if (s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
     s2n(s->d1->handshake_read_seq, ptr);
 #if 0
-        if (s->d1->r_msg_hdr.frag_off == 0)
-            /*
-             * waiting for a new msg
-             */
-            else
-            s2n(s->d1->r_msg_hdr.seq, ptr); /* partial msg read */
+		if ( s->d1->r_msg_hdr.frag_off == 0)  /* waiting for a new msg */
+
+		else
+			s2n(s->d1->r_msg_hdr.seq, ptr); /* partial msg read */
 #endif
 
 #if 0
-        fprintf(stderr,
-                "s->d1->handshake_read_seq = %d, s->d1->r_msg_hdr.seq = %d\n",
-                s->d1->handshake_read_seq, s->d1->r_msg_hdr.seq);
+		fprintf(stderr, "s->d1->handshake_read_seq = %d, s->d1->r_msg_hdr.seq = %d\n",s->d1->handshake_read_seq,s->d1->r_msg_hdr.seq);
 #endif
     l2n3(s->d1->r_msg_hdr.frag_off, ptr);
   }
@@ -1898,13 +1710,8 @@
   if (rr->epoch == s->d1->r_epoch)
     return &s->d1->bitmap;
 
-  /*
-   * Only HM and ALERT messages can be from the next epoch and only if we
-   * have already processed all of the unprocessed records from the last
-   * epoch
-   */
+  /* Only HM and ALERT messages can be from the next epoch */
   else if (rr->epoch == (unsigned long)(s->d1->r_epoch + 1) &&
-           s->d1->unprocessed_rcds.epoch != s->d1->r_epoch &&
            (rr->type == SSL3_RT_HANDSHAKE || rr->type == SSL3_RT_ALERT)) {
     *is_next_epoch = 1;
     return &s->d1->next_bitmap;
@@ -1915,62 +1722,67 @@
 
 #if 0
 static int
-dtls1_record_needs_buffering(SSL *s, SSL3_RECORD *rr,
-                             unsigned short *priority, unsigned long *offset)
-{
-
-    /* alerts are passed up immediately */
-    if (rr->type == SSL3_RT_APPLICATION_DATA || rr->type == SSL3_RT_ALERT)
-        return 0;
-
-    /*
-     * Only need to buffer if a handshake is underway. (this implies that
-     * Hello Request and Client Hello are passed up immediately)
-     */
-    if (SSL_in_init(s)) {
-        unsigned char *data = rr->data;
-        /* need to extract the HM/CCS sequence number here */
-        if (rr->type == SSL3_RT_HANDSHAKE ||
-            rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {
-            unsigned short seq_num;
-            struct hm_header_st msg_hdr;
-            struct ccs_header_st ccs_hdr;
-
-            if (rr->type == SSL3_RT_HANDSHAKE) {
-                dtls1_get_message_header(data, &msg_hdr);
-                seq_num = msg_hdr.seq;
-                *offset = msg_hdr.frag_off;
-            } else {
-                dtls1_get_ccs_header(data, &ccs_hdr);
-                seq_num = ccs_hdr.seq;
-                *offset = 0;
-            }
-
-            /*
-             * this is either a record we're waiting for, or a retransmit of
-             * something we happened to previously receive (higher layers
-             * will drop the repeat silently
-             */
-            if (seq_num < s->d1->handshake_read_seq)
-                return 0;
-            if (rr->type == SSL3_RT_HANDSHAKE &&
-                seq_num == s->d1->handshake_read_seq &&
-                msg_hdr.frag_off < s->d1->r_msg_hdr.frag_off)
-                return 0;
-            else if (seq_num == s->d1->handshake_read_seq &&
-                     (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC ||
-                      msg_hdr.frag_off == s->d1->r_msg_hdr.frag_off))
-                return 0;
-            else {
-                *priority = seq_num;
-                return 1;
-            }
-        } else                  /* unknown record type */
-            return 0;
-    }
+dtls1_record_needs_buffering(SSL *s, SSL3_RECORD *rr, unsigned short *priority,
+	unsigned long *offset)
+	{
+
+	/* alerts are passed up immediately */
+	if ( rr->type == SSL3_RT_APPLICATION_DATA ||
+		rr->type == SSL3_RT_ALERT)
+		return 0;
+
+	/* Only need to buffer if a handshake is underway.
+	 * (this implies that Hello Request and Client Hello are passed up
+	 * immediately) */
+	if ( SSL_in_init(s))
+		{
+		unsigned char *data = rr->data;
+		/* need to extract the HM/CCS sequence number here */
+		if ( rr->type == SSL3_RT_HANDSHAKE ||
+			rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
+			{
+			unsigned short seq_num;
+			struct hm_header_st msg_hdr;
+			struct ccs_header_st ccs_hdr;
+
+			if ( rr->type == SSL3_RT_HANDSHAKE)
+				{
+				dtls1_get_message_header(data, &msg_hdr);
+				seq_num = msg_hdr.seq;
+				*offset = msg_hdr.frag_off;
+				}
+			else
+				{
+				dtls1_get_ccs_header(data, &ccs_hdr);
+				seq_num = ccs_hdr.seq;
+				*offset = 0;
+				}
+				
+			/* this is either a record we're waiting for, or a
+			 * retransmit of something we happened to previously 
+			 * receive (higher layers will drop the repeat silently */
+			if ( seq_num < s->d1->handshake_read_seq)
+				return 0;
+			if (rr->type == SSL3_RT_HANDSHAKE && 
+				seq_num == s->d1->handshake_read_seq &&
+				msg_hdr.frag_off < s->d1->r_msg_hdr.frag_off)
+				return 0;
+			else if ( seq_num == s->d1->handshake_read_seq &&
+				(rr->type == SSL3_RT_CHANGE_CIPHER_SPEC ||
+					msg_hdr.frag_off == s->d1->r_msg_hdr.frag_off))
+				return 0;
+			else
+				{
+				*priority = seq_num;
+				return 1;
+				}
+			}
+		else /* unknown record type */
+			return 0;
+		}
 
-    return 0;
-}
+	return 0;
+	}
 #endif
 
 void dtls1_reset_seq_numbers(SSL *s, int rw) {
@@ -1982,12 +1794,6 @@
     s->d1->r_epoch++;
     memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));
     memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));
-
-    /*
-     * We must not use any buffered messages received from the previous
-     * epoch
-     */
-    dtls1_clear_received_buffer(s);
   } else {
     seq = s->s3->write_sequence;
     memcpy(s->d1->last_write_sequence, seq, sizeof(s->s3->write_sequence));
