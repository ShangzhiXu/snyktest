--- /home/V1SCAN/CWE-119/FormattedUsed/parserInternals-turicreate-6.4.1.c	2023-12-10 02:45:01.210163985 +0900
+++ /home/V1SCAN/CWE-119/FormattedPatch/NEW##CVE-2015-7498##0##GNOME@@libxml2##parserInternals.c	2023-12-10 02:45:01.520179670 +0900
@@ -926,6 +926,7 @@
 int xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc) {
   xmlCharEncodingHandlerPtr handler;
   int len = -1;
+  int ret;
 
   if (ctxt == NULL)
     return (-1);
@@ -1079,7 +1080,15 @@
   if (handler == NULL)
     return (-1);
   ctxt->charset = XML_CHAR_ENCODING_UTF8;
-  return (xmlSwitchToEncodingInt(ctxt, handler, len));
+  ret = xmlSwitchToEncodingInt(ctxt, handler, len);
+  if ((ret < 0) || (ctxt->errNo == XML_I18N_CONV_FAILED)) {
+    /*
+     * on encoding conversion errors, stop the parser
+     */
+    xmlStopParser(ctxt);
+    ctxt->errNo = XML_I18N_CONV_FAILED;
+  }
+  return (ret);
 }
 
 /**
@@ -1661,12 +1670,20 @@
   ctxt->nsWellFormed = 1;
   ctxt->valid = 1;
   ctxt->loadsubset = xmlLoadExtDtdDefaultValue;
+  if (ctxt->loadsubset) {
+    ctxt->options |= XML_PARSE_DTDLOAD;
+  }
   ctxt->validate = xmlDoValidityCheckingDefaultValue;
   ctxt->pedantic = xmlPedanticParserDefaultValue;
+  if (ctxt->pedantic) {
+    ctxt->options |= XML_PARSE_PEDANTIC;
+  }
   ctxt->linenumbers = xmlLineNumbersDefaultValue;
   ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
-  if (ctxt->keepBlanks == 0)
+  if (ctxt->keepBlanks == 0) {
     ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
+    ctxt->options |= XML_PARSE_NOBLANKS;
+  }
 
   ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;
   ctxt->vctxt.userData = ctxt;
@@ -1678,8 +1695,12 @@
     else
       ctxt->vctxt.warning = xmlParserValidityWarning;
     ctxt->vctxt.nodeMax = 0;
+    ctxt->options |= XML_PARSE_DTDVALID;
   }
   ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;
+  if (ctxt->replaceEntities) {
+    ctxt->options |= XML_PARSE_NOENT;
+  }
   ctxt->record_info = 0;
   ctxt->nbChars = 0;
   ctxt->checkIndex = 0;
@@ -1957,7 +1978,8 @@
 
   /* Otherwise, we need to add new node to buffer */
   else {
-    if (ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) {
+    if ((ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) ||
+        (ctxt->node_seq.buffer == NULL)) {
       xmlParserNodeInfo *tmp_buffer;
       unsigned int byte_size;
 
