--- /home/V1SCAN/CWE-611/FormattedUsed/xmlparse-freebsd-src.c	2023-12-12 05:05:57.582677988 +0900
+++ /home/V1SCAN/CWE-611/FormattedVul/OLD##CVE-2018-20843##0##libexpat@@libexpat##xmlparse.c	2023-12-12 05:05:58.492676176 +0900
@@ -1,4 +1,4 @@
-/* 5ab094ffadd6edfc94c3eee53af44a86951f9f1f0933ada3114bbce2bfb02c99 (2.5.0+)
+/* 19ac4776051591216f1874e34ee99b6a43a3784c8bd7d70efeb9258dd22b906a (2.2.6+)
                             __  __            _
                          ___\ \/ /_ __   __ _| |_
                         / _ \\  /| '_ \ / _` | __|
@@ -7,35 +7,7 @@
                                  |_| XML parser
 
    Copyright (c) 1997-2000 Thai Open Source Software Center Ltd
-   Copyright (c) 2000      Clark Cooper <coopercc@users.sourceforge.net>
-   Copyright (c) 2000-2006 Fred L. Drake, Jr. <fdrake@users.sourceforge.net>
-   Copyright (c) 2001-2002 Greg Stein <gstein@users.sourceforge.net>
-   Copyright (c) 2002-2016 Karl Waclawek <karl@waclawek.net>
-   Copyright (c) 2005-2009 Steven Solie <steven@solie.ca>
-   Copyright (c) 2016      Eric Rahm <erahm@mozilla.com>
-   Copyright (c) 2016-2022 Sebastian Pipping <sebastian@pipping.org>
-   Copyright (c) 2016      Gaurav <g.gupta@samsung.com>
-   Copyright (c) 2016      Thomas Beutlich <tc@tbeu.de>
-   Copyright (c) 2016      Gustavo Grieco <gustavo.grieco@imag.fr>
-   Copyright (c) 2016      Pascal Cuoq <cuoq@trust-in-soft.com>
-   Copyright (c) 2016      Ed Schouten <ed@nuxi.nl>
-   Copyright (c) 2017-2022 Rhodri James <rhodri@wildebeest.org.uk>
-   Copyright (c) 2017      Václav Slavík <vaclav@slavik.io>
-   Copyright (c) 2017      Viktor Szakats <commit@vsz.me>
-   Copyright (c) 2017      Chanho Park <chanho61.park@samsung.com>
-   Copyright (c) 2017      Rolf Eike Beer <eike@sf-mail.de>
-   Copyright (c) 2017      Hans Wennborg <hans@chromium.org>
-   Copyright (c) 2018      Anton Maklakov <antmak.pub@gmail.com>
-   Copyright (c) 2018      Benjamin Peterson <benjamin@python.org>
-   Copyright (c) 2018      Marco Maggi <marco.maggi-ipsu@poste.it>
-   Copyright (c) 2018      Mariusz Zaborski <oshogbo@vexillium.org>
-   Copyright (c) 2019      David Loffredo <loffredo@steptools.com>
-   Copyright (c) 2019-2020 Ben Wagner <bungeman@chromium.org>
-   Copyright (c) 2019      Vadim Zeitlin <vadim@zeitlins.org>
-   Copyright (c) 2021      Dong-hee Na <donghee.na@python.org>
-   Copyright (c) 2022      Samanta Navarro <ferivoz@riseup.net>
-   Copyright (c) 2022      Jeffrey Walton <noloader@gmail.com>
-   Copyright (c) 2022      Jann Horn <jannh@google.com>
+   Copyright (c) 2000-2017 Expat development team
    Licensed under the MIT license:
 
    Permission is  hereby granted,  free of charge,  to any  person obtaining
@@ -58,28 +30,15 @@
    USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 
-#define XML_BUILDING_EXPAT 1
-
-#include <expat_config.h>
-
 #if !defined(_GNU_SOURCE)
 #define _GNU_SOURCE 1 /* syscall prototype */
 #endif
 
-#ifdef _WIN32
-/* force stdlib to define rand_s() */
-#if !defined(_CRT_RAND_S)
-#define _CRT_RAND_S
-#endif
-#endif
-
 #include <assert.h>
 #include <limits.h> /* UINT_MAX */
-#include <math.h>   /* isnan */
 #include <stddef.h>
-#include <stdint.h> /* uintptr_t */
 #include <stdio.h>  /* fprintf */
-#include <stdlib.h> /* getenv, rand_s */
+#include <stdlib.h> /* getenv */
 #include <string.h> /* memset(), memcpy() */
 
 #ifdef _WIN32
@@ -92,9 +51,13 @@
 #include <unistd.h>    /* getpid() */
 #endif
 
+#define XML_BUILDING_EXPAT 1
+
 #ifdef _WIN32
 #include "winconfig.h"
-#endif
+#elif defined(HAVE_EXPAT_CONFIG_H)
+#include <expat_config.h>
+#endif /* ndef _WIN32 */
 
 #include "ascii.h"
 #include "expat.h"
@@ -129,14 +92,14 @@
     enabled.  For end user security, that is probably not what you want. \
     \
     Your options include: \
-      * Linux >=3.17 + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \
-      * Linux >=3.17 + glibc (including <2.25) (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \
+      * Linux + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \
+      * Linux + glibc <2.25 (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \
       * BSD / macOS >=10.7 (arc4random_buf): HAVE_ARC4RANDOM_BUF, \
-      * BSD / macOS (including <10.7) (arc4random): HAVE_ARC4RANDOM, \
+      * BSD / macOS <10.7 (arc4random): HAVE_ARC4RANDOM, \
       * libbsd (arc4random_buf): HAVE_ARC4RANDOM_BUF + HAVE_LIBBSD, \
       * libbsd (arc4random): HAVE_ARC4RANDOM + HAVE_LIBBSD, \
-      * Linux (including <3.17) / BSD / macOS (including <10.7) / Solaris >=8 (/dev/urandom): XML_DEV_URANDOM, \
-      * Windows >=Vista (rand_s): _WIN32. \
+      * Linux / BSD / macOS (/dev/urandom): XML_DEV_URANDOM \
+      * Windows (RtlGenRandom): _WIN32. \
     \
     If insist on not using any of these, bypass this error by defining \
     XML_POOR_ENTROPY; you have been warned. \
@@ -151,7 +114,9 @@
 #define XmlGetInternalEncoding XmlGetUtf16InternalEncoding
 #define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS
 #define XmlEncode XmlUtf16Encode
-#define MUST_CONVERT(enc, s) (!(enc)->isUtf16 || (((uintptr_t)(s)) & 1))
+/* Using pointer subtraction to convert to integer type. */
+#define MUST_CONVERT(enc, s)                                                   \
+  (!(enc)->isUtf16 || (((char *)(s) - (char *)NULL) & 1))
 typedef unsigned short ICHAR;
 #else
 #define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX
@@ -401,31 +366,6 @@
   XML_Bool betweenDecl; /* WFC: PE Between Declarations */
 } OPEN_INTERNAL_ENTITY;
 
-enum XML_Account {
-  XML_ACCOUNT_DIRECT,           /* bytes directly passed to the Expat parser */
-  XML_ACCOUNT_ENTITY_EXPANSION, /* intermediate bytes produced during entity
-                                   expansion */
-  XML_ACCOUNT_NONE              /* i.e. do not account, was accounted already */
-};
-
-#ifdef XML_DTD
-typedef unsigned long long XmlBigCount;
-typedef struct accounting {
-  XmlBigCount countBytesDirect;
-  XmlBigCount countBytesIndirect;
-  int debugLevel;
-  float maximumAmplificationFactor; // >=1.0
-  unsigned long long activationThresholdBytes;
-} ACCOUNTING;
-
-typedef struct entity_stats {
-  unsigned int countEverOpened;
-  unsigned int currentDepth;
-  unsigned int maximumDepthSeen;
-  int debugLevel;
-} ENTITY_STATS;
-#endif /* XML_DTD */
-
 typedef enum XML_Error PTRCALL Processor(XML_Parser parser, const char *start,
                                          const char *end, const char **endPtr);
 
@@ -456,18 +396,16 @@
 static enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,
                                const char *s, const char *end, int tok,
                                const char *next, const char **nextPtr,
-                               XML_Bool haveMore, XML_Bool allowClosingDoctype,
-                               enum XML_Account account);
+                               XML_Bool haveMore);
 static enum XML_Error processInternalEntity(XML_Parser parser, ENTITY *entity,
                                             XML_Bool betweenDecl);
 static enum XML_Error doContent(XML_Parser parser, int startTagLevel,
                                 const ENCODING *enc, const char *start,
                                 const char *end, const char **endPtr,
-                                XML_Bool haveMore, enum XML_Account account);
+                                XML_Bool haveMore);
 static enum XML_Error doCdataSection(XML_Parser parser, const ENCODING *,
                                      const char **startPtr, const char *end,
-                                     const char **nextPtr, XML_Bool haveMore,
-                                     enum XML_Account account);
+                                     const char **nextPtr, XML_Bool haveMore);
 #ifdef XML_DTD
 static enum XML_Error doIgnoreSection(XML_Parser parser, const ENCODING *,
                                       const char **startPtr, const char *end,
@@ -477,8 +415,7 @@
 static void freeBindings(XML_Parser parser, BINDING *bindings);
 static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *,
                                 const char *s, TAG_NAME *tagNamePtr,
-                                BINDING **bindingsPtr,
-                                enum XML_Account account);
+                                BINDING **bindingsPtr);
 static enum XML_Error addBinding(XML_Parser parser, PREFIX *prefix,
                                  const ATTRIBUTE_ID *attId, const XML_Char *uri,
                                  BINDING **bindingsPtr);
@@ -487,18 +424,15 @@
                            XML_Parser parser);
 static enum XML_Error storeAttributeValue(XML_Parser parser, const ENCODING *,
                                           XML_Bool isCdata, const char *,
-                                          const char *, STRING_POOL *,
-                                          enum XML_Account account);
+                                          const char *, STRING_POOL *);
 static enum XML_Error appendAttributeValue(XML_Parser parser, const ENCODING *,
                                            XML_Bool isCdata, const char *,
-                                           const char *, STRING_POOL *,
-                                           enum XML_Account account);
+                                           const char *, STRING_POOL *);
 static ATTRIBUTE_ID *getAttributeId(XML_Parser parser, const ENCODING *enc,
                                     const char *start, const char *end);
 static int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
 static enum XML_Error storeEntityValue(XML_Parser parser, const ENCODING *enc,
-                                       const char *start, const char *end,
-                                       enum XML_Account account);
+                                       const char *start, const char *end);
 static int reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
                                        const char *start, const char *end);
 static int reportComment(XML_Parser parser, const ENCODING *enc,
@@ -562,34 +496,6 @@
 
 static void parserInit(XML_Parser parser, const XML_Char *encodingName);
 
-#ifdef XML_DTD
-static float accountingGetCurrentAmplification(XML_Parser rootParser);
-static void accountingReportStats(XML_Parser originParser, const char *epilog);
-static void accountingOnAbort(XML_Parser originParser);
-static void accountingReportDiff(XML_Parser rootParser,
-                                 unsigned int levelsAwayFromRootParser,
-                                 const char *before, const char *after,
-                                 ptrdiff_t bytesMore, int source_line,
-                                 enum XML_Account account);
-static XML_Bool accountingDiffTolerated(XML_Parser originParser, int tok,
-                                        const char *before, const char *after,
-                                        int source_line,
-                                        enum XML_Account account);
-
-static void entityTrackingReportStats(XML_Parser parser, ENTITY *entity,
-                                      const char *action, int sourceLine);
-static void entityTrackingOnOpen(XML_Parser parser, ENTITY *entity,
-                                 int sourceLine);
-static void entityTrackingOnClose(XML_Parser parser, ENTITY *entity,
-                                  int sourceLine);
-
-static XML_Parser getRootParserOf(XML_Parser parser,
-                                  unsigned int *outLevelDiff);
-#endif /* XML_DTD */
-
-static unsigned long getDebugLevel(const char *variableName,
-                                   unsigned long defaultDebugLevel);
-
 #define poolStart(pool) ((pool)->start)
 #define poolEnd(pool) ((pool)->ptr)
 #define poolLength(pool) ((pool)->ptr - (pool)->start)
@@ -703,10 +609,6 @@
   enum XML_ParamEntityParsing m_paramEntityParsing;
 #endif
   unsigned long m_hash_secret_salt;
-#ifdef XML_DTD
-  ACCOUNTING m_accounting;
-  ENTITY_STATS m_entity_stats;
-#endif
 };
 
 #define MALLOC(parser, s) (parser->m_mem.malloc_fcn((s)))
@@ -719,11 +621,11 @@
 
 XML_Parser XMLCALL XML_ParserCreateNS(const XML_Char *encodingName,
                                       XML_Char nsSep) {
-  XML_Char tmp[2] = {nsSep, 0};
+  XML_Char tmp[2];
+  *tmp = nsSep;
   return XML_ParserCreate_MM(encodingName, NULL, tmp);
 }
 
-// "xml=http://www.w3.org/XML/1998/namespace"
 static const XML_Char implicitContext[] = {
     ASCII_x,     ASCII_m,     ASCII_l,      ASCII_EQUALS, ASCII_h,
     ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,  ASCII_SLASH,
@@ -823,36 +725,32 @@
 
 #ifdef _WIN32
 
-/* Provide declaration of rand_s() for MinGW-32 (not 64, which has it),
-   as it didn't declare it in its header prior to version 5.3.0 of its
-   runtime package (mingwrt, containing stdlib.h).  The upstream fix
-   was introduced at https://osdn.net/projects/mingw/ticket/39658 . */
-#if defined(__MINGW32__) && defined(__MINGW32_VERSION) &&                      \
-    __MINGW32_VERSION < 5003000L && !defined(__MINGW64_VERSION_MAJOR)
-__declspec(dllimport) int rand_s(unsigned int *);
-#endif
+typedef BOOLEAN(APIENTRY *RTLGENRANDOM_FUNC)(PVOID, ULONG);
+HMODULE _Expat_LoadLibrary(LPCTSTR filename); /* see loadlibrary.c */
 
-/* Obtain entropy on Windows using the rand_s() function which
- * generates cryptographically secure random numbers.  Internally it
- * uses RtlGenRandom API which is present in Windows XP and later.
+/* Obtain entropy on Windows XP / Windows Server 2003 and later.
+ * Hint on RtlGenRandom and the following article from libsodium.
+ *
+ * Michael Howard: Cryptographically Secure Random number on Windows without
+ * using CryptoAPI
+ * https://blogs.msdn.microsoft.com/michael_howard/2005/01/14/cryptographically-secure-random-number-on-windows-without-using-cryptoapi/
  */
-static int writeRandomBytes_rand_s(void *target, size_t count) {
-  size_t bytesWrittenTotal = 0;
-
-  while (bytesWrittenTotal < count) {
-    unsigned int random32 = 0;
-    size_t i = 0;
-
-    if (rand_s(&random32))
-      return 0; /* failure */
+static int writeRandomBytes_RtlGenRandom(void *target, size_t count) {
+  int success = 0; /* full count bytes written? */
+  const HMODULE advapi32 = _Expat_LoadLibrary(TEXT("ADVAPI32.DLL"));
 
-    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);
-         i++, bytesWrittenTotal++) {
-      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));
-      ((uint8_t *)target)[bytesWrittenTotal] = random8;
+  if (advapi32) {
+    const RTLGENRANDOM_FUNC RtlGenRandom =
+        (RTLGENRANDOM_FUNC)GetProcAddress(advapi32, "SystemFunction036");
+    if (RtlGenRandom) {
+      if (RtlGenRandom((PVOID)target, (ULONG)count) == TRUE) {
+        success = 1;
+      }
     }
+    FreeLibrary(advapi32);
   }
-  return 1; /* success */
+
+  return success;
 }
 
 #endif /* _WIN32 */
@@ -884,8 +782,9 @@
 #endif /* ! defined(HAVE_ARC4RANDOM_BUF) && ! defined(HAVE_ARC4RANDOM) */
 
 static unsigned long ENTROPY_DEBUG(const char *label, unsigned long entropy) {
-  if (getDebugLevel("EXPAT_ENTROPY_DEBUG", 0) >= 1u) {
-    fprintf(stderr, "expat: Entropy: %s --> 0x%0*lx (%lu bytes)\n", label,
+  const char *const EXPAT_ENTROPY_DEBUG = getenv("EXPAT_ENTROPY_DEBUG");
+  if (EXPAT_ENTROPY_DEBUG && !strcmp(EXPAT_ENTROPY_DEBUG, "1")) {
+    fprintf(stderr, "Entropy: %s --> 0x%0*lx (%lu bytes)\n", label,
             (int)sizeof(entropy) * 2, entropy, (unsigned long)sizeof(entropy));
   }
   return entropy;
@@ -905,8 +804,8 @@
 #else
   /* Try high quality providers first .. */
 #ifdef _WIN32
-  if (writeRandomBytes_rand_s((void *)&entropy, sizeof(entropy))) {
-    return ENTROPY_DEBUG("rand_s", entropy);
+  if (writeRandomBytes_RtlGenRandom((void *)&entropy, sizeof(entropy))) {
+    return ENTROPY_DEBUG("RtlGenRandom", entropy);
   }
 #elif defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)
   if (writeRandomBytes_getrandom_nonblock((void *)&entropy, sizeof(entropy))) {
@@ -966,7 +865,7 @@
 
   if (memsuite) {
     XML_Memory_Handling_Suite *mtemp;
-    parser = memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));
+    parser = (XML_Parser)memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));
     if (parser != NULL) {
       mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
       mtemp->malloc_fcn = memsuite->malloc_fcn;
@@ -1058,14 +957,6 @@
   parserInit(parser, encodingName);
 
   if (encodingName && !parser->m_protocolEncodingName) {
-    if (dtd) {
-      // We need to stop the upcoming call to XML_ParserFree from happily
-      // destroying parser->m_dtd because the DTD is shared with the parent
-      // parser and the only guard that keeps XML_ParserFree from destroying
-      // parser->m_dtd is parser->m_isParamEntity but it will be set to
-      // XML_TRUE only later in XML_ExternalEntityParserCreate (or not at all).
-      parser->m_dtd = NULL;
-    }
     XML_ParserFree(parser);
     return NULL;
   }
@@ -1150,18 +1041,6 @@
   parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
 #endif
   parser->m_hash_secret_salt = 0;
-
-#ifdef XML_DTD
-  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));
-  parser->m_accounting.debugLevel = getDebugLevel("EXPAT_ACCOUNTING_DEBUG", 0u);
-  parser->m_accounting.maximumAmplificationFactor =
-      EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;
-  parser->m_accounting.activationThresholdBytes =
-      EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;
-
-  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));
-  parser->m_entity_stats.debugLevel = getDebugLevel("EXPAT_ENTITY_DEBUG", 0u);
-#endif
 }
 
 /* moves list of bindings to m_freeBindingList */
@@ -1342,7 +1221,8 @@
      would be otherwise.
   */
   if (parser->m_ns) {
-    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};
+    XML_Char tmp[2];
+    *tmp = parser->m_namespaceSeparator;
     parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
   } else {
     parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
@@ -1503,7 +1383,6 @@
   parser->m_useForeignDTD = useDTD;
   return XML_ERROR_NONE;
 #else
-  UNUSED_P(useDTD);
   return XML_ERROR_FEATURE_REQUIRES_XML_DTD;
 #endif
 }
@@ -1862,7 +1741,7 @@
     int nLeftOver;
     enum XML_Status result;
     /* Detect overflow (a+b > MAX <==> b > MAX-a) */
-    if ((XML_Size)len > ((XML_Size)-1) / 2 - parser->m_parseEndByteIndex) {
+    if (len > ((XML_Size)-1) / 2 - parser->m_parseEndByteIndex) {
       parser->m_errorCode = XML_ERROR_NO_MEMORY;
       parser->m_eventPtr = parser->m_eventEndPtr = NULL;
       parser->m_processor = errorProcessor;
@@ -1954,12 +1833,6 @@
     parser->m_errorCode = XML_ERROR_FINISHED;
     return XML_STATUS_ERROR;
   case XML_INITIALIZED:
-    /* Has someone called XML_GetBuffer successfully before? */
-    if (!parser->m_bufferPtr) {
-      parser->m_errorCode = XML_ERROR_NO_BUFFER;
-      return XML_STATUS_ERROR;
-    }
-
     if (parser->m_parentParser == NULL && !startParsing(parser)) {
       parser->m_errorCode = XML_ERROR_NO_MEMORY;
       return XML_STATUS_ERROR;
@@ -2037,11 +1910,6 @@
     keep = (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);
     if (keep > XML_CONTEXT_BYTES)
       keep = XML_CONTEXT_BYTES;
-    /* Detect and prevent integer overflow */
-    if (keep > INT_MAX - neededSize) {
-      parser->m_errorCode = XML_ERROR_NO_MEMORY;
-      return NULL;
-    }
     neededSize += keep;
 #endif /* defined XML_CONTEXT_BYTES */
     if (neededSize <=
@@ -2090,6 +1958,10 @@
       parser->m_bufferLim = newBuf + bufferSize;
 #ifdef XML_CONTEXT_BYTES
       if (parser->m_bufferPtr) {
+        int keep =
+            (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);
+        if (keep > XML_CONTEXT_BYTES)
+          keep = XML_CONTEXT_BYTES;
         memcpy(newBuf, &parser->m_bufferPtr[-keep],
                EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr) +
                    keep);
@@ -2241,7 +2113,7 @@
   (void)offset;
   (void)size;
 #endif /* defined XML_CONTEXT_BYTES */
-  return (const char *)0;
+  return (char *)0;
 }
 
 XML_Size XMLCALL XML_GetCurrentLineNumber(XML_Parser parser) {
@@ -2394,19 +2266,12 @@
   /* Added in 2.2.5. */
   case XML_ERROR_INVALID_ARGUMENT: /* Constant added in 2.2.1, already */
     return XML_L("invalid argument");
-    /* Added in 2.3.0. */
-  case XML_ERROR_NO_BUFFER:
-    return XML_L(
-        "a successful prior call to function XML_GetBuffer is required");
-  /* Added in 2.4.0. */
-  case XML_ERROR_AMPLIFICATION_LIMIT_BREACH:
-    return XML_L(
-        "limit on input amplification factor (from DTD and entities) breached");
   }
   return NULL;
 }
 
 const XML_LChar *XMLCALL XML_ExpatVersion(void) {
+
   /* V1 is used to string-ize the version number. However, it would
      string-ize the actual version macro *names* unless we get them
      substituted before being passed to V1. CPP is defined to expand
@@ -2465,43 +2330,11 @@
 #ifdef XML_ATTR_INFO
       {XML_FEATURE_ATTR_INFO, XML_L("XML_ATTR_INFO"), 0},
 #endif
-#ifdef XML_DTD
-      /* Added in Expat 2.4.0. */
-      {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,
-       XML_L("XML_BLAP_MAX_AMP"),
-       (long int)
-           EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},
-      {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,
-       XML_L("XML_BLAP_ACT_THRES"),
-       EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},
-#endif
       {XML_FEATURE_END, NULL, 0}};
 
   return features;
 }
 
-#ifdef XML_DTD
-XML_Bool XMLCALL XML_SetBillionLaughsAttackProtectionMaximumAmplification(
-    XML_Parser parser, float maximumAmplificationFactor) {
-  if ((parser == NULL) || (parser->m_parentParser != NULL) ||
-      isnan(maximumAmplificationFactor) ||
-      (maximumAmplificationFactor < 1.0f)) {
-    return XML_FALSE;
-  }
-  parser->m_accounting.maximumAmplificationFactor = maximumAmplificationFactor;
-  return XML_TRUE;
-}
-
-XML_Bool XMLCALL XML_SetBillionLaughsAttackProtectionActivationThreshold(
-    XML_Parser parser, unsigned long long activationThresholdBytes) {
-  if ((parser == NULL) || (parser->m_parentParser != NULL)) {
-    return XML_FALSE;
-  }
-  parser->m_accounting.activationThresholdBytes = activationThresholdBytes;
-  return XML_TRUE;
-}
-#endif /* XML_DTD */
-
 /* Initially tag->rawName always points into the parse buffer;
    for those TAG instances opened while the current parse buffer was
    processed, and not yet closed, we need to store tag->rawName in a more
@@ -2512,7 +2345,6 @@
   while (tag) {
     int bufSize;
     int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);
-    size_t rawNameLen;
     char *rawNameBuf = tag->buf + nameLen;
     /* Stop if already stored.  Since m_tagStack is a stack, we can stop
        at the first entry that has already been copied; everything
@@ -2524,11 +2356,7 @@
     /* For re-use purposes we need to ensure that the
        size of tag->buf is a multiple of sizeof(XML_Char).
     */
-    rawNameLen = ROUND_UP(tag->rawNameLength, sizeof(XML_Char));
-    /* Detect and prevent integer overflow. */
-    if (rawNameLen > (size_t)INT_MAX - nameLen)
-      return XML_FALSE;
-    bufSize = nameLen + (int)rawNameLen;
+    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));
     if (bufSize > tag->bufEnd - tag->buf) {
       char *temp = (char *)REALLOC(parser, tag->buf, bufSize);
       if (temp == NULL)
@@ -2559,9 +2387,9 @@
                                                const char *start,
                                                const char *end,
                                                const char **endPtr) {
-  enum XML_Error result = doContent(
-      parser, 0, parser->m_encoding, start, end, endPtr,
-      (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);
+  enum XML_Error result =
+      doContent(parser, 0, parser->m_encoding, start, end, endPtr,
+                (XML_Bool)!parser->m_parsingStatus.finalBuffer);
   if (result == XML_ERROR_NONE) {
     if (!storeRawNames(parser))
       return XML_ERROR_NO_MEMORY;
@@ -2587,14 +2415,6 @@
   int tok = XmlContentTok(parser->m_encoding, start, end, &next);
   switch (tok) {
   case XML_TOK_BOM:
-#ifdef XML_DTD
-    if (!accountingDiffTolerated(parser, tok, start, next, __LINE__,
-                                 XML_ACCOUNT_DIRECT)) {
-      accountingOnAbort(parser);
-      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-    }
-#endif /* XML_DTD */
-
     /* If we are at the end of the buffer, this would cause the next stage,
        i.e. externalEntityInitProcessor3, to pass control directly to
        doContent (by detecting XML_TOK_NONE) without processing any xml text
@@ -2632,10 +2452,6 @@
   const char *next = start; /* XmlContentTok doesn't always set the last arg */
   parser->m_eventPtr = start;
   tok = XmlContentTok(parser->m_encoding, start, end, &next);
-  /* Note: These bytes are accounted later in:
-           - processXmlDecl
-           - externalEntityContentProcessor
-  */
   parser->m_eventEndPtr = next;
 
   switch (tok) {
@@ -2677,8 +2493,7 @@
                                const char *end, const char **endPtr) {
   enum XML_Error result =
       doContent(parser, 1, parser->m_encoding, start, end, endPtr,
-                (XML_Bool)!parser->m_parsingStatus.finalBuffer,
-                XML_ACCOUNT_ENTITY_EXPANSION);
+                (XML_Bool)!parser->m_parsingStatus.finalBuffer);
   if (result == XML_ERROR_NONE) {
     if (!storeRawNames(parser))
       return XML_ERROR_NO_MEMORY;
@@ -2689,7 +2504,7 @@
 static enum XML_Error doContent(XML_Parser parser, int startTagLevel,
                                 const ENCODING *enc, const char *s,
                                 const char *end, const char **nextPtr,
-                                XML_Bool haveMore, enum XML_Account account) {
+                                XML_Bool haveMore) {
   /* save one level of indirection */
   DTD *const dtd = parser->m_dtd;
 
@@ -2707,17 +2522,6 @@
   for (;;) {
     const char *next = s; /* XmlContentTok doesn't always set the last arg */
     int tok = XmlContentTok(enc, s, end, &next);
-#ifdef XML_DTD
-    const char *accountAfter =
-        ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))
-            ? (haveMore ? s /* i.e. 0 bytes */ : end)
-            : next;
-    if (!accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,
-                                 account)) {
-      accountingOnAbort(parser);
-      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-    }
-#endif
     *eventEndPP = next;
     switch (tok) {
     case XML_TOK_TRAILING_CR:
@@ -2773,14 +2577,6 @@
       XML_Char ch = (XML_Char)XmlPredefinedEntityName(
           enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
       if (ch) {
-#ifdef XML_DTD
-        /* NOTE: We are replacing 4-6 characters original input for 1 character
-         *       so there is no amplification and hence recording without
-         *       protection. */
-        accountingDiffTolerated(parser, tok, (char *)&ch,
-                                ((char *)&ch) + sizeof(XML_Char), __LINE__,
-                                XML_ACCOUNT_ENTITY_EXPANSION);
-#endif /* XML_DTD */
         if (parser->m_characterDataHandler)
           parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);
         else if (parser->m_defaultHandler)
@@ -2899,8 +2695,7 @@
       }
       tag->name.str = (XML_Char *)tag->buf;
       *toPtr = XML_T('\0');
-      result =
-          storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);
+      result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
       if (result)
         return result;
       if (parser->m_startElementHandler)
@@ -2924,8 +2719,7 @@
       if (!name.str)
         return XML_ERROR_NO_MEMORY;
       poolFinish(&parser->m_tempPool);
-      result = storeAtts(parser, enc, s, &name, &bindings,
-                         XML_ACCOUNT_NONE /* token spans whole start tag */);
+      result = storeAtts(parser, enc, s, &name, &bindings);
       if (result != XML_ERROR_NONE) {
         freeBindings(parser, bindings);
         return result;
@@ -2962,6 +2756,9 @@
         int len;
         const char *rawName;
         TAG *tag = parser->m_tagStack;
+        parser->m_tagStack = tag->parent;
+        tag->parent = parser->m_freeTagList;
+        parser->m_freeTagList = tag;
         rawName = s + enc->minBytesPerChar * 2;
         len = XmlNameLength(enc, rawName);
         if (len != tag->rawNameLength ||
@@ -2969,9 +2766,6 @@
           *eventPP = rawName;
           return XML_ERROR_TAG_MISMATCH;
         }
-        parser->m_tagStack = tag->parent;
-        tag->parent = parser->m_freeTagList;
-        parser->m_freeTagList = tag;
         --parser->m_tagLevel;
         if (parser->m_endElementHandler) {
           const XML_Char *localPart;
@@ -3008,13 +2802,8 @@
           parser->m_freeBindingList = b;
           b->prefix->binding = b->prevPrefixBinding;
         }
-        if ((parser->m_tagLevel == 0) &&
-            (parser->m_parsingStatus.parsing != XML_FINISHED)) {
-          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)
-            parser->m_processor = epilogProcessor;
-          else
-            return epilogProcessor(parser, next, end, nextPtr);
-        }
+        if (parser->m_tagLevel == 0)
+          return epilogProcessor(parser, next, end, nextPtr);
       }
       break;
     case XML_TOK_CHAR_REF: {
@@ -3060,8 +2849,7 @@
       /* END disabled code */
       else if (parser->m_defaultHandler)
         reportDefault(parser, enc, s, next);
-      result =
-          doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);
+      result = doCdataSection(parser, enc, &next, end, nextPtr, haveMore);
       if (result != XML_ERROR_NONE)
         return result;
       else if (!next) {
@@ -3189,8 +2977,7 @@
 */
 static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *enc,
                                 const char *attStr, TAG_NAME *tagNamePtr,
-                                BINDING **bindingsPtr,
-                                enum XML_Account account) {
+                                BINDING **bindingsPtr) {
   DTD *const dtd = parser->m_dtd; /* save one level of indirection */
   ELEMENT_TYPE *elementType;
   int nDefaultAtts;
@@ -3222,38 +3009,13 @@
 
   /* get the attributes from the tokenizer */
   n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);
-
-  /* Detect and prevent integer overflow */
-  if (n > INT_MAX - nDefaultAtts) {
-    return XML_ERROR_NO_MEMORY;
-  }
-
   if (n + nDefaultAtts > parser->m_attsSize) {
     int oldAttsSize = parser->m_attsSize;
     ATTRIBUTE *temp;
 #ifdef XML_ATTR_INFO
     XML_AttrInfo *temp2;
 #endif
-
-    /* Detect and prevent integer overflow */
-    if ((nDefaultAtts > INT_MAX - INIT_ATTS_SIZE) ||
-        (n > INT_MAX - (nDefaultAtts + INIT_ATTS_SIZE))) {
-      return XML_ERROR_NO_MEMORY;
-    }
-
     parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
-
-    /* Detect and prevent integer overflow.
-     * The preprocessor guard addresses the "always false" warning
-     * from -Wtype-limits on platforms where
-     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-    if ((unsigned)parser->m_attsSize > (size_t)(-1) / sizeof(ATTRIBUTE)) {
-      parser->m_attsSize = oldAttsSize;
-      return XML_ERROR_NO_MEMORY;
-    }
-#endif
-
     temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,
                                 parser->m_attsSize * sizeof(ATTRIBUTE));
     if (temp == NULL) {
@@ -3262,17 +3024,6 @@
     }
     parser->m_atts = temp;
 #ifdef XML_ATTR_INFO
-    /* Detect and prevent integer overflow.
-     * The preprocessor guard addresses the "always false" warning
-     * from -Wtype-limits on platforms where
-     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-    if ((unsigned)parser->m_attsSize > (size_t)(-1) / sizeof(XML_AttrInfo)) {
-      parser->m_attsSize = oldAttsSize;
-      return XML_ERROR_NO_MEMORY;
-    }
-#endif
-
     temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,
                                     parser->m_attsSize * sizeof(XML_AttrInfo));
     if (temp2 == NULL) {
@@ -3334,9 +3085,9 @@
       }
 
       /* normalize the attribute value */
-      result = storeAttributeValue(
-          parser, enc, isCdata, parser->m_atts[i].valuePtr,
-          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);
+      result =
+          storeAttributeValue(parser, enc, isCdata, parser->m_atts[i].valuePtr,
+                              parser->m_atts[i].valueEnd, &parser->m_tempPool);
       if (result)
         return result;
       appAtts[attIndex] = poolStart(&parser->m_tempPool);
@@ -3411,13 +3162,7 @@
   if (nPrefixes) {
     int j; /* hash table index */
     unsigned long version = parser->m_nsAttsVersion;
-
-    /* Detect and prevent invalid shift */
-    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {
-      return XML_ERROR_NO_MEMORY;
-    }
-
-    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;
+    int nsAttsSize = (int)1 << parser->m_nsAttsPower;
     unsigned char oldNsAttsPower = parser->m_nsAttsPower;
     /* size of hash table must be at least 2 * (# of prefixed attributes) */
     if ((nPrefixes << 1) >>
@@ -3428,28 +3173,7 @@
         ;
       if (parser->m_nsAttsPower < 3)
         parser->m_nsAttsPower = 3;
-
-      /* Detect and prevent invalid shift */
-      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {
-        /* Restore actual size of memory in m_nsAtts */
-        parser->m_nsAttsPower = oldNsAttsPower;
-        return XML_ERROR_NO_MEMORY;
-      }
-
-      nsAttsSize = 1u << parser->m_nsAttsPower;
-
-      /* Detect and prevent integer overflow.
-       * The preprocessor guard addresses the "always false" warning
-       * from -Wtype-limits on platforms where
-       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {
-        /* Restore actual size of memory in m_nsAtts */
-        parser->m_nsAttsPower = oldNsAttsPower;
-        return XML_ERROR_NO_MEMORY;
-      }
-#endif
-
+      nsAttsSize = (int)1 << parser->m_nsAttsPower;
       temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,
                                nsAttsSize * sizeof(NS_ATT));
       if (!temp) {
@@ -3607,31 +3331,9 @@
   tagNamePtr->prefixLen = prefixLen;
   for (i = 0; localPart[i++];)
     ; /* i includes null terminator */
-
-  /* Detect and prevent integer overflow */
-  if (binding->uriLen > INT_MAX - prefixLen ||
-      i > INT_MAX - (binding->uriLen + prefixLen)) {
-    return XML_ERROR_NO_MEMORY;
-  }
-
   n = i + binding->uriLen + prefixLen;
   if (n > binding->uriAlloc) {
     TAG *p;
-
-    /* Detect and prevent integer overflow */
-    if (n > INT_MAX - EXPAND_SPARE) {
-      return XML_ERROR_NO_MEMORY;
-    }
-    /* Detect and prevent integer overflow.
-     * The preprocessor guard addresses the "always false" warning
-     * from -Wtype-limits on platforms where
-     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-    if ((unsigned)(n + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
-      return XML_ERROR_NO_MEMORY;
-    }
-#endif
-
     uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));
     if (!uri)
       return XML_ERROR_NO_MEMORY;
@@ -3656,123 +3358,12 @@
   return XML_ERROR_NONE;
 }
 
-static XML_Bool is_rfc3986_uri_char(XML_Char candidate) {
-  // For the RFC 3986 ANBF grammar see
-  // https://datatracker.ietf.org/doc/html/rfc3986#appendix-A
-
-  switch (candidate) {
-  // From rule "ALPHA" (uppercase half)
-  case 'A':
-  case 'B':
-  case 'C':
-  case 'D':
-  case 'E':
-  case 'F':
-  case 'G':
-  case 'H':
-  case 'I':
-  case 'J':
-  case 'K':
-  case 'L':
-  case 'M':
-  case 'N':
-  case 'O':
-  case 'P':
-  case 'Q':
-  case 'R':
-  case 'S':
-  case 'T':
-  case 'U':
-  case 'V':
-  case 'W':
-  case 'X':
-  case 'Y':
-  case 'Z':
-
-  // From rule "ALPHA" (lowercase half)
-  case 'a':
-  case 'b':
-  case 'c':
-  case 'd':
-  case 'e':
-  case 'f':
-  case 'g':
-  case 'h':
-  case 'i':
-  case 'j':
-  case 'k':
-  case 'l':
-  case 'm':
-  case 'n':
-  case 'o':
-  case 'p':
-  case 'q':
-  case 'r':
-  case 's':
-  case 't':
-  case 'u':
-  case 'v':
-  case 'w':
-  case 'x':
-  case 'y':
-  case 'z':
-
-  // From rule "DIGIT"
-  case '0':
-  case '1':
-  case '2':
-  case '3':
-  case '4':
-  case '5':
-  case '6':
-  case '7':
-  case '8':
-  case '9':
-
-  // From rule "pct-encoded"
-  case '%':
-
-  // From rule "unreserved"
-  case '-':
-  case '.':
-  case '_':
-  case '~':
-
-  // From rule "gen-delims"
-  case ':':
-  case '/':
-  case '?':
-  case '#':
-  case '[':
-  case ']':
-  case '@':
-
-  // From rule "sub-delims"
-  case '!':
-  case '$':
-  case '&':
-  case '\'':
-  case '(':
-  case ')':
-  case '*':
-  case '+':
-  case ',':
-  case ';':
-  case '=':
-    return XML_TRUE;
-
-  default:
-    return XML_FALSE;
-  }
-}
-
 /* addBinding() overwrites the value of prefix->binding without checking.
    Therefore one must keep track of the old value outside of addBinding().
 */
 static enum XML_Error addBinding(XML_Parser parser, PREFIX *prefix,
                                  const ATTRIBUTE_ID *attId, const XML_Char *uri,
                                  BINDING **bindingsPtr) {
-  // "http://www.w3.org/XML/1998/namespace"
   static const XML_Char xmlNamespace[] = {
       ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,
       ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,
@@ -3783,7 +3374,6 @@
       ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,
       ASCII_e,      '\0'};
   static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;
-  // "http://www.w3.org/2000/xmlns/"
   static const XML_Char xmlnsNamespace[] = {
       ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,
       ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,
@@ -3806,6 +3396,7 @@
 
   if (prefix->name && prefix->name[0] == XML_T(ASCII_x) &&
       prefix->name[1] == XML_T(ASCII_m) && prefix->name[2] == XML_T(ASCII_l)) {
+
     /* Not allowed to bind xmlns */
     if (prefix->name[3] == XML_T(ASCII_n) &&
         prefix->name[4] == XML_T(ASCII_s) && prefix->name[5] == XML_T('\0'))
@@ -3822,29 +3413,6 @@
     if (!mustBeXML && isXMLNS &&
         (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))
       isXMLNS = XML_FALSE;
-
-    // NOTE: While Expat does not validate namespace URIs against RFC 3986
-    //       today (and is not REQUIRED to do so with regard to the XML 1.0
-    //       namespaces specification) we have to at least make sure, that
-    //       the application on top of Expat (that is likely splitting expanded
-    //       element names ("qualified names") of form
-    //       "[uri sep] local [sep prefix] '\0'" back into 1, 2 or 3 pieces
-    //       in its element handler code) cannot be confused by an attacker
-    //       putting additional namespace separator characters into namespace
-    //       declarations.  That would be ambiguous and not to be expected.
-    //
-    //       While the HTML API docs of function XML_ParserCreateNS have been
-    //       advising against use of a namespace separator character that can
-    //       appear in a URI for >20 years now, some widespread applications
-    //       are using URI characters (':' (colon) in particular) for a
-    //       namespace separator, in practice.  To keep these applications
-    //       functional, we only reject namespaces URIs containing the
-    //       application-chosen namespace separator if the chosen separator
-    //       is a non-URI character with regard to RFC 3986.
-    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator) &&
-        !is_rfc3986_uri_char(uri[len])) {
-      return XML_ERROR_SYNTAX;
-    }
   }
   isXML = isXML && len == xmlLen;
   isXMLNS = isXMLNS && len == xmlnsLen;
@@ -3861,21 +3429,6 @@
   if (parser->m_freeBindingList) {
     b = parser->m_freeBindingList;
     if (len > b->uriAlloc) {
-      /* Detect and prevent integer overflow */
-      if (len > INT_MAX - EXPAND_SPARE) {
-        return XML_ERROR_NO_MEMORY;
-      }
-
-      /* Detect and prevent integer overflow.
-       * The preprocessor guard addresses the "always false" warning
-       * from -Wtype-limits on platforms where
-       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
-        return XML_ERROR_NO_MEMORY;
-      }
-#endif
-
       XML_Char *temp = (XML_Char *)REALLOC(
           parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));
       if (temp == NULL)
@@ -3888,21 +3441,6 @@
     b = (BINDING *)MALLOC(parser, sizeof(BINDING));
     if (!b)
       return XML_ERROR_NO_MEMORY;
-
-    /* Detect and prevent integer overflow */
-    if (len > INT_MAX - EXPAND_SPARE) {
-      return XML_ERROR_NO_MEMORY;
-    }
-    /* Detect and prevent integer overflow.
-     * The preprocessor guard addresses the "always false" warning
-     * from -Wtype-limits on platforms where
-     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {
-      return XML_ERROR_NO_MEMORY;
-    }
-#endif
-
     b->uri =
         (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));
     if (!b->uri) {
@@ -3939,9 +3477,9 @@
                                                     const char *start,
                                                     const char *end,
                                                     const char **endPtr) {
-  enum XML_Error result = doCdataSection(
-      parser, parser->m_encoding, &start, end, endPtr,
-      (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_ACCOUNT_DIRECT);
+  enum XML_Error result =
+      doCdataSection(parser, parser->m_encoding, &start, end, endPtr,
+                     (XML_Bool)!parser->m_parsingStatus.finalBuffer);
   if (result != XML_ERROR_NONE)
     return result;
   if (start) {
@@ -3961,8 +3499,7 @@
 */
 static enum XML_Error doCdataSection(XML_Parser parser, const ENCODING *enc,
                                      const char **startPtr, const char *end,
-                                     const char **nextPtr, XML_Bool haveMore,
-                                     enum XML_Account account) {
+                                     const char **nextPtr, XML_Bool haveMore) {
   const char *s = *startPtr;
   const char **eventPP;
   const char **eventEndPP;
@@ -3978,16 +3515,8 @@
   *startPtr = NULL;
 
   for (;;) {
-    const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */
+    const char *next;
     int tok = XmlCdataSectionTok(enc, s, end, &next);
-#ifdef XML_DTD
-    if (!accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {
-      accountingOnAbort(parser);
-      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-    }
-#else
-    UNUSED_P(account);
-#endif
     *eventEndPP = next;
     switch (tok) {
     case XML_TOK_CDATA_SECT_CLOSE:
@@ -4105,7 +3634,7 @@
 static enum XML_Error doIgnoreSection(XML_Parser parser, const ENCODING *enc,
                                       const char **startPtr, const char *end,
                                       const char **nextPtr, XML_Bool haveMore) {
-  const char *next = *startPtr; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */
+  const char *next;
   int tok;
   const char *s = *startPtr;
   const char **eventPP;
@@ -4133,13 +3662,6 @@
   *eventPP = s;
   *startPtr = NULL;
   tok = XmlIgnoreSectionTok(enc, s, end, &next);
-#ifdef XML_DTD
-  if (!accountingDiffTolerated(parser, tok, s, next, __LINE__,
-                               XML_ACCOUNT_DIRECT)) {
-    accountingOnAbort(parser);
-    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-  }
-#endif
   *eventEndPP = next;
   switch (tok) {
   case XML_TOK_IGNORE_SECT:
@@ -4188,7 +3710,7 @@
   const char *s;
 #ifdef XML_UNICODE
   char encodingBuf[128];
-  /* See comments about `protocolEncodingName` in parserInit() */
+  /* See comments abount `protoclEncodingName` in parserInit() */
   if (!parser->m_protocolEncodingName)
     s = NULL;
   else {
@@ -4219,18 +3741,9 @@
   const XML_Char *storedEncName = NULL;
   const ENCODING *newEncoding = NULL;
   const char *version = NULL;
-  const char *versionend = NULL;
+  const char *versionend;
   const XML_Char *storedversion = NULL;
   int standalone = -1;
-
-#ifdef XML_DTD
-  if (!accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,
-                               XML_ACCOUNT_DIRECT)) {
-    accountingOnAbort(parser);
-    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-  }
-#endif
-
   if (!(parser->m_ns ? XmlParseXmlDeclNS : XmlParseXmlDecl)(
           isGeneralTextEntity, parser->m_encoding, s, next, &parser->m_eventPtr,
           &version, &versionend, &encodingName, &newEncoding, &standalone)) {
@@ -4381,10 +3894,6 @@
 
   for (;;) {
     tok = XmlPrologTok(parser->m_encoding, start, end, &next);
-    /* Note: Except for XML_TOK_BOM below, these bytes are accounted later in:
-             - storeEntityValue
-             - processXmlDecl
-    */
     parser->m_eventEndPtr = next;
     if (tok <= 0) {
       if (!parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {
@@ -4403,8 +3912,7 @@
         break;
       }
       /* found end of entity value - can store it now */
-      return storeEntityValue(parser, parser->m_encoding, s, end,
-                              XML_ACCOUNT_DIRECT);
+      return storeEntityValue(parser, parser->m_encoding, s, end);
     } else if (tok == XML_TOK_XML_DECL) {
       enum XML_Error result;
       result = processXmlDecl(parser, 0, start, next);
@@ -4431,14 +3939,6 @@
     */
     else if (tok == XML_TOK_BOM && next == end &&
              !parser->m_parsingStatus.finalBuffer) {
-#ifdef XML_DTD
-      if (!accountingDiffTolerated(parser, tok, s, next, __LINE__,
-                                   XML_ACCOUNT_DIRECT)) {
-        accountingOnAbort(parser);
-        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-      }
-#endif
-
       *nextPtr = next;
       return XML_ERROR_NONE;
     }
@@ -4482,24 +3982,16 @@
   }
   /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.
      However, when parsing an external subset, doProlog will not accept a BOM
-     as valid, and report a syntax error, so we have to skip the BOM, and
-     account for the BOM bytes.
+     as valid, and report a syntax error, so we have to skip the BOM
   */
   else if (tok == XML_TOK_BOM) {
-    if (!accountingDiffTolerated(parser, tok, s, next, __LINE__,
-                                 XML_ACCOUNT_DIRECT)) {
-      accountingOnAbort(parser);
-      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-    }
-
     s = next;
     tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   }
 
   parser->m_processor = prologProcessor;
   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
-                  (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_TRUE,
-                  XML_ACCOUNT_DIRECT);
+                  (XML_Bool)!parser->m_parsingStatus.finalBuffer);
 }
 
 static enum XML_Error PTRCALL entityValueProcessor(XML_Parser parser,
@@ -4513,9 +4005,6 @@
 
   for (;;) {
     tok = XmlPrologTok(enc, start, end, &next);
-    /* Note: These bytes are accounted later in:
-             - storeEntityValue
-    */
     if (tok <= 0) {
       if (!parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {
         *nextPtr = s;
@@ -4533,7 +4022,7 @@
         break;
       }
       /* found end of entity value - can store it now */
-      return storeEntityValue(parser, enc, s, end, XML_ACCOUNT_DIRECT);
+      return storeEntityValue(parser, enc, s, end);
     }
     start = next;
   }
@@ -4547,15 +4036,13 @@
   const char *next = s;
   int tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
-                  (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_TRUE,
-                  XML_ACCOUNT_DIRECT);
+                  (XML_Bool)!parser->m_parsingStatus.finalBuffer);
 }
 
 static enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,
                                const char *s, const char *end, int tok,
                                const char *next, const char **nextPtr,
-                               XML_Bool haveMore, XML_Bool allowClosingDoctype,
-                               enum XML_Account account) {
+                               XML_Bool haveMore) {
 #ifdef XML_DTD
   static const XML_Char externalSubsetName[] = {ASCII_HASH, '\0'};
 #endif /* XML_DTD */
@@ -4582,10 +4069,6 @@
   static const XML_Char enumValueSep[] = {ASCII_PIPE, '\0'};
   static const XML_Char enumValueStart[] = {ASCII_LPAREN, '\0'};
 
-#ifndef XML_DTD
-  UNUSED_P(account);
-#endif
-
   /* save one level of indirection */
   DTD *const dtd = parser->m_dtd;
 
@@ -4650,19 +4133,6 @@
       }
     }
     role = XmlTokenRole(&parser->m_prologState, tok, s, next, enc);
-#ifdef XML_DTD
-    switch (role) {
-    case XML_ROLE_INSTANCE_START: // bytes accounted in contentProcessor
-    case XML_ROLE_XML_DECL:       // bytes accounted in processXmlDecl
-    case XML_ROLE_TEXT_DECL:      // bytes accounted in processXmlDecl
-      break;
-    default:
-      if (!accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {
-        accountingOnAbort(parser);
-        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-      }
-    }
-#endif
     switch (role) {
     case XML_ROLE_XML_DECL: {
       enum XML_Error result = processXmlDecl(parser, 0, s, next);
@@ -4748,11 +4218,6 @@
       }
       break;
     case XML_ROLE_DOCTYPE_CLOSE:
-      if (allowClosingDoctype != XML_TRUE) {
-        /* Must not close doctype from within expanded parameter entities */
-        return XML_ERROR_INVALID_TOKEN;
-      }
-
       if (parser->m_doctypeName) {
         parser->m_startDoctypeDeclHandler(
             parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,
@@ -4927,10 +4392,10 @@
               parser->m_handlerArg, parser->m_declElementType->name,
               parser->m_declAttributeId->name, parser->m_declAttributeType, 0,
               role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
+          poolClear(&parser->m_tempPool);
           handleDefault = XML_FALSE;
         }
       }
-      poolClear(&parser->m_tempPool);
       break;
     case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:
     case XML_ROLE_FIXED_ATTRIBUTE_VALUE:
@@ -4938,8 +4403,7 @@
         const XML_Char *attVal;
         enum XML_Error result = storeAttributeValue(
             parser, enc, parser->m_declAttributeIsCdata,
-            s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool,
-            XML_ACCOUNT_NONE);
+            s + enc->minBytesPerChar, next - enc->minBytesPerChar, &dtd->pool);
         if (result)
           return result;
         attVal = poolStart(&dtd->pool);
@@ -4972,9 +4436,8 @@
       break;
     case XML_ROLE_ENTITY_VALUE:
       if (dtd->keepProcessing) {
-        enum XML_Error result =
-            storeEntityValue(parser, enc, s + enc->minBytesPerChar,
-                             next - enc->minBytesPerChar, XML_ACCOUNT_NONE);
+        enum XML_Error result = storeEntityValue(
+            parser, enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);
         if (parser->m_declEntity) {
           parser->m_declEntity->textPtr = poolStart(&dtd->entityValuePool);
           parser->m_declEntity->textLen =
@@ -5232,37 +4695,19 @@
     case XML_ROLE_GROUP_OPEN:
       if (parser->m_prologState.level >= parser->m_groupSize) {
         if (parser->m_groupSize) {
-          {
-            /* Detect and prevent integer overflow */
-            if (parser->m_groupSize > (unsigned int)(-1) / 2u) {
-              return XML_ERROR_NO_MEMORY;
-            }
-
-            char *const new_connector = (char *)REALLOC(
-                parser, parser->m_groupConnector, parser->m_groupSize *= 2);
-            if (new_connector == NULL) {
-              parser->m_groupSize /= 2;
-              return XML_ERROR_NO_MEMORY;
-            }
-            parser->m_groupConnector = new_connector;
+          char *temp = (char *)REALLOC(parser, parser->m_groupConnector,
+                                       parser->m_groupSize *= 2);
+          if (temp == NULL) {
+            parser->m_groupSize /= 2;
+            return XML_ERROR_NO_MEMORY;
           }
-
+          parser->m_groupConnector = temp;
           if (dtd->scaffIndex) {
-            /* Detect and prevent integer overflow.
-             * The preprocessor guard addresses the "always false" warning
-             * from -Wtype-limits on platforms where
-             * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-            if (parser->m_groupSize > (size_t)(-1) / sizeof(int)) {
-              return XML_ERROR_NO_MEMORY;
-            }
-#endif
-
-            int *const new_scaff_index = (int *)REALLOC(
-                parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));
-            if (new_scaff_index == NULL)
+            int *temp = (int *)REALLOC(parser, dtd->scaffIndex,
+                                       parser->m_groupSize * sizeof(int));
+            if (temp == NULL)
               return XML_ERROR_NO_MEMORY;
-            dtd->scaffIndex = new_scaff_index;
+            dtd->scaffIndex = temp;
           }
         } else {
           parser->m_groupConnector =
@@ -5278,7 +4723,6 @@
         int myindex = nextScaffoldPart(parser);
         if (myindex < 0)
           return XML_ERROR_NO_MEMORY;
-        assert(dtd->scaffIndex != NULL);
         dtd->scaffIndex[dtd->scaffLevel] = myindex;
         dtd->scaffLevel++;
         dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
@@ -5338,7 +4782,7 @@
              *
              * If 'standalone' is false, the DTD must have no
              * parameter entities or we wouldn't have passed the outer
-             * 'if' statement.  That means the only entity in the hash
+             * 'if' statement.  That measn the only entity in the hash
              * table is the external subset name "#" which cannot be
              * given as a parameter entity name in XML syntax, so the
              * lookup must have returned NULL and we don't even reach
@@ -5379,15 +4823,12 @@
         if (parser->m_externalEntityRefHandler) {
           dtd->paramEntityRead = XML_FALSE;
           entity->open = XML_TRUE;
-          entityTrackingOnOpen(parser, entity, __LINE__);
           if (!parser->m_externalEntityRefHandler(
                   parser->m_externalEntityRefHandlerArg, 0, entity->base,
                   entity->systemId, entity->publicId)) {
-            entityTrackingOnClose(parser, entity, __LINE__);
             entity->open = XML_FALSE;
             return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
           }
-          entityTrackingOnClose(parser, entity, __LINE__);
           entity->open = XML_FALSE;
           handleDefault = XML_FALSE;
           if (!dtd->paramEntityRead) {
@@ -5466,7 +4907,7 @@
       if (dtd->in_eldecl) {
         ELEMENT_TYPE *el;
         const XML_Char *name;
-        size_t nameLen;
+        int nameLen;
         const char *nxt =
             (quant == XML_CQUANT_NONE ? next : next - enc->minBytesPerChar);
         int myindex = nextScaffoldPart(parser);
@@ -5482,13 +4923,7 @@
         nameLen = 0;
         for (; name[nameLen++];)
           ;
-
-        /* Detect and prevent integer overflow */
-        if (nameLen > UINT_MAX - dtd->contentStringLen) {
-          return XML_ERROR_NO_MEMORY;
-        }
-
-        dtd->contentStringLen += (unsigned)nameLen;
+        dtd->contentStringLen += nameLen;
         if (parser->m_elementDeclHandler)
           handleDefault = XML_FALSE;
       }
@@ -5591,13 +5026,6 @@
   for (;;) {
     const char *next = NULL;
     int tok = XmlPrologTok(parser->m_encoding, s, end, &next);
-#ifdef XML_DTD
-    if (!accountingDiffTolerated(parser, tok, s, next, __LINE__,
-                                 XML_ACCOUNT_DIRECT)) {
-      accountingOnAbort(parser);
-      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-    }
-#endif
     parser->m_eventEndPtr = next;
     switch (tok) {
     /* report partial linebreak - it might be the last token */
@@ -5671,9 +5099,6 @@
       return XML_ERROR_NO_MEMORY;
   }
   entity->open = XML_TRUE;
-#ifdef XML_DTD
-  entityTrackingOnOpen(parser, entity, __LINE__);
-#endif
   entity->processed = 0;
   openEntity->next = parser->m_openInternalEntities;
   parser->m_openInternalEntities = openEntity;
@@ -5682,8 +5107,8 @@
   openEntity->betweenDecl = betweenDecl;
   openEntity->internalEventPtr = NULL;
   openEntity->internalEventEndPtr = NULL;
-  textStart = (const char *)entity->textPtr;
-  textEnd = (const char *)(entity->textPtr + entity->textLen);
+  textStart = (char *)entity->textPtr;
+  textEnd = (char *)(entity->textPtr + entity->textLen);
   /* Set a safe default value in case 'next' does not get set */
   next = textStart;
 
@@ -5692,22 +5117,17 @@
     int tok =
         XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
-                      tok, next, &next, XML_FALSE, XML_FALSE,
-                      XML_ACCOUNT_ENTITY_EXPANSION);
+                      tok, next, &next, XML_FALSE);
   } else
 #endif /* XML_DTD */
     result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,
-                       textStart, textEnd, &next, XML_FALSE,
-                       XML_ACCOUNT_ENTITY_EXPANSION);
+                       textStart, textEnd, &next, XML_FALSE);
 
   if (result == XML_ERROR_NONE) {
     if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {
       entity->processed = (int)(next - textStart);
       parser->m_processor = internalEntityProcessor;
     } else {
-#ifdef XML_DTD
-      entityTrackingOnClose(parser, entity, __LINE__);
-#endif /* XML_DTD */
       entity->open = XML_FALSE;
       parser->m_openInternalEntities = openEntity->next;
       /* put openEntity back in list of free instances */
@@ -5731,8 +5151,8 @@
     return XML_ERROR_UNEXPECTED_STATE;
 
   entity = openEntity->entity;
-  textStart = ((const char *)entity->textPtr) + entity->processed;
-  textEnd = (const char *)(entity->textPtr + entity->textLen);
+  textStart = ((char *)entity->textPtr) + entity->processed;
+  textEnd = (char *)(entity->textPtr + entity->textLen);
   /* Set a safe default value in case 'next' does not get set */
   next = textStart;
 
@@ -5741,37 +5161,25 @@
     int tok =
         XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
-                      tok, next, &next, XML_FALSE, XML_TRUE,
-                      XML_ACCOUNT_ENTITY_EXPANSION);
+                      tok, next, &next, XML_FALSE);
   } else
 #endif /* XML_DTD */
-    result = doContent(parser, openEntity->startTagLevel,
-                       parser->m_internalEncoding, textStart, textEnd, &next,
-                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);
+    result =
+        doContent(parser, openEntity->startTagLevel, parser->m_internalEncoding,
+                  textStart, textEnd, &next, XML_FALSE);
 
   if (result != XML_ERROR_NONE)
     return result;
-
-  if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {
-    entity->processed = (int)(next - (const char *)entity->textPtr);
+  else if (textEnd != next &&
+           parser->m_parsingStatus.parsing == XML_SUSPENDED) {
+    entity->processed = (int)(next - (char *)entity->textPtr);
     return result;
-  }
-
-#ifdef XML_DTD
-  entityTrackingOnClose(parser, entity, __LINE__);
-#endif
-  entity->open = XML_FALSE;
-  parser->m_openInternalEntities = openEntity->next;
-  /* put openEntity back in list of free instances */
-  openEntity->next = parser->m_freeInternalEntities;
-  parser->m_freeInternalEntities = openEntity;
-
-  // If there are more open entities we want to stop right here and have the
-  // upcoming call to XML_ResumeParser continue with entity content, or it would
-  // be ignored altogether.
-  if (parser->m_openInternalEntities != NULL &&
-      parser->m_parsingStatus.parsing == XML_SUSPENDED) {
-    return XML_ERROR_NONE;
+  } else {
+    entity->open = XML_FALSE;
+    parser->m_openInternalEntities = openEntity->next;
+    /* put openEntity back in list of free instances */
+    openEntity->next = parser->m_freeInternalEntities;
+    parser->m_freeInternalEntities = openEntity;
   }
 
 #ifdef XML_DTD
@@ -5780,41 +5188,31 @@
     parser->m_processor = prologProcessor;
     tok = XmlPrologTok(parser->m_encoding, s, end, &next);
     return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
-                    (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_TRUE,
-                    XML_ACCOUNT_DIRECT);
+                    (XML_Bool)!parser->m_parsingStatus.finalBuffer);
   } else
 #endif /* XML_DTD */
   {
     parser->m_processor = contentProcessor;
     /* see externalEntityContentProcessor vs contentProcessor */
-    result =
-        doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding, s,
-                  end, nextPtr, (XML_Bool)!parser->m_parsingStatus.finalBuffer,
-                  XML_ACCOUNT_DIRECT);
-    if (result == XML_ERROR_NONE) {
-      if (!storeRawNames(parser))
-        return XML_ERROR_NO_MEMORY;
-    }
-    return result;
+    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,
+                     s, end, nextPtr,
+                     (XML_Bool)!parser->m_parsingStatus.finalBuffer);
   }
 }
 
-static enum XML_Error PTRCALL errorProcessor(XML_Parser parser, const char *s,
-                                             const char *end,
-                                             const char **nextPtr) {
-  UNUSED_P(s);
-  UNUSED_P(end);
-  UNUSED_P(nextPtr);
+static enum XML_Error PTRCALL errorProcessor(XML_Parser parser,
+                                             const char *UNUSED_P(s),
+                                             const char *UNUSED_P(end),
+                                             const char **UNUSED_P(nextPtr)) {
   return parser->m_errorCode;
 }
 
 static enum XML_Error storeAttributeValue(XML_Parser parser,
                                           const ENCODING *enc, XML_Bool isCdata,
                                           const char *ptr, const char *end,
-                                          STRING_POOL *pool,
-                                          enum XML_Account account) {
+                                          STRING_POOL *pool) {
   enum XML_Error result =
-      appendAttributeValue(parser, enc, isCdata, ptr, end, pool, account);
+      appendAttributeValue(parser, enc, isCdata, ptr, end, pool);
   if (result)
     return result;
   if (!isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)
@@ -5827,23 +5225,11 @@
 static enum XML_Error appendAttributeValue(XML_Parser parser,
                                            const ENCODING *enc,
                                            XML_Bool isCdata, const char *ptr,
-                                           const char *end, STRING_POOL *pool,
-                                           enum XML_Account account) {
+                                           const char *end, STRING_POOL *pool) {
   DTD *const dtd = parser->m_dtd; /* save one level of indirection */
-#ifndef XML_DTD
-  UNUSED_P(account);
-#endif
-
   for (;;) {
-    const char *next =
-        ptr; /* XmlAttributeValueTok doesn't always set the last arg */
+    const char *next;
     int tok = XmlAttributeValueTok(enc, ptr, end, &next);
-#ifdef XML_DTD
-    if (!accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {
-      accountingOnAbort(parser);
-      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-    }
-#endif
     switch (tok) {
     case XML_TOK_NONE:
       return XML_ERROR_NONE;
@@ -5903,14 +5289,6 @@
       XML_Char ch = (XML_Char)XmlPredefinedEntityName(
           enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);
       if (ch) {
-#ifdef XML_DTD
-        /* NOTE: We are replacing 4-6 characters original input for 1 character
-         *       so there is no amplification and hence recording without
-         *       protection. */
-        accountingDiffTolerated(parser, tok, (char *)&ch,
-                                ((char *)&ch) + sizeof(XML_Char), __LINE__,
-                                XML_ACCOUNT_ENTITY_EXPANSION);
-#endif /* XML_DTD */
         if (!poolAppendChar(pool, ch))
           return XML_ERROR_NO_MEMORY;
         break;
@@ -5988,16 +5366,9 @@
         enum XML_Error result;
         const XML_Char *textEnd = entity->textPtr + entity->textLen;
         entity->open = XML_TRUE;
-#ifdef XML_DTD
-        entityTrackingOnOpen(parser, entity, __LINE__);
-#endif
         result = appendAttributeValue(parser, parser->m_internalEncoding,
-                                      isCdata, (const char *)entity->textPtr,
-                                      (const char *)textEnd, pool,
-                                      XML_ACCOUNT_ENTITY_EXPANSION);
-#ifdef XML_DTD
-        entityTrackingOnClose(parser, entity, __LINE__);
-#endif
+                                      isCdata, (char *)entity->textPtr,
+                                      (char *)textEnd, pool);
         entity->open = XML_FALSE;
         if (result)
           return result;
@@ -6027,16 +5398,13 @@
 
 static enum XML_Error storeEntityValue(XML_Parser parser, const ENCODING *enc,
                                        const char *entityTextPtr,
-                                       const char *entityTextEnd,
-                                       enum XML_Account account) {
+                                       const char *entityTextEnd) {
   DTD *const dtd = parser->m_dtd; /* save one level of indirection */
   STRING_POOL *pool = &(dtd->entityValuePool);
   enum XML_Error result = XML_ERROR_NONE;
 #ifdef XML_DTD
   int oldInEntityValue = parser->m_prologState.inEntityValue;
   parser->m_prologState.inEntityValue = 1;
-#else
-  UNUSED_P(account);
 #endif /* XML_DTD */
   /* never return Null for the value argument in EntityDeclHandler,
      since this would indicate an external entity; therefore we
@@ -6047,19 +5415,8 @@
   }
 
   for (;;) {
-    const char *next =
-        entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */
+    const char *next;
     int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);
-
-#ifdef XML_DTD
-    if (!accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,
-                                 account)) {
-      accountingOnAbort(parser);
-      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;
-      goto endEntityValue;
-    }
-#endif
-
     switch (tok) {
     case XML_TOK_PARAM_ENTITY_REF:
 #ifdef XML_DTD
@@ -6095,16 +5452,13 @@
           if (parser->m_externalEntityRefHandler) {
             dtd->paramEntityRead = XML_FALSE;
             entity->open = XML_TRUE;
-            entityTrackingOnOpen(parser, entity, __LINE__);
             if (!parser->m_externalEntityRefHandler(
                     parser->m_externalEntityRefHandlerArg, 0, entity->base,
                     entity->systemId, entity->publicId)) {
-              entityTrackingOnClose(parser, entity, __LINE__);
               entity->open = XML_FALSE;
               result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;
               goto endEntityValue;
             }
-            entityTrackingOnClose(parser, entity, __LINE__);
             entity->open = XML_FALSE;
             if (!dtd->paramEntityRead)
               dtd->keepProcessing = dtd->standalone;
@@ -6112,12 +5466,9 @@
             dtd->keepProcessing = dtd->standalone;
         } else {
           entity->open = XML_TRUE;
-          entityTrackingOnOpen(parser, entity, __LINE__);
           result = storeEntityValue(
-              parser, parser->m_internalEncoding, (const char *)entity->textPtr,
-              (const char *)(entity->textPtr + entity->textLen),
-              XML_ACCOUNT_ENTITY_EXPANSION);
-          entityTrackingOnClose(parser, entity, __LINE__);
+              parser, parser->m_internalEncoding, (char *)entity->textPtr,
+              (char *)(entity->textPtr + entity->textLen));
           entity->open = XML_FALSE;
           if (result)
             goto endEntityValue;
@@ -6346,24 +5697,7 @@
       }
     } else {
       DEFAULT_ATTRIBUTE *temp;
-
-      /* Detect and prevent integer overflow */
-      if (type->allocDefaultAtts > INT_MAX / 2) {
-        return 0;
-      }
-
       int count = type->allocDefaultAtts * 2;
-
-      /* Detect and prevent integer overflow.
-       * The preprocessor guard addresses the "always false" warning
-       * from -Wtype-limits on platforms where
-       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-      if ((unsigned)count > (size_t)(-1) / sizeof(DEFAULT_ATTRIBUTE)) {
-        return 0;
-      }
-#endif
-
       temp = (DEFAULT_ATTRIBUTE *)REALLOC(parser, type->defaultAtts,
                                           (count * sizeof(DEFAULT_ATTRIBUTE)));
       if (temp == NULL)
@@ -6404,7 +5738,6 @@
       else
         poolDiscard(&dtd->pool);
       elementType->prefix = prefix;
-      break;
     }
   }
   return 1;
@@ -6646,7 +5979,7 @@
 }
 
 static DTD *dtdCreate(const XML_Memory_Handling_Suite *ms) {
-  DTD *p = ms->malloc_fcn(sizeof(DTD));
+  DTD *p = (DTD *)ms->malloc_fcn(sizeof(DTD));
   if (p == NULL)
     return p;
   poolInit(&(p->pool), ms);
@@ -6817,8 +6150,8 @@
     if (!newE)
       return 0;
     if (oldE->nDefaultAtts) {
-      newE->defaultAtts =
-          ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
+      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)ms->malloc_fcn(
+          oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
       if (!newE->defaultAtts) {
         return 0;
       }
@@ -6975,7 +6308,7 @@
     /* table->size is a power of 2 */
     table->size = (size_t)1 << INIT_POWER;
     tsize = table->size * sizeof(NAMED *);
-    table->v = table->mem->malloc_fcn(tsize);
+    table->v = (NAMED **)table->mem->malloc_fcn(tsize);
     if (!table->v) {
       table->size = 0;
       return NULL;
@@ -7000,22 +6333,10 @@
     /* check for overflow (table is half full) */
     if (table->used >> (table->power - 1)) {
       unsigned char newPower = table->power + 1;
-
-      /* Detect and prevent invalid shift */
-      if (newPower >= sizeof(unsigned long) * 8 /* bits per byte */) {
-        return NULL;
-      }
-
       size_t newSize = (size_t)1 << newPower;
       unsigned long newMask = (unsigned long)newSize - 1;
-
-      /* Detect and prevent integer overflow */
-      if (newSize > (size_t)(-1) / sizeof(NAMED *)) {
-        return NULL;
-      }
-
       size_t tsize = newSize * sizeof(NAMED *);
-      NAMED **newV = table->mem->malloc_fcn(tsize);
+      NAMED **newV = (NAMED **)table->mem->malloc_fcn(tsize);
       if (!newV)
         return NULL;
       memset(newV, 0, tsize);
@@ -7044,7 +6365,7 @@
       }
     }
   }
-  table->v[i] = table->mem->malloc_fcn(createSize);
+  table->v[i] = (NAMED *)table->mem->malloc_fcn(createSize);
   if (!table->v[i])
     return NULL;
   memset(table->v[i], 0, createSize);
@@ -7081,7 +6402,7 @@
 static void FASTCALL hashTableIterInit(HASH_TABLE_ITER *iter,
                                        const HASH_TABLE *table) {
   iter->p = table->v;
-  iter->end = iter->p ? iter->p + table->size : NULL;
+  iter->end = iter->p + table->size;
 }
 
 static NAMED *FASTCALL hashTableIterNext(HASH_TABLE_ITER *iter) {
@@ -7323,7 +6644,7 @@
     if (bytesToAllocate == 0)
       return XML_FALSE;
 
-    tem = pool->mem->malloc_fcn(bytesToAllocate);
+    tem = (BLOCK *)pool->mem->malloc_fcn(bytesToAllocate);
     if (!tem)
       return XML_FALSE;
     tem->size = blockSize;
@@ -7353,20 +6674,6 @@
   if (dtd->scaffCount >= dtd->scaffSize) {
     CONTENT_SCAFFOLD *temp;
     if (dtd->scaffold) {
-      /* Detect and prevent integer overflow */
-      if (dtd->scaffSize > UINT_MAX / 2u) {
-        return -1;
-      }
-      /* Detect and prevent integer overflow.
-       * The preprocessor guard addresses the "always false" warning
-       * from -Wtype-limits on platforms where
-       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-      if (dtd->scaffSize > (size_t)(-1) / 2u / sizeof(CONTENT_SCAFFOLD)) {
-        return -1;
-      }
-#endif
-
       temp = (CONTENT_SCAFFOLD *)REALLOC(
           parser, dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));
       if (temp == NULL)
@@ -7398,129 +6705,53 @@
   return next;
 }
 
-static XML_Content *build_model(XML_Parser parser) {
-  /* Function build_model transforms the existing parser->m_dtd->scaffold
-   * array of CONTENT_SCAFFOLD tree nodes into a new array of
-   * XML_Content tree nodes followed by a gapless list of zero-terminated
-   * strings. */
+static void build_node(XML_Parser parser, int src_node, XML_Content *dest,
+                       XML_Content **contpos, XML_Char **strpos) {
   DTD *const dtd = parser->m_dtd; /* save one level of indirection */
-  XML_Content *ret;
-  XML_Char *str; /* the current string writing location */
-
-  /* Detect and prevent integer overflow.
-   * The preprocessor guard addresses the "always false" warning
-   * from -Wtype-limits on platforms where
-   * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */
-#if UINT_MAX >= SIZE_MAX
-  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {
-    return NULL;
-  }
-  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {
-    return NULL;
-  }
-#endif
-  if (dtd->scaffCount * sizeof(XML_Content) >
-      (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {
-    return NULL;
+  dest->type = dtd->scaffold[src_node].type;
+  dest->quant = dtd->scaffold[src_node].quant;
+  if (dest->type == XML_CTYPE_NAME) {
+    const XML_Char *src;
+    dest->name = *strpos;
+    src = dtd->scaffold[src_node].name;
+    for (;;) {
+      *(*strpos)++ = *src;
+      if (!*src)
+        break;
+      src++;
+    }
+    dest->numchildren = 0;
+    dest->children = NULL;
+  } else {
+    unsigned int i;
+    int cn;
+    dest->numchildren = dtd->scaffold[src_node].childcnt;
+    dest->children = *contpos;
+    *contpos += dest->numchildren;
+    for (i = 0, cn = dtd->scaffold[src_node].firstchild; i < dest->numchildren;
+         i++, cn = dtd->scaffold[cn].nextsib) {
+      build_node(parser, cn, &(dest->children[i]), contpos, strpos);
+    }
+    dest->name = NULL;
   }
+}
 
-  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content) +
-                            (dtd->contentStringLen * sizeof(XML_Char)));
+static XML_Content *build_model(XML_Parser parser) {
+  DTD *const dtd = parser->m_dtd; /* save one level of indirection */
+  XML_Content *ret;
+  XML_Content *cpos;
+  XML_Char *str;
+  int allocsize = (dtd->scaffCount * sizeof(XML_Content) +
+                   (dtd->contentStringLen * sizeof(XML_Char)));
 
   ret = (XML_Content *)MALLOC(parser, allocsize);
   if (!ret)
     return NULL;
 
-  /* What follows is an iterative implementation (of what was previously done
-   * recursively in a dedicated function called "build_node".  The old recursive
-   * build_node could be forced into stack exhaustion from input as small as a
-   * few megabyte, and so that was a security issue.  Hence, a function call
-   * stack is avoided now by resolving recursion.)
-   *
-   * The iterative approach works as follows:
-   *
-   * - We have two writing pointers, both walking up the result array; one does
-   *   the work, the other creates "jobs" for its colleague to do, and leads
-   *   the way:
-   *
-   *   - The faster one, pointer jobDest, always leads and writes "what job
-   *     to do" by the other, once they reach that place in the
-   *     array: leader "jobDest" stores the source node array index (relative
-   *     to array dtd->scaffold) in field "numchildren".
-   *
-   *   - The slower one, pointer dest, looks at the value stored in the
-   *     "numchildren" field (which actually holds a source node array index
-   *     at that time) and puts the real data from dtd->scaffold in.
-   *
-   * - Before the loop starts, jobDest writes source array index 0
-   *   (where the root node is located) so that dest will have something to do
-   *   when it starts operation.
-   *
-   * - Whenever nodes with children are encountered, jobDest appends
-   *   them as new jobs, in order.  As a result, tree node siblings are
-   *   adjacent in the resulting array, for example:
-   *
-   *     [0] root, has two children
-   *       [1] first child of 0, has three children
-   *         [3] first child of 1, does not have children
-   *         [4] second child of 1, does not have children
-   *         [5] third child of 1, does not have children
-   *       [2] second child of 0, does not have children
-   *
-   *   Or (the same data) presented in flat array view:
-   *
-   *     [0] root, has two children
-   *
-   *     [1] first child of 0, has three children
-   *     [2] second child of 0, does not have children
-   *
-   *     [3] first child of 1, does not have children
-   *     [4] second child of 1, does not have children
-   *     [5] third child of 1, does not have children
-   *
-   * - The algorithm repeats until all target array indices have been processed.
-   */
-  XML_Content *dest = ret; /* tree node writing location, moves upwards */
-  XML_Content *const destLimit = &ret[dtd->scaffCount];
-  XML_Content *jobDest = ret; /* next free writing location in target array */
-  str = (XML_Char *)&ret[dtd->scaffCount];
-
-  /* Add the starting job, the root node (index 0) of the source tree  */
-  (jobDest++)->numchildren = 0;
-
-  for (; dest < destLimit; dest++) {
-    /* Retrieve source tree array index from job storage */
-    const int src_node = (int)dest->numchildren;
-
-    /* Convert item */
-    dest->type = dtd->scaffold[src_node].type;
-    dest->quant = dtd->scaffold[src_node].quant;
-    if (dest->type == XML_CTYPE_NAME) {
-      const XML_Char *src;
-      dest->name = str;
-      src = dtd->scaffold[src_node].name;
-      for (;;) {
-        *str++ = *src;
-        if (!*src)
-          break;
-        src++;
-      }
-      dest->numchildren = 0;
-      dest->children = NULL;
-    } else {
-      unsigned int i;
-      int cn;
-      dest->name = NULL;
-      dest->numchildren = dtd->scaffold[src_node].childcnt;
-      dest->children = jobDest;
-
-      /* Append scaffold indices of children to array */
-      for (i = 0, cn = dtd->scaffold[src_node].firstchild;
-           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib)
-        (jobDest++)->numchildren = (unsigned int)cn;
-    }
-  }
+  str = (XML_Char *)(&ret[dtd->scaffCount]);
+  cpos = &ret[1];
 
+  build_node(parser, 0, ret, &cpos, &str);
   return ret;
 }
 
@@ -7548,7 +6779,7 @@
 
 static XML_Char *copyString(const XML_Char *s,
                             const XML_Memory_Handling_Suite *memsuite) {
-  size_t charsRequired = 0;
+  int charsRequired = 0;
   XML_Char *result;
 
   /* First determine how long the string is */
@@ -7566,748 +6797,3 @@
   memcpy(result, s, charsRequired * sizeof(XML_Char));
   return result;
 }
-
-#ifdef XML_DTD
-
-static float accountingGetCurrentAmplification(XML_Parser rootParser) {
-  const XmlBigCount countBytesOutput =
-      rootParser->m_accounting.countBytesDirect +
-      rootParser->m_accounting.countBytesIndirect;
-  const float amplificationFactor =
-      rootParser->m_accounting.countBytesDirect
-          ? (countBytesOutput /
-             (float)(rootParser->m_accounting.countBytesDirect))
-          : 1.0f;
-  assert(!rootParser->m_parentParser);
-  return amplificationFactor;
-}
-
-static void accountingReportStats(XML_Parser originParser, const char *epilog) {
-  const XML_Parser rootParser = getRootParserOf(originParser, NULL);
-  assert(!rootParser->m_parentParser);
-
-  if (rootParser->m_accounting.debugLevel < 1) {
-    return;
-  }
-
-  const float amplificationFactor =
-      accountingGetCurrentAmplification(rootParser);
-  fprintf(stderr,
-          "expat: Accounting(%p): Direct " EXPAT_FMT_ULL(
-              "10") ", indirect " EXPAT_FMT_ULL("10") ", amplification %8.2f%s",
-          (void *)rootParser, rootParser->m_accounting.countBytesDirect,
-          rootParser->m_accounting.countBytesIndirect,
-          (double)amplificationFactor, epilog);
-}
-
-static void accountingOnAbort(XML_Parser originParser) {
-  accountingReportStats(originParser, " ABORTING\n");
-}
-
-static void accountingReportDiff(XML_Parser rootParser,
-                                 unsigned int levelsAwayFromRootParser,
-                                 const char *before, const char *after,
-                                 ptrdiff_t bytesMore, int source_line,
-                                 enum XML_Account account) {
-  assert(!rootParser->m_parentParser);
-
-  fprintf(stderr,
-          " (+" EXPAT_FMT_PTRDIFF_T("6") " bytes %s|%d, xmlparse.c:%d) %*s\"",
-          bytesMore, (account == XML_ACCOUNT_DIRECT) ? "DIR" : "EXP",
-          levelsAwayFromRootParser, source_line, 10, "");
-
-  const char ellipis[] = "[..]";
-  const size_t ellipsisLength = sizeof(ellipis) /* because compile-time */ - 1;
-  const unsigned int contextLength = 10;
-
-  /* Note: Performance is of no concern here */
-  const char *walker = before;
-  if ((rootParser->m_accounting.debugLevel >= 3) ||
-      (after - before) <=
-          (ptrdiff_t)(contextLength + ellipsisLength + contextLength)) {
-    for (; walker < after; walker++) {
-      fprintf(stderr, "%s", unsignedCharToPrintable(walker[0]));
-    }
-  } else {
-    for (; walker < before + contextLength; walker++) {
-      fprintf(stderr, "%s", unsignedCharToPrintable(walker[0]));
-    }
-    fprintf(stderr, ellipis);
-    walker = after - contextLength;
-    for (; walker < after; walker++) {
-      fprintf(stderr, "%s", unsignedCharToPrintable(walker[0]));
-    }
-  }
-  fprintf(stderr, "\"\n");
-}
-
-static XML_Bool accountingDiffTolerated(XML_Parser originParser, int tok,
-                                        const char *before, const char *after,
-                                        int source_line,
-                                        enum XML_Account account) {
-  /* Note: We need to check the token type *first* to be sure that
-   *       we can even access variable <after>, safely.
-   *       E.g. for XML_TOK_NONE <after> may hold an invalid pointer. */
-  switch (tok) {
-  case XML_TOK_INVALID:
-  case XML_TOK_PARTIAL:
-  case XML_TOK_PARTIAL_CHAR:
-  case XML_TOK_NONE:
-    return XML_TRUE;
-  }
-
-  if (account == XML_ACCOUNT_NONE)
-    return XML_TRUE; /* because these bytes have been accounted for, already */
-
-  unsigned int levelsAwayFromRootParser;
-  const XML_Parser rootParser =
-      getRootParserOf(originParser, &levelsAwayFromRootParser);
-  assert(!rootParser->m_parentParser);
-
-  const int isDirect =
-      (account == XML_ACCOUNT_DIRECT) && (originParser == rootParser);
-  const ptrdiff_t bytesMore = after - before;
-
-  XmlBigCount *const additionTarget =
-      isDirect ? &rootParser->m_accounting.countBytesDirect
-               : &rootParser->m_accounting.countBytesIndirect;
-
-  /* Detect and avoid integer overflow */
-  if (*additionTarget > (XmlBigCount)(-1) - (XmlBigCount)bytesMore)
-    return XML_FALSE;
-  *additionTarget += bytesMore;
-
-  const XmlBigCount countBytesOutput =
-      rootParser->m_accounting.countBytesDirect +
-      rootParser->m_accounting.countBytesIndirect;
-  const float amplificationFactor =
-      accountingGetCurrentAmplification(rootParser);
-  const XML_Bool tolerated =
-      (countBytesOutput < rootParser->m_accounting.activationThresholdBytes) ||
-      (amplificationFactor <=
-       rootParser->m_accounting.maximumAmplificationFactor);
-
-  if (rootParser->m_accounting.debugLevel >= 2) {
-    accountingReportStats(rootParser, "");
-    accountingReportDiff(rootParser, levelsAwayFromRootParser, before, after,
-                         bytesMore, source_line, account);
-  }
-
-  return tolerated;
-}
-
-unsigned long long testingAccountingGetCountBytesDirect(XML_Parser parser) {
-  if (!parser)
-    return 0;
-  return parser->m_accounting.countBytesDirect;
-}
-
-unsigned long long testingAccountingGetCountBytesIndirect(XML_Parser parser) {
-  if (!parser)
-    return 0;
-  return parser->m_accounting.countBytesIndirect;
-}
-
-static void entityTrackingReportStats(XML_Parser rootParser, ENTITY *entity,
-                                      const char *action, int sourceLine) {
-  assert(!rootParser->m_parentParser);
-  if (rootParser->m_entity_stats.debugLevel < 1)
-    return;
-
-#if defined(XML_UNICODE)
-  const char *const entityName = "[..]";
-#else
-  const char *const entityName = entity->name;
-#endif
-
-  fprintf(stderr,
-          "expat: Entities(%p): Count %9d, depth %2d/%2d %*s%s%s; %s length %d "
-          "(xmlparse.c:%d)\n",
-          (void *)rootParser, rootParser->m_entity_stats.countEverOpened,
-          rootParser->m_entity_stats.currentDepth,
-          rootParser->m_entity_stats.maximumDepthSeen,
-          (rootParser->m_entity_stats.currentDepth - 1) * 2, "",
-          entity->is_param ? "%" : "&", entityName, action, entity->textLen,
-          sourceLine);
-}
-
-static void entityTrackingOnOpen(XML_Parser originParser, ENTITY *entity,
-                                 int sourceLine) {
-  const XML_Parser rootParser = getRootParserOf(originParser, NULL);
-  assert(!rootParser->m_parentParser);
-
-  rootParser->m_entity_stats.countEverOpened++;
-  rootParser->m_entity_stats.currentDepth++;
-  if (rootParser->m_entity_stats.currentDepth >
-      rootParser->m_entity_stats.maximumDepthSeen) {
-    rootParser->m_entity_stats.maximumDepthSeen++;
-  }
-
-  entityTrackingReportStats(rootParser, entity, "OPEN ", sourceLine);
-}
-
-static void entityTrackingOnClose(XML_Parser originParser, ENTITY *entity,
-                                  int sourceLine) {
-  const XML_Parser rootParser = getRootParserOf(originParser, NULL);
-  assert(!rootParser->m_parentParser);
-
-  entityTrackingReportStats(rootParser, entity, "CLOSE", sourceLine);
-  rootParser->m_entity_stats.currentDepth--;
-}
-
-static XML_Parser getRootParserOf(XML_Parser parser,
-                                  unsigned int *outLevelDiff) {
-  XML_Parser rootParser = parser;
-  unsigned int stepsTakenUpwards = 0;
-  while (rootParser->m_parentParser) {
-    rootParser = rootParser->m_parentParser;
-    stepsTakenUpwards++;
-  }
-  assert(!rootParser->m_parentParser);
-  if (outLevelDiff != NULL) {
-    *outLevelDiff = stepsTakenUpwards;
-  }
-  return rootParser;
-}
-
-const char *unsignedCharToPrintable(unsigned char c) {
-  switch (c) {
-  case 0:
-    return "\\0";
-  case 1:
-    return "\\x1";
-  case 2:
-    return "\\x2";
-  case 3:
-    return "\\x3";
-  case 4:
-    return "\\x4";
-  case 5:
-    return "\\x5";
-  case 6:
-    return "\\x6";
-  case 7:
-    return "\\x7";
-  case 8:
-    return "\\x8";
-  case 9:
-    return "\\t";
-  case 10:
-    return "\\n";
-  case 11:
-    return "\\xB";
-  case 12:
-    return "\\xC";
-  case 13:
-    return "\\r";
-  case 14:
-    return "\\xE";
-  case 15:
-    return "\\xF";
-  case 16:
-    return "\\x10";
-  case 17:
-    return "\\x11";
-  case 18:
-    return "\\x12";
-  case 19:
-    return "\\x13";
-  case 20:
-    return "\\x14";
-  case 21:
-    return "\\x15";
-  case 22:
-    return "\\x16";
-  case 23:
-    return "\\x17";
-  case 24:
-    return "\\x18";
-  case 25:
-    return "\\x19";
-  case 26:
-    return "\\x1A";
-  case 27:
-    return "\\x1B";
-  case 28:
-    return "\\x1C";
-  case 29:
-    return "\\x1D";
-  case 30:
-    return "\\x1E";
-  case 31:
-    return "\\x1F";
-  case 32:
-    return " ";
-  case 33:
-    return "!";
-  case 34:
-    return "\\\"";
-  case 35:
-    return "#";
-  case 36:
-    return "$";
-  case 37:
-    return "%";
-  case 38:
-    return "&";
-  case 39:
-    return "'";
-  case 40:
-    return "(";
-  case 41:
-    return ")";
-  case 42:
-    return "*";
-  case 43:
-    return "+";
-  case 44:
-    return ",";
-  case 45:
-    return "-";
-  case 46:
-    return ".";
-  case 47:
-    return "/";
-  case 48:
-    return "0";
-  case 49:
-    return "1";
-  case 50:
-    return "2";
-  case 51:
-    return "3";
-  case 52:
-    return "4";
-  case 53:
-    return "5";
-  case 54:
-    return "6";
-  case 55:
-    return "7";
-  case 56:
-    return "8";
-  case 57:
-    return "9";
-  case 58:
-    return ":";
-  case 59:
-    return ";";
-  case 60:
-    return "<";
-  case 61:
-    return "=";
-  case 62:
-    return ">";
-  case 63:
-    return "?";
-  case 64:
-    return "@";
-  case 65:
-    return "A";
-  case 66:
-    return "B";
-  case 67:
-    return "C";
-  case 68:
-    return "D";
-  case 69:
-    return "E";
-  case 70:
-    return "F";
-  case 71:
-    return "G";
-  case 72:
-    return "H";
-  case 73:
-    return "I";
-  case 74:
-    return "J";
-  case 75:
-    return "K";
-  case 76:
-    return "L";
-  case 77:
-    return "M";
-  case 78:
-    return "N";
-  case 79:
-    return "O";
-  case 80:
-    return "P";
-  case 81:
-    return "Q";
-  case 82:
-    return "R";
-  case 83:
-    return "S";
-  case 84:
-    return "T";
-  case 85:
-    return "U";
-  case 86:
-    return "V";
-  case 87:
-    return "W";
-  case 88:
-    return "X";
-  case 89:
-    return "Y";
-  case 90:
-    return "Z";
-  case 91:
-    return "[";
-  case 92:
-    return "\\\\";
-  case 93:
-    return "]";
-  case 94:
-    return "^";
-  case 95:
-    return "_";
-  case 96:
-    return "`";
-  case 97:
-    return "a";
-  case 98:
-    return "b";
-  case 99:
-    return "c";
-  case 100:
-    return "d";
-  case 101:
-    return "e";
-  case 102:
-    return "f";
-  case 103:
-    return "g";
-  case 104:
-    return "h";
-  case 105:
-    return "i";
-  case 106:
-    return "j";
-  case 107:
-    return "k";
-  case 108:
-    return "l";
-  case 109:
-    return "m";
-  case 110:
-    return "n";
-  case 111:
-    return "o";
-  case 112:
-    return "p";
-  case 113:
-    return "q";
-  case 114:
-    return "r";
-  case 115:
-    return "s";
-  case 116:
-    return "t";
-  case 117:
-    return "u";
-  case 118:
-    return "v";
-  case 119:
-    return "w";
-  case 120:
-    return "x";
-  case 121:
-    return "y";
-  case 122:
-    return "z";
-  case 123:
-    return "{";
-  case 124:
-    return "|";
-  case 125:
-    return "}";
-  case 126:
-    return "~";
-  case 127:
-    return "\\x7F";
-  case 128:
-    return "\\x80";
-  case 129:
-    return "\\x81";
-  case 130:
-    return "\\x82";
-  case 131:
-    return "\\x83";
-  case 132:
-    return "\\x84";
-  case 133:
-    return "\\x85";
-  case 134:
-    return "\\x86";
-  case 135:
-    return "\\x87";
-  case 136:
-    return "\\x88";
-  case 137:
-    return "\\x89";
-  case 138:
-    return "\\x8A";
-  case 139:
-    return "\\x8B";
-  case 140:
-    return "\\x8C";
-  case 141:
-    return "\\x8D";
-  case 142:
-    return "\\x8E";
-  case 143:
-    return "\\x8F";
-  case 144:
-    return "\\x90";
-  case 145:
-    return "\\x91";
-  case 146:
-    return "\\x92";
-  case 147:
-    return "\\x93";
-  case 148:
-    return "\\x94";
-  case 149:
-    return "\\x95";
-  case 150:
-    return "\\x96";
-  case 151:
-    return "\\x97";
-  case 152:
-    return "\\x98";
-  case 153:
-    return "\\x99";
-  case 154:
-    return "\\x9A";
-  case 155:
-    return "\\x9B";
-  case 156:
-    return "\\x9C";
-  case 157:
-    return "\\x9D";
-  case 158:
-    return "\\x9E";
-  case 159:
-    return "\\x9F";
-  case 160:
-    return "\\xA0";
-  case 161:
-    return "\\xA1";
-  case 162:
-    return "\\xA2";
-  case 163:
-    return "\\xA3";
-  case 164:
-    return "\\xA4";
-  case 165:
-    return "\\xA5";
-  case 166:
-    return "\\xA6";
-  case 167:
-    return "\\xA7";
-  case 168:
-    return "\\xA8";
-  case 169:
-    return "\\xA9";
-  case 170:
-    return "\\xAA";
-  case 171:
-    return "\\xAB";
-  case 172:
-    return "\\xAC";
-  case 173:
-    return "\\xAD";
-  case 174:
-    return "\\xAE";
-  case 175:
-    return "\\xAF";
-  case 176:
-    return "\\xB0";
-  case 177:
-    return "\\xB1";
-  case 178:
-    return "\\xB2";
-  case 179:
-    return "\\xB3";
-  case 180:
-    return "\\xB4";
-  case 181:
-    return "\\xB5";
-  case 182:
-    return "\\xB6";
-  case 183:
-    return "\\xB7";
-  case 184:
-    return "\\xB8";
-  case 185:
-    return "\\xB9";
-  case 186:
-    return "\\xBA";
-  case 187:
-    return "\\xBB";
-  case 188:
-    return "\\xBC";
-  case 189:
-    return "\\xBD";
-  case 190:
-    return "\\xBE";
-  case 191:
-    return "\\xBF";
-  case 192:
-    return "\\xC0";
-  case 193:
-    return "\\xC1";
-  case 194:
-    return "\\xC2";
-  case 195:
-    return "\\xC3";
-  case 196:
-    return "\\xC4";
-  case 197:
-    return "\\xC5";
-  case 198:
-    return "\\xC6";
-  case 199:
-    return "\\xC7";
-  case 200:
-    return "\\xC8";
-  case 201:
-    return "\\xC9";
-  case 202:
-    return "\\xCA";
-  case 203:
-    return "\\xCB";
-  case 204:
-    return "\\xCC";
-  case 205:
-    return "\\xCD";
-  case 206:
-    return "\\xCE";
-  case 207:
-    return "\\xCF";
-  case 208:
-    return "\\xD0";
-  case 209:
-    return "\\xD1";
-  case 210:
-    return "\\xD2";
-  case 211:
-    return "\\xD3";
-  case 212:
-    return "\\xD4";
-  case 213:
-    return "\\xD5";
-  case 214:
-    return "\\xD6";
-  case 215:
-    return "\\xD7";
-  case 216:
-    return "\\xD8";
-  case 217:
-    return "\\xD9";
-  case 218:
-    return "\\xDA";
-  case 219:
-    return "\\xDB";
-  case 220:
-    return "\\xDC";
-  case 221:
-    return "\\xDD";
-  case 222:
-    return "\\xDE";
-  case 223:
-    return "\\xDF";
-  case 224:
-    return "\\xE0";
-  case 225:
-    return "\\xE1";
-  case 226:
-    return "\\xE2";
-  case 227:
-    return "\\xE3";
-  case 228:
-    return "\\xE4";
-  case 229:
-    return "\\xE5";
-  case 230:
-    return "\\xE6";
-  case 231:
-    return "\\xE7";
-  case 232:
-    return "\\xE8";
-  case 233:
-    return "\\xE9";
-  case 234:
-    return "\\xEA";
-  case 235:
-    return "\\xEB";
-  case 236:
-    return "\\xEC";
-  case 237:
-    return "\\xED";
-  case 238:
-    return "\\xEE";
-  case 239:
-    return "\\xEF";
-  case 240:
-    return "\\xF0";
-  case 241:
-    return "\\xF1";
-  case 242:
-    return "\\xF2";
-  case 243:
-    return "\\xF3";
-  case 244:
-    return "\\xF4";
-  case 245:
-    return "\\xF5";
-  case 246:
-    return "\\xF6";
-  case 247:
-    return "\\xF7";
-  case 248:
-    return "\\xF8";
-  case 249:
-    return "\\xF9";
-  case 250:
-    return "\\xFA";
-  case 251:
-    return "\\xFB";
-  case 252:
-    return "\\xFC";
-  case 253:
-    return "\\xFD";
-  case 254:
-    return "\\xFE";
-  case 255:
-    return "\\xFF";
-  default:
-    assert(0); /* never gets here */
-    return "dead code";
-  }
-  assert(0); /* never gets here */
-}
-
-#endif /* XML_DTD */
-
-static unsigned long getDebugLevel(const char *variableName,
-                                   unsigned long defaultDebugLevel) {
-  const char *const valueOrNull = getenv(variableName);
-  if (valueOrNull == NULL) {
-    return defaultDebugLevel;
-  }
-  const char *const value = valueOrNull;
-
-  errno = 0;
-  char *afterValue = (char *)value;
-  unsigned long debugLevel = strtoul(value, &afterValue, 10);
-  if ((errno != 0) || (afterValue[0] != '\0')) {
-    errno = 0;
-    return defaultDebugLevel;
-  }
-
-  return debugLevel;
-}
