--- /home/V1SCAN/CWE-611/FormattedUsed/xmlparse-mame.c	2023-12-12 05:05:51.147936919 +0900
+++ /home/V1SCAN/CWE-611/FormattedPatch/NEW##CVE-2018-20843##0##libexpat@@libexpat##xmlparse.c	2023-12-12 05:05:51.612691088 +0900
@@ -1,4 +1,4 @@
-/* 5cd169f2942b85c05e0b1b96f9990f91ac3d07e470ad7ce906ac8590c8ed4f35 (2.2.10+)
+/* 19ac4776051591216f1874e34ee99b6a43a3784c8bd7d70efeb9258dd22b906a (2.2.6+)
                             __  __            _
                          ___\ \/ /_ __   __ _| |_
                         / _ \\  /| '_ \ / _` | __|
@@ -34,31 +34,13 @@
 #define _GNU_SOURCE 1 /* syscall prototype */
 #endif
 
-#ifdef _WIN32
-/* force stdlib to define rand_s() */
-#if !defined(_CRT_RAND_S)
-#define _CRT_RAND_S
-#endif
-#endif
-
 #include <assert.h>
 #include <limits.h> /* UINT_MAX */
 #include <stddef.h>
 #include <stdio.h>  /* fprintf */
-#include <stdlib.h> /* getenv, rand_s */
+#include <stdlib.h> /* getenv */
 #include <string.h> /* memset(), memcpy() */
 
-#if defined(_WIN32) && defined(_MSC_VER) && (_MSC_VER < 1600)
-/* vs2008/9.0 and earlier lack stdint.h; _MSC_VER 1600 is vs2010/10.0 */
-#if defined(_WIN64)
-typedef unsigned __int64 uintptr_t;
-#else
-typedef unsigned __int32 uintptr_t;
-#endif
-#else
-#include <stdint.h> /* uintptr_t */
-#endif
-
 #ifdef _WIN32
 #define getpid GetCurrentProcessId
 #else
@@ -110,14 +92,14 @@
     enabled.  For end user security, that is probably not what you want. \
     \
     Your options include: \
-      * Linux >=3.17 + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \
-      * Linux >=3.17 + glibc (including <2.25) (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \
+      * Linux + glibc >=2.25 (getrandom): HAVE_GETRANDOM, \
+      * Linux + glibc <2.25 (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, \
       * BSD / macOS >=10.7 (arc4random_buf): HAVE_ARC4RANDOM_BUF, \
-      * BSD / macOS (including <10.7) (arc4random): HAVE_ARC4RANDOM, \
+      * BSD / macOS <10.7 (arc4random): HAVE_ARC4RANDOM, \
       * libbsd (arc4random_buf): HAVE_ARC4RANDOM_BUF + HAVE_LIBBSD, \
       * libbsd (arc4random): HAVE_ARC4RANDOM + HAVE_LIBBSD, \
-      * Linux (including <3.17) / BSD / macOS (including <10.7) (/dev/urandom): XML_DEV_URANDOM, \
-      * Windows >=Vista (rand_s): _WIN32. \
+      * Linux / BSD / macOS (/dev/urandom): XML_DEV_URANDOM \
+      * Windows (RtlGenRandom): _WIN32. \
     \
     If insist on not using any of these, bypass this error by defining \
     XML_POOR_ENTROPY; you have been warned. \
@@ -132,7 +114,9 @@
 #define XmlGetInternalEncoding XmlGetUtf16InternalEncoding
 #define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS
 #define XmlEncode XmlUtf16Encode
-#define MUST_CONVERT(enc, s) (!(enc)->isUtf16 || (((uintptr_t)(s)) & 1))
+/* Using pointer subtraction to convert to integer type. */
+#define MUST_CONVERT(enc, s)                                                   \
+  (!(enc)->isUtf16 || (((char *)(s) - (char *)NULL) & 1))
 typedef unsigned short ICHAR;
 #else
 #define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX
@@ -412,7 +396,7 @@
 static enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,
                                const char *s, const char *end, int tok,
                                const char *next, const char **nextPtr,
-                               XML_Bool haveMore, XML_Bool allowClosingDoctype);
+                               XML_Bool haveMore);
 static enum XML_Error processInternalEntity(XML_Parser parser, ENTITY *entity,
                                             XML_Bool betweenDecl);
 static enum XML_Error doContent(XML_Parser parser, int startTagLevel,
@@ -741,36 +725,32 @@
 
 #ifdef _WIN32
 
-/* Provide declaration of rand_s() for MinGW-32 (not 64, which has it),
-   as it didn't declare it in its header prior to version 5.3.0 of its
-   runtime package (mingwrt, containing stdlib.h).  The upstream fix
-   was introduced at https://osdn.net/projects/mingw/ticket/39658 . */
-#if defined(__MINGW32__) && defined(__MINGW32_VERSION) &&                      \
-    __MINGW32_VERSION < 5003000L && !defined(__MINGW64_VERSION_MAJOR)
-__declspec(dllimport) int rand_s(unsigned int *);
-#endif
+typedef BOOLEAN(APIENTRY *RTLGENRANDOM_FUNC)(PVOID, ULONG);
+HMODULE _Expat_LoadLibrary(LPCTSTR filename); /* see loadlibrary.c */
 
-/* Obtain entropy on Windows using the rand_s() function which
- * generates cryptographically secure random numbers.  Internally it
- * uses RtlGenRandom API which is present in Windows XP and later.
+/* Obtain entropy on Windows XP / Windows Server 2003 and later.
+ * Hint on RtlGenRandom and the following article from libsodium.
+ *
+ * Michael Howard: Cryptographically Secure Random number on Windows without
+ * using CryptoAPI
+ * https://blogs.msdn.microsoft.com/michael_howard/2005/01/14/cryptographically-secure-random-number-on-windows-without-using-cryptoapi/
  */
-static int writeRandomBytes_rand_s(void *target, size_t count) {
-  size_t bytesWrittenTotal = 0;
-
-  while (bytesWrittenTotal < count) {
-    unsigned int random32 = 0;
-    size_t i = 0;
-
-    if (rand_s(&random32))
-      return 0; /* failure */
+static int writeRandomBytes_RtlGenRandom(void *target, size_t count) {
+  int success = 0; /* full count bytes written? */
+  const HMODULE advapi32 = _Expat_LoadLibrary(TEXT("ADVAPI32.DLL"));
 
-    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);
-         i++, bytesWrittenTotal++) {
-      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));
-      ((uint8_t *)target)[bytesWrittenTotal] = random8;
+  if (advapi32) {
+    const RTLGENRANDOM_FUNC RtlGenRandom =
+        (RTLGENRANDOM_FUNC)GetProcAddress(advapi32, "SystemFunction036");
+    if (RtlGenRandom) {
+      if (RtlGenRandom((PVOID)target, (ULONG)count) == TRUE) {
+        success = 1;
+      }
     }
+    FreeLibrary(advapi32);
   }
-  return 1; /* success */
+
+  return success;
 }
 
 #endif /* _WIN32 */
@@ -824,8 +804,8 @@
 #else
   /* Try high quality providers first .. */
 #ifdef _WIN32
-  if (writeRandomBytes_rand_s((void *)&entropy, sizeof(entropy))) {
-    return ENTROPY_DEBUG("rand_s", entropy);
+  if (writeRandomBytes_RtlGenRandom((void *)&entropy, sizeof(entropy))) {
+    return ENTROPY_DEBUG("RtlGenRandom", entropy);
   }
 #elif defined(HAVE_GETRANDOM) || defined(HAVE_SYSCALL_GETRANDOM)
   if (writeRandomBytes_getrandom_nonblock((void *)&entropy, sizeof(entropy))) {
@@ -1403,7 +1383,6 @@
   parser->m_useForeignDTD = useDTD;
   return XML_ERROR_NONE;
 #else
-  UNUSED_P(useDTD);
   return XML_ERROR_FEATURE_REQUIRES_XML_DTD;
 #endif
 }
@@ -1762,7 +1741,7 @@
     int nLeftOver;
     enum XML_Status result;
     /* Detect overflow (a+b > MAX <==> b > MAX-a) */
-    if ((XML_Size)len > ((XML_Size)-1) / 2 - parser->m_parseEndByteIndex) {
+    if (len > ((XML_Size)-1) / 2 - parser->m_parseEndByteIndex) {
       parser->m_errorCode = XML_ERROR_NO_MEMORY;
       parser->m_eventPtr = parser->m_eventEndPtr = NULL;
       parser->m_processor = errorProcessor;
@@ -1979,6 +1958,10 @@
       parser->m_bufferLim = newBuf + bufferSize;
 #ifdef XML_CONTEXT_BYTES
       if (parser->m_bufferPtr) {
+        int keep =
+            (int)EXPAT_SAFE_PTR_DIFF(parser->m_bufferPtr, parser->m_buffer);
+        if (keep > XML_CONTEXT_BYTES)
+          keep = XML_CONTEXT_BYTES;
         memcpy(newBuf, &parser->m_bufferPtr[-keep],
                EXPAT_SAFE_PTR_DIFF(parser->m_bufferEnd, parser->m_bufferPtr) +
                    keep);
@@ -2130,7 +2113,7 @@
   (void)offset;
   (void)size;
 #endif /* defined XML_CONTEXT_BYTES */
-  return (const char *)0;
+  return (char *)0;
 }
 
 XML_Size XMLCALL XML_GetCurrentLineNumber(XML_Parser parser) {
@@ -2288,6 +2271,7 @@
 }
 
 const XML_LChar *XMLCALL XML_ExpatVersion(void) {
+
   /* V1 is used to string-ize the version number. However, it would
      string-ize the actual version macro *names* unless we get them
      substituted before being passed to V1. CPP is defined to expand
@@ -2818,13 +2802,8 @@
           parser->m_freeBindingList = b;
           b->prefix->binding = b->prevPrefixBinding;
         }
-        if ((parser->m_tagLevel == 0) &&
-            (parser->m_parsingStatus.parsing != XML_FINISHED)) {
-          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)
-            parser->m_processor = epilogProcessor;
-          else
-            return epilogProcessor(parser, next, end, nextPtr);
-        }
+        if (parser->m_tagLevel == 0)
+          return epilogProcessor(parser, next, end, nextPtr);
       }
       break;
     case XML_TOK_CHAR_REF: {
@@ -3417,6 +3396,7 @@
 
   if (prefix->name && prefix->name[0] == XML_T(ASCII_x) &&
       prefix->name[1] == XML_T(ASCII_m) && prefix->name[2] == XML_T(ASCII_l)) {
+
     /* Not allowed to bind xmlns */
     if (prefix->name[3] == XML_T(ASCII_n) &&
         prefix->name[4] == XML_T(ASCII_s) && prefix->name[5] == XML_T('\0'))
@@ -3535,7 +3515,7 @@
   *startPtr = NULL;
 
   for (;;) {
-    const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */
+    const char *next;
     int tok = XmlCdataSectionTok(enc, s, end, &next);
     *eventEndPP = next;
     switch (tok) {
@@ -3654,7 +3634,7 @@
 static enum XML_Error doIgnoreSection(XML_Parser parser, const ENCODING *enc,
                                       const char **startPtr, const char *end,
                                       const char **nextPtr, XML_Bool haveMore) {
-  const char *next = *startPtr; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */
+  const char *next;
   int tok;
   const char *s = *startPtr;
   const char **eventPP;
@@ -4011,7 +3991,7 @@
 
   parser->m_processor = prologProcessor;
   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
-                  (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_TRUE);
+                  (XML_Bool)!parser->m_parsingStatus.finalBuffer);
 }
 
 static enum XML_Error PTRCALL entityValueProcessor(XML_Parser parser,
@@ -4056,14 +4036,13 @@
   const char *next = s;
   int tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
-                  (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_TRUE);
+                  (XML_Bool)!parser->m_parsingStatus.finalBuffer);
 }
 
 static enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,
                                const char *s, const char *end, int tok,
                                const char *next, const char **nextPtr,
-                               XML_Bool haveMore,
-                               XML_Bool allowClosingDoctype) {
+                               XML_Bool haveMore) {
 #ifdef XML_DTD
   static const XML_Char externalSubsetName[] = {ASCII_HASH, '\0'};
 #endif /* XML_DTD */
@@ -4239,11 +4218,6 @@
       }
       break;
     case XML_ROLE_DOCTYPE_CLOSE:
-      if (allowClosingDoctype != XML_TRUE) {
-        /* Must not close doctype from within expanded parameter entities */
-        return XML_ERROR_INVALID_TOKEN;
-      }
-
       if (parser->m_doctypeName) {
         parser->m_startDoctypeDeclHandler(
             parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,
@@ -4721,22 +4695,19 @@
     case XML_ROLE_GROUP_OPEN:
       if (parser->m_prologState.level >= parser->m_groupSize) {
         if (parser->m_groupSize) {
-          {
-            char *const new_connector = (char *)REALLOC(
-                parser, parser->m_groupConnector, parser->m_groupSize *= 2);
-            if (new_connector == NULL) {
-              parser->m_groupSize /= 2;
-              return XML_ERROR_NO_MEMORY;
-            }
-            parser->m_groupConnector = new_connector;
+          char *temp = (char *)REALLOC(parser, parser->m_groupConnector,
+                                       parser->m_groupSize *= 2);
+          if (temp == NULL) {
+            parser->m_groupSize /= 2;
+            return XML_ERROR_NO_MEMORY;
           }
-
+          parser->m_groupConnector = temp;
           if (dtd->scaffIndex) {
-            int *const new_scaff_index = (int *)REALLOC(
-                parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));
-            if (new_scaff_index == NULL)
+            int *temp = (int *)REALLOC(parser, dtd->scaffIndex,
+                                       parser->m_groupSize * sizeof(int));
+            if (temp == NULL)
               return XML_ERROR_NO_MEMORY;
-            dtd->scaffIndex = new_scaff_index;
+            dtd->scaffIndex = temp;
           }
         } else {
           parser->m_groupConnector =
@@ -4752,7 +4723,6 @@
         int myindex = nextScaffoldPart(parser);
         if (myindex < 0)
           return XML_ERROR_NO_MEMORY;
-        assert(dtd->scaffIndex != NULL);
         dtd->scaffIndex[dtd->scaffLevel] = myindex;
         dtd->scaffLevel++;
         dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
@@ -5137,8 +5107,8 @@
   openEntity->betweenDecl = betweenDecl;
   openEntity->internalEventPtr = NULL;
   openEntity->internalEventEndPtr = NULL;
-  textStart = (const char *)entity->textPtr;
-  textEnd = (const char *)(entity->textPtr + entity->textLen);
+  textStart = (char *)entity->textPtr;
+  textEnd = (char *)(entity->textPtr + entity->textLen);
   /* Set a safe default value in case 'next' does not get set */
   next = textStart;
 
@@ -5147,7 +5117,7 @@
     int tok =
         XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
-                      tok, next, &next, XML_FALSE, XML_FALSE);
+                      tok, next, &next, XML_FALSE);
   } else
 #endif /* XML_DTD */
     result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,
@@ -5181,8 +5151,8 @@
     return XML_ERROR_UNEXPECTED_STATE;
 
   entity = openEntity->entity;
-  textStart = ((const char *)entity->textPtr) + entity->processed;
-  textEnd = (const char *)(entity->textPtr + entity->textLen);
+  textStart = ((char *)entity->textPtr) + entity->processed;
+  textEnd = (char *)(entity->textPtr + entity->textLen);
   /* Set a safe default value in case 'next' does not get set */
   next = textStart;
 
@@ -5191,7 +5161,7 @@
     int tok =
         XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
-                      tok, next, &next, XML_FALSE, XML_TRUE);
+                      tok, next, &next, XML_FALSE);
   } else
 #endif /* XML_DTD */
     result =
@@ -5202,7 +5172,7 @@
     return result;
   else if (textEnd != next &&
            parser->m_parsingStatus.parsing == XML_SUSPENDED) {
-    entity->processed = (int)(next - (const char *)entity->textPtr);
+    entity->processed = (int)(next - (char *)entity->textPtr);
     return result;
   } else {
     entity->open = XML_FALSE;
@@ -5218,7 +5188,7 @@
     parser->m_processor = prologProcessor;
     tok = XmlPrologTok(parser->m_encoding, s, end, &next);
     return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
-                    (XML_Bool)!parser->m_parsingStatus.finalBuffer, XML_TRUE);
+                    (XML_Bool)!parser->m_parsingStatus.finalBuffer);
   } else
 #endif /* XML_DTD */
   {
@@ -5230,12 +5200,10 @@
   }
 }
 
-static enum XML_Error PTRCALL errorProcessor(XML_Parser parser, const char *s,
-                                             const char *end,
-                                             const char **nextPtr) {
-  UNUSED_P(s);
-  UNUSED_P(end);
-  UNUSED_P(nextPtr);
+static enum XML_Error PTRCALL errorProcessor(XML_Parser parser,
+                                             const char *UNUSED_P(s),
+                                             const char *UNUSED_P(end),
+                                             const char **UNUSED_P(nextPtr)) {
   return parser->m_errorCode;
 }
 
@@ -5399,8 +5367,8 @@
         const XML_Char *textEnd = entity->textPtr + entity->textLen;
         entity->open = XML_TRUE;
         result = appendAttributeValue(parser, parser->m_internalEncoding,
-                                      isCdata, (const char *)entity->textPtr,
-                                      (const char *)textEnd, pool);
+                                      isCdata, (char *)entity->textPtr,
+                                      (char *)textEnd, pool);
         entity->open = XML_FALSE;
         if (result)
           return result;
@@ -5499,8 +5467,8 @@
         } else {
           entity->open = XML_TRUE;
           result = storeEntityValue(
-              parser, parser->m_internalEncoding, (const char *)entity->textPtr,
-              (const char *)(entity->textPtr + entity->textLen));
+              parser, parser->m_internalEncoding, (char *)entity->textPtr,
+              (char *)(entity->textPtr + entity->textLen));
           entity->open = XML_FALSE;
           if (result)
             goto endEntityValue;
@@ -6435,7 +6403,7 @@
 static void FASTCALL hashTableIterInit(HASH_TABLE_ITER *iter,
                                        const HASH_TABLE *table) {
   iter->p = table->v;
-  iter->end = iter->p ? iter->p + table->size : NULL;
+  iter->end = iter->p + table->size;
 }
 
 static NAMED *FASTCALL hashTableIterNext(HASH_TABLE_ITER *iter) {
