--- /home/V1SCAN/CWE-122/FormattedUsed/bitmap-reactos-0.4.13.c	2023-12-12 03:51:20.718350647 +0900
+++ /home/V1SCAN/CWE-122/FormattedPatch/NEW##CVE-2018-8800##0##rdesktop@@rdesktop##bitmap.c	2023-12-12 03:51:21.160070600 +0900
@@ -1,196 +1,738 @@
-/* $Id: bitmap.c,v 1.9 1998/02/03 23:45:02 brianp Exp $ */
+/* -*- c-basic-offset: 8 -*-
+   rdesktop: A Remote Desktop Protocol client.
+   Bitmap decompression routines
+   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* three separate function for speed when decompressing the bitmaps
+   when modifying one function make the change in the others
+   jay.sorg@gmail.com */
+
+/* indent is confused by this file */
+/* *INDENT-OFF* */
+
+#include "rdesktop.h"
+
+#define CVAL(p) (*(p++))
+#ifdef NEED_ALIGN
+#ifdef L_ENDIAN
+#define CVAL2(p, v)                                                            \
+  {                                                                            \
+    v = (*(p++));                                                              \
+    v |= (*(p++)) << 8;                                                        \
+  }
+#else
+#define CVAL2(p, v)                                                            \
+  {                                                                            \
+    v = (*(p++)) << 8;                                                         \
+    v |= (*(p++));                                                             \
+  }
+#endif /* L_ENDIAN */
+#else
+#define CVAL2(p, v)                                                            \
+  {                                                                            \
+    v = (*((uint16 *)p));                                                      \
+    p += 2;                                                                    \
+  }
+#endif /* NEED_ALIGN */
 
-/*
- * Mesa 3-D graphics library
- * Version:  2.5
- * Copyright (C) 1995-1997  Brian Paul
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the Free
- * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- * $Log: bitmap.c,v $
- * Revision 1.9  1998/02/03 23:45:02  brianp
- * added casts to prevent warnings with Amiga StormC compiler
- *
- * Revision 1.8  1997/10/02 03:06:42  brianp
- * added #include <assert.h>
- *
- * Revision 1.7  1997/09/27 00:15:39  brianp
- * changed parameters to gl_unpack_image()
- *
- * Revision 1.6  1997/07/24 01:24:45  brianp
- * changed precompiled header symbol from PCH to PC_HEADER
- *
- * Revision 1.5  1997/06/20 02:18:09  brianp
- * replaced Current.IntColor with Current.ByteColor
- *
- * Revision 1.4  1997/05/28 03:23:48  brianp
- * added precompiled header (PCH) support
- *
- * Revision 1.3  1996/11/06 04:23:18  brianp
- * replaced 0 with GL_COLOR_INDEX in gl_unpack_bitmap()
- *
- * Revision 1.2  1996/09/15 14:18:10  brianp
- * now use GLframebuffer and GLvisual
- *
- * Revision 1.1  1996/09/13 01:38:16  brianp
- * Initial revision
- *
- */
+#define UNROLL8(exp)                                                           \
+  { exp exp exp exp exp exp exp exp }
 
-#ifdef PC_HEADER
-#include "all.h"
-#else
-#include "bitmap.h"
-#include "context.h"
-#include "feedback.h"
-#include "image.h"
-#include "macros.h"
-#include "pb.h"
-#include "types.h"
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#endif
-
-/*
- * Unpack a bitmap image
- */
-struct gl_image *gl_unpack_bitmap(GLcontext *ctx, GLsizei width, GLsizei height,
-                                  const GLubyte *bitmap) {
-  return gl_unpack_image(ctx, width, height, GL_COLOR_INDEX, GL_BITMAP, bitmap);
-}
-
-/*
- * Do actual rendering of a bitmap.
- */
-void gl_render_bitmap(GLcontext *ctx, GLsizei width, GLsizei height,
-                      GLfloat xorig, GLfloat yorig, GLfloat xmove,
-                      GLfloat ymove, const struct gl_image *bitmap) {
-  struct pixel_buffer *PB = ctx->PB;
-  GLint bx, by;     /* bitmap position */
-  GLint px, py, pz; /* pixel position */
-  GLubyte *ptr;
-
-  assert(bitmap);
-  assert(bitmap->Type == GL_BITMAP);
-  assert(bitmap->Format == GL_COLOR_INDEX);
-
-  if (ctx->NewState) {
-    gl_update_state(ctx);
-    PB_INIT(PB, GL_BITMAP);
-  }
-
-  if (ctx->Visual->RGBAflag) {
-    GLint r, g, b, a;
-    r = (GLint)(ctx->Current.RasterColor[0] * ctx->Visual->RedScale);
-    g = (GLint)(ctx->Current.RasterColor[1] * ctx->Visual->GreenScale);
-    b = (GLint)(ctx->Current.RasterColor[2] * ctx->Visual->BlueScale);
-    a = (GLint)(ctx->Current.RasterColor[3] * ctx->Visual->AlphaScale);
-    PB_SET_COLOR(ctx, PB, r, g, b, a);
-  } else {
-    PB_SET_INDEX(ctx, PB, ctx->Current.RasterIndex);
-  }
-
-  px = (GLint)((ctx->Current.RasterPos[0] - xorig) + 0.0F);
-  py = (GLint)((ctx->Current.RasterPos[1] - yorig) + 0.0F);
-  pz = (GLint)(ctx->Current.RasterPos[2] * DEPTH_SCALE);
-  ptr = (GLubyte *)bitmap->Data;
-
-  for (by = 0; by < height; by++) {
-    GLubyte bitmask;
-
-    /* do a row */
-    bitmask = 128;
-    for (bx = 0; bx < width; bx++) {
-      if (*ptr & bitmask) {
-        PB_WRITE_PIXEL(PB, px + bx, py + by, pz);
-      }
-      bitmask = bitmask >> 1;
-      if (bitmask == 0) {
-        ptr++;
-        bitmask = 128;
-      }
-    }
-
-    PB_CHECK_FLUSH(ctx, PB)
-
-    /* get ready for next row */
-    if (bitmask != 128)
-      ptr++;
-  }
-
-  gl_flush_pb(ctx);
-}
-
-/*
- * Execute a glBitmap command:
- *   1. check for errors
- *   2. feedback/render/select
- *   3. advance raster position
- */
-void gl_Bitmap(GLcontext *ctx, GLsizei width, GLsizei height, GLfloat xorig,
-               GLfloat yorig, GLfloat xmove, GLfloat ymove,
-               const struct gl_image *bitmap) {
-  if (width < 0 || height < 0) {
-    gl_error(ctx, GL_INVALID_VALUE, "glBitmap");
-    return;
-  }
-  if (INSIDE_BEGIN_END(ctx)) {
-    gl_error(ctx, GL_INVALID_OPERATION, "glBitmap");
-    return;
-  }
-  if (ctx->Current.RasterPosValid == GL_FALSE) {
-    /* do nothing */
-    return;
-  }
-
-  if (ctx->RenderMode == GL_RENDER) {
-    GLboolean completed = GL_FALSE;
-    if (ctx->Driver.Bitmap) {
-      /* let device driver try to render the bitmap */
-      completed = (*ctx->Driver.Bitmap)(ctx, width, height, xorig, yorig, xmove,
-                                        ymove, bitmap);
-    }
-    if (!completed) {
-      /* use generic function */
-      gl_render_bitmap(ctx, width, height, xorig, yorig, xmove, ymove, bitmap);
-    }
-  } else if (ctx->RenderMode == GL_FEEDBACK) {
-    GLfloat color[4], texcoord[4], invq;
-    color[0] = ctx->Current.ByteColor[0] * ctx->Visual->InvRedScale;
-    color[1] = ctx->Current.ByteColor[1] * ctx->Visual->InvGreenScale;
-    color[2] = ctx->Current.ByteColor[2] * ctx->Visual->InvBlueScale;
-    color[3] = ctx->Current.ByteColor[3] * ctx->Visual->InvAlphaScale;
-    invq = 1.0F / ctx->Current.TexCoord[3];
-    texcoord[0] = ctx->Current.TexCoord[0] * invq;
-    texcoord[1] = ctx->Current.TexCoord[1] * invq;
-    texcoord[2] = ctx->Current.TexCoord[2] * invq;
-    texcoord[3] = ctx->Current.TexCoord[3];
-    FEEDBACK_TOKEN(ctx, (GLfloat)(GLint)GL_BITMAP_TOKEN);
-    /* TODO: Verify XYZW values are correct: */
-    gl_feedback_vertex(ctx, ctx->Current.RasterPos[0] - xorig,
-                       ctx->Current.RasterPos[1] - yorig,
-                       ctx->Current.RasterPos[2], ctx->Current.RasterPos[3],
-                       color, ctx->Current.Index, texcoord);
-  } else if (ctx->RenderMode == GL_SELECT) {
-    /* Bitmaps don't generate selection hits.  See appendix B of 1.1 spec. */
-  }
-
-  /* update raster position */
-  ctx->Current.RasterPos[0] += xmove;
-  ctx->Current.RasterPos[1] += ymove;
+#define REPEAT(statement)                                                      \
+  {                                                                            \
+    while ((count & ~0x7) && ((x + 8) < width))                                \
+      UNROLL8(statement; count--; x++;);                                       \
+                                                                               \
+    while ((count > 0) && (x < width)) {                                       \
+      statement;                                                               \
+      count--;                                                                 \
+      x++;                                                                     \
+    }                                                                          \
+  }
+
+#define MASK_UPDATE()                                                          \
+  {                                                                            \
+    mixmask <<= 1;                                                             \
+    if (mixmask == 0) {                                                        \
+      mask = fom_mask ? fom_mask : CVAL(input);                                \
+      mixmask = 1;                                                             \
+    }                                                                          \
+  }
+
+/* 1 byte bitmap decompress */
+static RD_BOOL bitmap_decompress1(uint8 *output, int width, int height,
+                                  uint8 *input, int size) {
+  uint8 *end = input + size;
+  uint8 *prevline = NULL, *line = NULL;
+  int opcode, count, offset, isfillormix, x = width;
+  int lastopcode = -1, insertmix = False, bicolour = False;
+  uint8 code;
+  uint8 colour1 = 0, colour2 = 0;
+  uint8 mixmask, mask = 0;
+  uint8 mix = 0xff;
+  int fom_mask = 0;
+
+  while (input < end) {
+    fom_mask = 0;
+    code = CVAL(input);
+    opcode = code >> 4;
+    /* Handle different opcode forms */
+    switch (opcode) {
+    case 0xc:
+    case 0xd:
+    case 0xe:
+      opcode -= 6;
+      count = code & 0xf;
+      offset = 16;
+      break;
+    case 0xf:
+      opcode = code & 0xf;
+      if (opcode < 9) {
+        count = CVAL(input);
+        count |= CVAL(input) << 8;
+      } else {
+        count = (opcode < 0xb) ? 8 : 1;
+      }
+      offset = 0;
+      break;
+    default:
+      opcode >>= 1;
+      count = code & 0x1f;
+      offset = 32;
+      break;
+    }
+    /* Handle strange cases for counts */
+    if (offset != 0) {
+      isfillormix = ((opcode == 2) || (opcode == 7));
+      if (count == 0) {
+        if (isfillormix)
+          count = CVAL(input) + 1;
+        else
+          count = CVAL(input) + offset;
+      } else if (isfillormix) {
+        count <<= 3;
+      }
+    }
+    /* Read preliminary data */
+    switch (opcode) {
+    case 0: /* Fill */
+      if ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))
+        insertmix = True;
+      break;
+    case 8: /* Bicolour */
+      colour1 = CVAL(input);
+      colour2 = CVAL(input);
+      break;
+    case 3: /* Colour */
+      colour2 = CVAL(input);
+      break;
+    case 6: /* SetMix/Mix */
+    case 7: /* SetMix/FillOrMix */
+      mix = CVAL(input);
+      opcode -= 5;
+      break;
+    case 9: /* FillOrMix_1 */
+      mask = 0x03;
+      opcode = 0x02;
+      fom_mask = 3;
+      break;
+    case 0x0a: /* FillOrMix_2 */
+      mask = 0x05;
+      opcode = 0x02;
+      fom_mask = 5;
+      break;
+    }
+    lastopcode = opcode;
+    mixmask = 0;
+    /* Output body */
+    while (count > 0) {
+      if (x >= width) {
+        if (height <= 0)
+          return False;
+        x = 0;
+        height--;
+        prevline = line;
+        line = output + height * width;
+      }
+      switch (opcode) {
+      case 0: /* Fill */
+        if (insertmix) {
+          if (prevline == NULL)
+            line[x] = mix;
+          else
+            line[x] = prevline[x] ^ mix;
+          insertmix = False;
+          count--;
+          x++;
+        }
+        if (prevline == NULL) {
+          REPEAT(line[x] = 0)
+        } else {
+          REPEAT(line[x] = prevline[x])
+        }
+        break;
+      case 1: /* Mix */
+        if (prevline == NULL) {
+          REPEAT(line[x] = mix)
+        } else {
+          REPEAT(line[x] = prevline[x] ^ mix)
+        }
+        break;
+      case 2: /* Fill or Mix */
+        if (prevline == NULL) {
+          REPEAT(MASK_UPDATE(); if (mask & mixmask) line[x] = mix;
+                 else line[x] = 0;)
+        } else {
+          REPEAT(MASK_UPDATE(); if (mask & mixmask) line[x] = prevline[x] ^ mix;
+                 else line[x] = prevline[x];)
+        }
+        break;
+      case 3: /* Colour */
+        REPEAT(line[x] = colour2)
+        break;
+      case 4: /* Copy */
+        REPEAT(line[x] = CVAL(input))
+        break;
+      case 8: /* Bicolour */
+        REPEAT(if (bicolour) {
+          line[x] = colour2;
+          bicolour = False;
+        } else {
+          line[x] = colour1;
+          bicolour = True;
+          count++;
+        })
+        break;
+      case 0xd: /* White */
+        REPEAT(line[x] = 0xff)
+        break;
+      case 0xe: /* Black */
+        REPEAT(line[x] = 0)
+        break;
+      default:
+        logger(Core, Warning,
+               "bitmap_decompress(), unhandled bitmap opcode 0x%x", opcode);
+        return False;
+      }
+    }
+  }
+  return True;
+}
+
+/* 2 byte bitmap decompress */
+static RD_BOOL bitmap_decompress2(uint8 *output, int width, int height,
+                                  uint8 *input, int size) {
+  uint8 *end = input + size;
+  uint16 *prevline = NULL, *line = NULL;
+  int opcode, count, offset, isfillormix, x = width;
+  int lastopcode = -1, insertmix = False, bicolour = False;
+  uint8 code;
+  uint16 colour1 = 0, colour2 = 0;
+  uint8 mixmask, mask = 0;
+  uint16 mix = 0xffff;
+  int fom_mask = 0;
+
+  while (input < end) {
+    fom_mask = 0;
+    code = CVAL(input);
+    opcode = code >> 4;
+    /* Handle different opcode forms */
+    switch (opcode) {
+    case 0xc:
+    case 0xd:
+    case 0xe:
+      opcode -= 6;
+      count = code & 0xf;
+      offset = 16;
+      break;
+    case 0xf:
+      opcode = code & 0xf;
+      if (opcode < 9) {
+        count = CVAL(input);
+        count |= CVAL(input) << 8;
+      } else {
+        count = (opcode < 0xb) ? 8 : 1;
+      }
+      offset = 0;
+      break;
+    default:
+      opcode >>= 1;
+      count = code & 0x1f;
+      offset = 32;
+      break;
+    }
+    /* Handle strange cases for counts */
+    if (offset != 0) {
+      isfillormix = ((opcode == 2) || (opcode == 7));
+      if (count == 0) {
+        if (isfillormix)
+          count = CVAL(input) + 1;
+        else
+          count = CVAL(input) + offset;
+      } else if (isfillormix) {
+        count <<= 3;
+      }
+    }
+    /* Read preliminary data */
+    switch (opcode) {
+    case 0: /* Fill */
+      if ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))
+        insertmix = True;
+      break;
+    case 8: /* Bicolour */
+      CVAL2(input, colour1);
+      CVAL2(input, colour2);
+      break;
+    case 3: /* Colour */
+      CVAL2(input, colour2);
+      break;
+    case 6: /* SetMix/Mix */
+    case 7: /* SetMix/FillOrMix */
+      CVAL2(input, mix);
+      opcode -= 5;
+      break;
+    case 9: /* FillOrMix_1 */
+      mask = 0x03;
+      opcode = 0x02;
+      fom_mask = 3;
+      break;
+    case 0x0a: /* FillOrMix_2 */
+      mask = 0x05;
+      opcode = 0x02;
+      fom_mask = 5;
+      break;
+    }
+    lastopcode = opcode;
+    mixmask = 0;
+    /* Output body */
+    while (count > 0) {
+      if (x >= width) {
+        if (height <= 0)
+          return False;
+        x = 0;
+        height--;
+        prevline = line;
+        line = ((uint16 *)output) + height * width;
+      }
+      switch (opcode) {
+      case 0: /* Fill */
+        if (insertmix) {
+          if (prevline == NULL)
+            line[x] = mix;
+          else
+            line[x] = prevline[x] ^ mix;
+          insertmix = False;
+          count--;
+          x++;
+        }
+        if (prevline == NULL) {
+          REPEAT(line[x] = 0)
+        } else {
+          REPEAT(line[x] = prevline[x])
+        }
+        break;
+      case 1: /* Mix */
+        if (prevline == NULL) {
+          REPEAT(line[x] = mix)
+        } else {
+          REPEAT(line[x] = prevline[x] ^ mix)
+        }
+        break;
+      case 2: /* Fill or Mix */
+        if (prevline == NULL) {
+          REPEAT(MASK_UPDATE(); if (mask & mixmask) line[x] = mix;
+                 else line[x] = 0;)
+        } else {
+          REPEAT(MASK_UPDATE(); if (mask & mixmask) line[x] = prevline[x] ^ mix;
+                 else line[x] = prevline[x];)
+        }
+        break;
+      case 3: /* Colour */
+        REPEAT(line[x] = colour2)
+        break;
+      case 4: /* Copy */
+        REPEAT(CVAL2(input, line[x]))
+        break;
+      case 8: /* Bicolour */
+        REPEAT(if (bicolour) {
+          line[x] = colour2;
+          bicolour = False;
+        } else {
+          line[x] = colour1;
+          bicolour = True;
+          count++;
+        })
+        break;
+      case 0xd: /* White */
+        REPEAT(line[x] = 0xffff)
+        break;
+      case 0xe: /* Black */
+        REPEAT(line[x] = 0)
+        break;
+      default:
+        logger(Core, Warning,
+               "bitmap_decompress2(), unhandled bitmap opcode 0x%x", opcode);
+        return False;
+      }
+    }
+  }
+  return True;
+}
+
+/* 3 byte bitmap decompress */
+static RD_BOOL bitmap_decompress3(uint8 *output, int width, int height,
+                                  uint8 *input, int size) {
+  uint8 *end = input + size;
+  uint8 *prevline = NULL, *line = NULL;
+  int opcode, count, offset, isfillormix, x = width;
+  int lastopcode = -1, insertmix = False, bicolour = False;
+  uint8 code;
+  uint8 colour1[3] = {0, 0, 0}, colour2[3] = {0, 0, 0};
+  uint8 mixmask, mask = 0;
+  uint8 mix[3] = {0xff, 0xff, 0xff};
+  int fom_mask = 0;
+
+  while (input < end) {
+    fom_mask = 0;
+    code = CVAL(input);
+    opcode = code >> 4;
+    /* Handle different opcode forms */
+    switch (opcode) {
+    case 0xc:
+    case 0xd:
+    case 0xe:
+      opcode -= 6;
+      count = code & 0xf;
+      offset = 16;
+      break;
+    case 0xf:
+      opcode = code & 0xf;
+      if (opcode < 9) {
+        count = CVAL(input);
+        count |= CVAL(input) << 8;
+      } else {
+        count = (opcode < 0xb) ? 8 : 1;
+      }
+      offset = 0;
+      break;
+    default:
+      opcode >>= 1;
+      count = code & 0x1f;
+      offset = 32;
+      break;
+    }
+    /* Handle strange cases for counts */
+    if (offset != 0) {
+      isfillormix = ((opcode == 2) || (opcode == 7));
+      if (count == 0) {
+        if (isfillormix)
+          count = CVAL(input) + 1;
+        else
+          count = CVAL(input) + offset;
+      } else if (isfillormix) {
+        count <<= 3;
+      }
+    }
+    /* Read preliminary data */
+    switch (opcode) {
+    case 0: /* Fill */
+      if ((lastopcode == opcode) && !((x == width) && (prevline == NULL)))
+        insertmix = True;
+      break;
+    case 8: /* Bicolour */
+      colour1[0] = CVAL(input);
+      colour1[1] = CVAL(input);
+      colour1[2] = CVAL(input);
+      colour2[0] = CVAL(input);
+      colour2[1] = CVAL(input);
+      colour2[2] = CVAL(input);
+      break;
+    case 3: /* Colour */
+      colour2[0] = CVAL(input);
+      colour2[1] = CVAL(input);
+      colour2[2] = CVAL(input);
+      break;
+    case 6: /* SetMix/Mix */
+    case 7: /* SetMix/FillOrMix */
+      mix[0] = CVAL(input);
+      mix[1] = CVAL(input);
+      mix[2] = CVAL(input);
+      opcode -= 5;
+      break;
+    case 9: /* FillOrMix_1 */
+      mask = 0x03;
+      opcode = 0x02;
+      fom_mask = 3;
+      break;
+    case 0x0a: /* FillOrMix_2 */
+      mask = 0x05;
+      opcode = 0x02;
+      fom_mask = 5;
+      break;
+    }
+    lastopcode = opcode;
+    mixmask = 0;
+    /* Output body */
+    while (count > 0) {
+      if (x >= width) {
+        if (height <= 0)
+          return False;
+        x = 0;
+        height--;
+        prevline = line;
+        line = output + height * (width * 3);
+      }
+      switch (opcode) {
+      case 0: /* Fill */
+        if (insertmix) {
+          if (prevline == NULL) {
+            line[x * 3] = mix[0];
+            line[x * 3 + 1] = mix[1];
+            line[x * 3 + 2] = mix[2];
+          } else {
+            line[x * 3] = prevline[x * 3] ^ mix[0];
+            line[x * 3 + 1] = prevline[x * 3 + 1] ^ mix[1];
+            line[x * 3 + 2] = prevline[x * 3 + 2] ^ mix[2];
+          }
+          insertmix = False;
+          count--;
+          x++;
+        }
+        if (prevline == NULL) {
+          REPEAT(line[x * 3] = 0; line[x * 3 + 1] = 0; line[x * 3 + 2] = 0;)
+        } else {
+          REPEAT(line[x * 3] = prevline[x * 3];
+                 line[x * 3 + 1] = prevline[x * 3 + 1];
+                 line[x * 3 + 2] = prevline[x * 3 + 2];)
+        }
+        break;
+      case 1: /* Mix */
+        if (prevline == NULL) {
+          REPEAT(line[x * 3] = mix[0]; line[x * 3 + 1] = mix[1];
+                 line[x * 3 + 2] = mix[2];)
+        } else {
+          REPEAT(line[x * 3] = prevline[x * 3] ^ mix[0];
+                 line[x * 3 + 1] = prevline[x * 3 + 1] ^ mix[1];
+                 line[x * 3 + 2] = prevline[x * 3 + 2] ^ mix[2];)
+        }
+        break;
+      case 2: /* Fill or Mix */
+        if (prevline == NULL) {
+          REPEAT(MASK_UPDATE(); if (mask & mixmask) {
+            line[x * 3] = mix[0];
+            line[x * 3 + 1] = mix[1];
+            line[x * 3 + 2] = mix[2];
+          } else {
+            line[x * 3] = 0;
+            line[x * 3 + 1] = 0;
+            line[x * 3 + 2] = 0;
+          })
+        } else {
+          REPEAT(MASK_UPDATE(); if (mask & mixmask) {
+            line[x * 3] = prevline[x * 3] ^ mix[0];
+            line[x * 3 + 1] = prevline[x * 3 + 1] ^ mix[1];
+            line[x * 3 + 2] = prevline[x * 3 + 2] ^ mix[2];
+          } else {
+            line[x * 3] = prevline[x * 3];
+            line[x * 3 + 1] = prevline[x * 3 + 1];
+            line[x * 3 + 2] = prevline[x * 3 + 2];
+          })
+        }
+        break;
+      case 3: /* Colour */
+        REPEAT(line[x * 3] = colour2[0]; line[x * 3 + 1] = colour2[1];
+               line[x * 3 + 2] = colour2[2];)
+        break;
+      case 4: /* Copy */
+        REPEAT(line[x * 3] = CVAL(input); line[x * 3 + 1] = CVAL(input);
+               line[x * 3 + 2] = CVAL(input);)
+        break;
+      case 8: /* Bicolour */
+        REPEAT(if (bicolour) {
+          line[x * 3] = colour2[0];
+          line[x * 3 + 1] = colour2[1];
+          line[x * 3 + 2] = colour2[2];
+          bicolour = False;
+        } else {
+          line[x * 3] = colour1[0];
+          line[x * 3 + 1] = colour1[1];
+          line[x * 3 + 2] = colour1[2];
+          bicolour = True;
+          count++;
+        })
+        break;
+      case 0xd: /* White */
+        REPEAT(line[x * 3] = 0xff; line[x * 3 + 1] = 0xff;
+               line[x * 3 + 2] = 0xff;)
+        break;
+      case 0xe: /* Black */
+        REPEAT(line[x * 3] = 0; line[x * 3 + 1] = 0; line[x * 3 + 2] = 0;)
+        break;
+      default:
+        logger(Core, Warning,
+               "bitmap_decompress3(), unhandled bitmap opcode 0x%x", opcode);
+        return False;
+      }
+    }
+  }
+  return True;
 }
+
+/* decompress a colour plane */
+static int process_plane(uint8 *in, int width, int height, uint8 *out,
+                         int size) {
+  UNUSED(size);
+  int indexw;
+  int indexh;
+  int code;
+  int collen;
+  int replen;
+  int color;
+  int x;
+  int revcode;
+  uint8 *last_line;
+  uint8 *this_line;
+  uint8 *org_in;
+  uint8 *org_out;
+
+  org_in = in;
+  org_out = out;
+  last_line = 0;
+  indexh = 0;
+  while (indexh < height) {
+    out = (org_out + width * height * 4) - ((indexh + 1) * width * 4);
+    color = 0;
+    this_line = out;
+    indexw = 0;
+    if (last_line == 0) {
+      while (indexw < width) {
+        code = CVAL(in);
+        replen = code & 0xf;
+        collen = (code >> 4) & 0xf;
+        revcode = (replen << 4) | collen;
+        if ((revcode <= 47) && (revcode >= 16)) {
+          replen = revcode;
+          collen = 0;
+        }
+        while (indexw < width && collen > 0) {
+          color = CVAL(in);
+          *out = color;
+          out += 4;
+          indexw++;
+          collen--;
+        }
+        while (indexw < width && replen > 0) {
+          *out = color;
+          out += 4;
+          indexw++;
+          replen--;
+        }
+      }
+    } else {
+      while (indexw < width) {
+        code = CVAL(in);
+        replen = code & 0xf;
+        collen = (code >> 4) & 0xf;
+        revcode = (replen << 4) | collen;
+        if ((revcode <= 47) && (revcode >= 16)) {
+          replen = revcode;
+          collen = 0;
+        }
+        while (indexw < width && collen > 0) {
+          x = CVAL(in);
+          if (x & 1) {
+            x = x >> 1;
+            x = x + 1;
+            color = -x;
+          } else {
+            x = x >> 1;
+            color = x;
+          }
+          x = last_line[indexw * 4] + color;
+          *out = x;
+          out += 4;
+          indexw++;
+          collen--;
+        }
+        while (indexw < width && replen > 0) {
+          x = last_line[indexw * 4] + color;
+          *out = x;
+          out += 4;
+          indexw++;
+          replen--;
+        }
+      }
+    }
+    indexh++;
+    last_line = this_line;
+  }
+  return (int)(in - org_in);
+}
+
+/* 4 byte bitmap decompress */
+static RD_BOOL bitmap_decompress4(uint8 *output, int width, int height,
+                                  uint8 *input, int size) {
+  int code;
+  int bytes_pro;
+  int total_pro;
+
+  code = CVAL(input);
+  if (code != 0x10) {
+    return False;
+  }
+  total_pro = 1;
+  bytes_pro = process_plane(input, width, height, output + 3, size - total_pro);
+  total_pro += bytes_pro;
+  input += bytes_pro;
+  bytes_pro = process_plane(input, width, height, output + 2, size - total_pro);
+  total_pro += bytes_pro;
+  input += bytes_pro;
+  bytes_pro = process_plane(input, width, height, output + 1, size - total_pro);
+  total_pro += bytes_pro;
+  input += bytes_pro;
+  bytes_pro = process_plane(input, width, height, output + 0, size - total_pro);
+  total_pro += bytes_pro;
+  return size == total_pro;
+}
+
+/* main decompress function */
+RD_BOOL
+bitmap_decompress(uint8 *output, int width, int height, uint8 *input, int size,
+                  int Bpp) {
+  RD_BOOL rv = False;
+
+  switch (Bpp) {
+  case 1:
+    rv = bitmap_decompress1(output, width, height, input, size);
+    break;
+  case 2:
+    rv = bitmap_decompress2(output, width, height, input, size);
+    break;
+  case 3:
+    rv = bitmap_decompress3(output, width, height, input, size);
+    break;
+  case 4:
+    rv = bitmap_decompress4(output, width, height, input, size);
+    break;
+  default:
+    logger(Core, Debug, "bitmap_decompress(), unhandled BPP %d", Bpp);
+    break;
+  }
+  return rv;
+}
+
+/* *INDENT-ON* */
