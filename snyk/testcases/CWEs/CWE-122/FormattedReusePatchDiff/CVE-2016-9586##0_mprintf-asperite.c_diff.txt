--- /home/V1SCAN/CWE-122/FormattedUsed/mprintf-asperite.c	2023-12-12 03:51:20.868350219 +0900
+++ /home/V1SCAN/CWE-122/FormattedPatch/NEW##CVE-2016-9586##0##curl@@curl##mprintf.c	2023-12-12 03:51:21.130070686 +0900
@@ -5,11 +5,11 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1999 - 2010, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1999 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
- * are also available at http://curl.haxx.se/docs/copyright.html.
+ * are also available at https://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
@@ -32,20 +32,10 @@
  *
  * If you ever want truly portable and good *printf() clones, the project that
  * took on from here is named 'Trio' and you find more details on the trio web
- * page at http://daniel.haxx.se/trio/
+ * page at https://daniel.haxx.se/projects/trio/
  */
 
-#include "setup.h"
-#include <ctype.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#if defined(DJGPP) && (DJGPP_MINOR < 4)
-#undef _MPRINTF_REPLACE /* don't use x_was_used() here */
-#endif
-
+#include "curl_setup.h"
 #include <curl/mprintf.h>
 
 #include "curl_memory.h"
@@ -78,6 +68,18 @@
 #endif
 
 /*
+ * Non-ANSI integer extensions
+ */
+
+#if (defined(__BORLANDC__) && (__BORLANDC__ >= 0x520)) ||                      \
+    (defined(__WATCOMC__) && defined(__386__)) ||                              \
+    (defined(__POCC__) && defined(_MSC_VER)) || (defined(_WIN32_WCE)) ||       \
+    (defined(__MINGW32__)) ||                                                  \
+    (defined(_MSC_VER) && (_MSC_VER >= 900) && (_INTEGRAL_MAX_BITS >= 64))
+#define MP_HAVE_INT_EXTENSIONS
+#endif
+
+/*
  * Max integer data types that mprintf.c is capable
  */
 
@@ -89,7 +91,9 @@
 #define mp_uintmax_t unsigned long
 #endif
 
-#define BUFFSIZE 256       /* buffer for long-to-str and float-to-str calcs */
+#define BUFFSIZE                                                               \
+  326 /* buffer for long-to-str and float-to-str calcs, should                 \
+         fit negative DBL_MAX (317 letters) */
 #define MAX_PARAMETERS 128 /* lame static limit */
 
 #ifdef __AMIGA__
@@ -108,7 +112,8 @@
       done++;                                                                  \
     else                                                                       \
       return done; /* return immediately on failure */                         \
-  } while (0)
+  }                                                                            \
+  WHILE_FALSE
 
 /* Data type to read from the arglist */
 typedef enum {
@@ -193,8 +198,14 @@
   return 0;
 }
 
-static int dprintf_IsQualifierNoDollar(char c) {
-  switch (c) {
+static bool dprintf_IsQualifierNoDollar(const char *fmt) {
+#if defined(MP_HAVE_INT_EXTENSIONS)
+  if (!strncmp(fmt, "I32", 3) || !strncmp(fmt, "I64", 3)) {
+    return TRUE;
+  }
+#endif
+
+  switch (*fmt) {
   case '-':
   case '+':
   case ' ':
@@ -217,101 +228,15 @@
   case 'q':
   case '*':
   case 'O':
-    return 1; /* true */
-  default:
-    return 0; /* false */
-  }
-}
-
-#ifdef DPRINTF_DEBUG2
-static void dprintf_Pass1Report(va_stack_t *vto, int max) {
-  int i;
-  char buffer[256];
-  int bit;
-  int flags;
-
-  for (i = 0; i < max; i++) {
-    char *type;
-    switch (vto[i].type) {
-    case FORMAT_UNKNOWN:
-      type = "unknown";
-      break;
-    case FORMAT_STRING:
-      type = "string";
-      break;
-    case FORMAT_PTR:
-      type = "pointer";
-      break;
-    case FORMAT_INT:
-      type = "int";
-      break;
-    case FORMAT_INTPTR:
-      type = "intptr";
-      break;
-    case FORMAT_LONG:
-      type = "long";
-      break;
-    case FORMAT_LONGLONG:
-      type = "long long";
-      break;
-    case FORMAT_DOUBLE:
-      type = "double";
-      break;
-    case FORMAT_LONGDOUBLE:
-      type = "long double";
-      break;
-    }
-
-    buffer[0] = 0;
-
-    for (bit = 0; bit < 31; bit++) {
-      flags = vto[i].flags & (1 << bit);
+#if defined(MP_HAVE_INT_EXTENSIONS)
+  case 'I':
+#endif
+    return TRUE;
 
-      if (flags & FLAGS_SPACE)
-        strcat(buffer, "space ");
-      else if (flags & FLAGS_SHOWSIGN)
-        strcat(buffer, "plus ");
-      else if (flags & FLAGS_LEFT)
-        strcat(buffer, "left ");
-      else if (flags & FLAGS_ALT)
-        strcat(buffer, "alt ");
-      else if (flags & FLAGS_SHORT)
-        strcat(buffer, "short ");
-      else if (flags & FLAGS_LONG)
-        strcat(buffer, "long ");
-      else if (flags & FLAGS_LONGLONG)
-        strcat(buffer, "longlong ");
-      else if (flags & FLAGS_LONGDOUBLE)
-        strcat(buffer, "longdouble ");
-      else if (flags & FLAGS_PAD_NIL)
-        strcat(buffer, "padnil ");
-      else if (flags & FLAGS_UNSIGNED)
-        strcat(buffer, "unsigned ");
-      else if (flags & FLAGS_OCTAL)
-        strcat(buffer, "octal ");
-      else if (flags & FLAGS_HEX)
-        strcat(buffer, "hex ");
-      else if (flags & FLAGS_UPPER)
-        strcat(buffer, "upper ");
-      else if (flags & FLAGS_WIDTH)
-        strcat(buffer, "width ");
-      else if (flags & FLAGS_WIDTHPARAM)
-        strcat(buffer, "widthparam ");
-      else if (flags & FLAGS_PREC)
-        strcat(buffer, "precision ");
-      else if (flags & FLAGS_PRECPARAM)
-        strcat(buffer, "precparam ");
-      else if (flags & FLAGS_CHAR)
-        strcat(buffer, "char ");
-      else if (flags & FLAGS_FLOATE)
-        strcat(buffer, "floate ");
-      else if (flags & FLAGS_FLOATG)
-        strcat(buffer, "floatg ");
-    }
-    printf("REPORT: %d. %s [%s]\n", i, type, buffer);
+  default:
+    return FALSE;
   }
 }
-#endif
 
 /******************************************************************
  *
@@ -319,10 +244,12 @@
  * Create an index with the type of each parameter entry and its
  * value (may vary in size)
  *
+ * Returns zero on success.
+ *
  ******************************************************************/
 
-static long dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,
-                          va_list arglist) {
+static int dprintf_Pass1(const char *format, va_stack_t *vto, char **endpos,
+                         va_list arglist) {
   char *fmt = (char *)format;
   int param_num = 0;
   long this_param;
@@ -364,111 +291,133 @@
 
       /* Handle the flags */
 
-      while (dprintf_IsQualifierNoDollar(*fmt)) {
-        switch (*fmt++) {
-        case ' ':
-          flags |= FLAGS_SPACE;
-          break;
-        case '+':
-          flags |= FLAGS_SHOWSIGN;
-          break;
-        case '-':
-          flags |= FLAGS_LEFT;
-          flags &= ~FLAGS_PAD_NIL;
-          break;
-        case '#':
-          flags |= FLAGS_ALT;
-          break;
-        case '.':
-          flags |= FLAGS_PREC;
-          if ('*' == *fmt) {
-            /* The precision is picked from a specified parameter */
-
-            flags |= FLAGS_PRECPARAM;
-            fmt++;
-            param_num++;
-
-            i = dprintf_DollarString(fmt, &fmt);
-            if (i)
-              precision = i;
-            else
-              precision = param_num;
+      while (dprintf_IsQualifierNoDollar(fmt)) {
+#if defined(MP_HAVE_INT_EXTENSIONS)
+        if (!strncmp(fmt, "I32", 3)) {
+          flags |= FLAGS_LONG;
+          fmt += 3;
+        } else if (!strncmp(fmt, "I64", 3)) {
+          flags |= FLAGS_LONGLONG;
+          fmt += 3;
+        } else
+#endif
 
-            if (precision > max_param)
-              max_param = precision;
-          } else {
-            flags |= FLAGS_PREC;
-            precision = strtol(fmt, &fmt, 10);
-          }
-          break;
-        case 'h':
-          flags |= FLAGS_SHORT;
-          break;
-        case 'l':
-          if (flags & FLAGS_LONG)
+          switch (*fmt++) {
+          case ' ':
+            flags |= FLAGS_SPACE;
+            break;
+          case '+':
+            flags |= FLAGS_SHOWSIGN;
+            break;
+          case '-':
+            flags |= FLAGS_LEFT;
+            flags &= ~FLAGS_PAD_NIL;
+            break;
+          case '#':
+            flags |= FLAGS_ALT;
+            break;
+          case '.':
+            if ('*' == *fmt) {
+              /* The precision is picked from a specified parameter */
+
+              flags |= FLAGS_PRECPARAM;
+              fmt++;
+              param_num++;
+
+              i = dprintf_DollarString(fmt, &fmt);
+              if (i)
+                precision = i;
+              else
+                precision = param_num;
+
+              if (precision > max_param)
+                max_param = precision;
+            } else {
+              flags |= FLAGS_PREC;
+              precision = strtol(fmt, &fmt, 10);
+            }
+            break;
+          case 'h':
+            flags |= FLAGS_SHORT;
+            break;
+#if defined(MP_HAVE_INT_EXTENSIONS)
+          case 'I':
+#if (CURL_SIZEOF_CURL_OFF_T > CURL_SIZEOF_LONG)
             flags |= FLAGS_LONGLONG;
-          else
+#else
             flags |= FLAGS_LONG;
-          break;
-        case 'L':
-          flags |= FLAGS_LONGDOUBLE;
-          break;
-        case 'q':
-          flags |= FLAGS_LONGLONG;
-          break;
-        case 'z':
-          /* the code below generates a warning if -Wunreachable-code is
-             used */
+#endif
+            break;
+#endif
+          case 'l':
+            if (flags & FLAGS_LONG)
+              flags |= FLAGS_LONGLONG;
+            else
+              flags |= FLAGS_LONG;
+            break;
+          case 'L':
+            flags |= FLAGS_LONGDOUBLE;
+            break;
+          case 'q':
+            flags |= FLAGS_LONGLONG;
+            break;
+          case 'z':
+            /* the code below generates a warning if -Wunreachable-code is
+               used */
 #if (SIZEOF_SIZE_T > CURL_SIZEOF_LONG)
-          flags |= FLAGS_LONGLONG;
+            flags |= FLAGS_LONGLONG;
 #else
           flags |= FLAGS_LONG;
 #endif
-          break;
-        case 'O':
+            break;
+          case 'O':
 #if (CURL_SIZEOF_CURL_OFF_T > CURL_SIZEOF_LONG)
-          flags |= FLAGS_LONGLONG;
+            flags |= FLAGS_LONGLONG;
 #else
           flags |= FLAGS_LONG;
 #endif
-          break;
-        case '0':
-          if (!(flags & FLAGS_LEFT))
-            flags |= FLAGS_PAD_NIL;
-          /* FALLTHROUGH */
-        case '1':
-        case '2':
-        case '3':
-        case '4':
-        case '5':
-        case '6':
-        case '7':
-        case '8':
-        case '9':
-          flags |= FLAGS_WIDTH;
-          width = strtol(fmt - 1, &fmt, 10);
-          break;
-        case '*': /* Special case */
-          flags |= FLAGS_WIDTHPARAM;
-          param_num++;
-
-          i = dprintf_DollarString(fmt, &fmt);
-          if (i)
-            width = i;
-          else
-            width = param_num;
-          if (width > max_param)
-            max_param = width;
-          break;
-        default:
-          break;
-        }
+            break;
+          case '0':
+            if (!(flags & FLAGS_LEFT))
+              flags |= FLAGS_PAD_NIL;
+            /* FALLTHROUGH */
+          case '1':
+          case '2':
+          case '3':
+          case '4':
+          case '5':
+          case '6':
+          case '7':
+          case '8':
+          case '9':
+            flags |= FLAGS_WIDTH;
+            width = strtol(fmt - 1, &fmt, 10);
+            break;
+          case '*': /* Special case */
+            flags |= FLAGS_WIDTHPARAM;
+            param_num++;
+
+            i = dprintf_DollarString(fmt, &fmt);
+            if (i)
+              width = i;
+            else
+              width = param_num;
+            if (width > max_param)
+              max_param = width;
+            break;
+          default:
+            break;
+          }
       } /* switch */
 
       /* Handle the specifier */
 
       i = this_param - 1;
 
+      if ((i < 0) || (i >= MAX_PARAMETERS))
+        /* out of allowed range */
+        return 1;
+
       switch (*fmt) {
       case 'S':
         flags |= FLAGS_ALT;
@@ -496,11 +445,11 @@
         break;
       case 'x':
         vto[i].type = FORMAT_INT;
-        flags |= FLAGS_HEX;
+        flags |= FLAGS_HEX | FLAGS_UNSIGNED;
         break;
       case 'X':
         vto[i].type = FORMAT_INT;
-        flags |= FLAGS_HEX | FLAGS_UPPER;
+        flags |= FLAGS_HEX | FLAGS_UPPER | FLAGS_UNSIGNED;
         break;
       case 'c':
         vto[i].type = FORMAT_INT;
@@ -537,38 +486,39 @@
       if (flags & FLAGS_WIDTHPARAM) {
         /* we have the width specified from a parameter, so we make that
            parameter's info setup properly */
-        vto[i].width = width - 1;
-        i = width - 1;
-        vto[i].type = FORMAT_WIDTH;
-        vto[i].flags = FLAGS_NEW;
-        vto[i].precision = vto[i].width = 0; /* can't use width or precision
-                                                of width! */
+        long k = width - 1;
+        vto[i].width = k;
+        vto[k].type = FORMAT_WIDTH;
+        vto[k].flags = FLAGS_NEW;
+        /* can't use width or precision of width! */
+        vto[k].width = 0;
+        vto[k].precision = 0;
       }
       if (flags & FLAGS_PRECPARAM) {
         /* we have the precision specified from a parameter, so we make that
            parameter's info setup properly */
-        vto[i].precision = precision - 1;
-        i = precision - 1;
-        vto[i].type = FORMAT_WIDTH;
-        vto[i].flags = FLAGS_NEW;
-        vto[i].precision = vto[i].width = 0; /* can't use width or precision
-                                                of width! */
+        long k = precision - 1;
+        vto[i].precision = k;
+        vto[k].type = FORMAT_WIDTH;
+        vto[k].flags = FLAGS_NEW;
+        /* can't use width or precision of width! */
+        vto[k].width = 0;
+        vto[k].precision = 0;
       }
       *endpos++ = fmt + 1; /* end of this sequence */
     }
   }
 
-#ifdef DPRINTF_DEBUG2
-  dprintf_Pass1Report(vto, max_param);
-#endif
-
   /* Read the arg list parameters into our data list */
   for (i = 0; i < max_param; i++) {
-    if ((i + 1 < max_param) && (vto[i + 1].type == FORMAT_WIDTH)) {
-      /* Width/precision arguments must be read before the main argument
-       * they are attached to
-       */
-      vto[i + 1].data.num.as_signed = (mp_intmax_t)va_arg(arglist, int);
+    /* Width/precision arguments must be read before the main argument
+       they are attached to */
+    if (vto[i].flags & FLAGS_WIDTHPARAM) {
+      vto[vto[i].width].data.num.as_signed = (mp_intmax_t)va_arg(arglist, int);
+    }
+    if (vto[i].flags & FLAGS_PRECPARAM) {
+      vto[vto[i].precision].data.num.as_signed =
+          (mp_intmax_t)va_arg(arglist, int);
     }
 
     switch (vto[i].type) {
@@ -621,7 +571,7 @@
     }
   }
 
-  return max_param;
+  return 0;
 }
 
 static int
@@ -652,8 +602,14 @@
 
   va_stack_t *p;
 
+  /* 'workend' points to the final buffer byte position, but with an extra
+     byte as margin to avoid the (false?) warning Coverity gives us
+     otherwise */
+  char *workend = &work[sizeof(work) - 2];
+
   /* Do the actual %-code parsing */
-  dprintf_Pass1(format, vto, endpos, ap_save);
+  if (dprintf_Pass1(format, vto, endpos, ap_save))
+    return -1;
 
   end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()
                        created for us */
@@ -681,6 +637,8 @@
     /* Used to convert negative in positive.  */
     mp_intmax_t signed_num;
 
+    char *w;
+
     if (*f != '%') {
       /* This isn't a format spec, so write everything out until the next one
          OR end of string is reached.  */
@@ -717,16 +675,29 @@
     p = &vto[param];
 
     /* pick up the specified width */
-    if (p->flags & FLAGS_WIDTHPARAM)
+    if (p->flags & FLAGS_WIDTHPARAM) {
       width = (long)vto[p->width].data.num.as_signed;
-    else
+      param_num++; /* since the width is extracted from a parameter, we
+                      must skip that to get to the next one properly */
+      if (width < 0) {
+        /* "A negative field width is taken as a '-' flag followed by a
+           positive field width." */
+        width = -width;
+        p->flags |= FLAGS_LEFT;
+        p->flags &= ~FLAGS_PAD_NIL;
+      }
+    } else
       width = p->width;
 
     /* pick up the specified precision */
     if (p->flags & FLAGS_PRECPARAM) {
       prec = (long)vto[p->precision].data.num.as_signed;
-      param_num++; /* since the precision is extraced from a parameter, we
+      param_num++; /* since the precision is extracted from a parameter, we
                       must skip that to get to the next one properly */
+      if (prec < 0)
+        /* "A negative precision is taken as if the precision were
+           omitted." */
+        prec = -1;
     } else if (p->flags & FLAGS_PREC)
       prec = p->precision;
     else
@@ -748,22 +719,20 @@
             OUTCHAR(' ');
         break;
       }
-      if (p->flags & FLAGS_UNSIGNED) {
-        /* Decimal unsigned integer.  */
-        base = 10;
-        goto unsigned_number;
-      }
       if (p->flags & FLAGS_OCTAL) {
         /* Octal unsigned integer.  */
         base = 8;
         goto unsigned_number;
-      }
-      if (p->flags & FLAGS_HEX) {
+      } else if (p->flags & FLAGS_HEX) {
         /* Hexadecimal unsigned integer.  */
 
         digits = (p->flags & FLAGS_UPPER) ? upper_digits : lower_digits;
         base = 16;
         goto unsigned_number;
+      } else if (p->flags & FLAGS_UNSIGNED) {
+        /* Decimal unsigned integer.  */
+        base = 10;
+        goto unsigned_number;
       }
 
       /* Decimal integer.  */
@@ -786,72 +755,68 @@
 
     number:
       /* Number of base BASE.  */
-      {
-        char *workend = &work[sizeof(work) - 1];
-        char *w;
-
-        /* Supply a default precision if none was given.  */
-        if (prec == -1)
-          prec = 1;
-
-        /* Put the number in WORK.  */
-        w = workend;
-        while (num > 0) {
-          *w-- = digits[num % base];
-          num /= base;
-        }
-        width -= (long)(workend - w);
-        prec -= (long)(workend - w);
 
-        if (is_alt && base == 8 && prec <= 0) {
-          *w-- = '0';
-          --width;
-        }
+      /* Supply a default precision if none was given.  */
+      if (prec == -1)
+        prec = 1;
+
+      /* Put the number in WORK.  */
+      w = workend;
+      while (num > 0) {
+        *w-- = digits[num % base];
+        num /= base;
+      }
+      width -= (long)(workend - w);
+      prec -= (long)(workend - w);
 
-        if (prec > 0) {
-          width -= prec;
-          while (prec-- > 0)
-            *w-- = '0';
-        }
+      if (is_alt && base == 8 && prec <= 0) {
+        *w-- = '0';
+        --width;
+      }
 
-        if (is_alt && base == 16)
-          width -= 2;
+      if (prec > 0) {
+        width -= prec;
+        while (prec-- > 0)
+          *w-- = '0';
+      }
 
-        if (is_neg || (p->flags & FLAGS_SHOWSIGN) || (p->flags & FLAGS_SPACE))
-          --width;
+      if (is_alt && base == 16)
+        width -= 2;
 
-        if (!(p->flags & FLAGS_LEFT) && !(p->flags & FLAGS_PAD_NIL))
-          while (width-- > 0)
-            OUTCHAR(' ');
+      if (is_neg || (p->flags & FLAGS_SHOWSIGN) || (p->flags & FLAGS_SPACE))
+        --width;
 
-        if (is_neg)
-          OUTCHAR('-');
-        else if (p->flags & FLAGS_SHOWSIGN)
-          OUTCHAR('+');
-        else if (p->flags & FLAGS_SPACE)
+      if (!(p->flags & FLAGS_LEFT) && !(p->flags & FLAGS_PAD_NIL))
+        while (width-- > 0)
           OUTCHAR(' ');
 
-        if (is_alt && base == 16) {
-          OUTCHAR('0');
-          if (p->flags & FLAGS_UPPER)
-            OUTCHAR('X');
-          else
-            OUTCHAR('x');
-        }
-
-        if (!(p->flags & FLAGS_LEFT) && (p->flags & FLAGS_PAD_NIL))
-          while (width-- > 0)
-            OUTCHAR('0');
+      if (is_neg)
+        OUTCHAR('-');
+      else if (p->flags & FLAGS_SHOWSIGN)
+        OUTCHAR('+');
+      else if (p->flags & FLAGS_SPACE)
+        OUTCHAR(' ');
+
+      if (is_alt && base == 16) {
+        OUTCHAR('0');
+        if (p->flags & FLAGS_UPPER)
+          OUTCHAR('X');
+        else
+          OUTCHAR('x');
+      }
 
-        /* Write the number.  */
-        while (++w <= workend) {
-          OUTCHAR(*w);
-        }
+      if (!(p->flags & FLAGS_LEFT) && (p->flags & FLAGS_PAD_NIL))
+        while (width-- > 0)
+          OUTCHAR('0');
 
-        if (p->flags & FLAGS_LEFT)
-          while (width-- > 0)
-            OUTCHAR(' ');
+      /* Write the number.  */
+      while (++w <= workend) {
+        OUTCHAR(*w);
       }
+
+      if (p->flags & FLAGS_LEFT)
+        while (width-- > 0)
+          OUTCHAR(' ');
       break;
 
     case FORMAT_STRING:
@@ -873,12 +838,12 @@
             str = "";
             len = 0;
           }
-        } else
+        } else if (prec != -1)
+          len = (size_t)prec;
+        else
           len = strlen(str);
 
-        if (prec != -1 && (size_t)prec < len)
-          len = (size_t)prec;
-        width -= (long)len;
+        width -= (len > LONG_MAX) ? LONG_MAX : (long)len;
 
         if (p->flags & FLAGS_ALT)
           OUTCHAR('"');
@@ -887,7 +852,7 @@
           while (width-- > 0)
             OUTCHAR(' ');
 
-        while (len-- > 0)
+        while ((len-- > 0) && *str)
           OUTCHAR(*str++);
         if (p->flags & FLAGS_LEFT)
           while (width-- > 0)
@@ -931,7 +896,7 @@
 
     case FORMAT_DOUBLE: {
       char formatbuf[32] = "%";
-      char *fptr;
+      char *fptr = &formatbuf[1];
       size_t left = sizeof(formatbuf) - strlen(formatbuf);
       int len;
 
@@ -948,23 +913,36 @@
         prec = (long)vto[p->precision].data.num.as_signed;
 
       if (p->flags & FLAGS_LEFT)
-        strcat(formatbuf, "-");
+        *fptr++ = '-';
       if (p->flags & FLAGS_SHOWSIGN)
-        strcat(formatbuf, "+");
+        *fptr++ = '+';
       if (p->flags & FLAGS_SPACE)
-        strcat(formatbuf, " ");
+        *fptr++ = ' ';
       if (p->flags & FLAGS_ALT)
-        strcat(formatbuf, "#");
+        *fptr++ = '#';
 
-      fptr = &formatbuf[strlen(formatbuf)];
+      *fptr = 0;
 
       if (width >= 0) {
+        if (width >= (long)sizeof(work))
+          width = sizeof(work) - 1;
         /* RECURSIVE USAGE */
         len = curl_msnprintf(fptr, left, "%ld", width);
         fptr += len;
         left -= len;
       }
       if (prec >= 0) {
+        /* for each digit in the integer part, we can have one less
+           precision */
+        size_t maxprec = sizeof(work) - 2;
+        double val = p->data.dnum;
+        while (val >= 10.0) {
+          val /= 10;
+          maxprec--;
+        }
+
+        if (prec > (long)maxprec)
+          prec = maxprec - 1;
         /* RECURSIVE USAGE */
         len = curl_msnprintf(fptr, left, ".%ld", prec);
         fptr += len;
@@ -981,10 +959,12 @@
 
       *fptr = 0; /* and a final zero termination */
 
-      /* NOTE NOTE NOTE!! Not all sprintf() implementations returns number
-         of output characters */
+      /* NOTE NOTE NOTE!! Not all sprintf implementations return number of
+         output characters */
       (sprintf)(work, formatbuf, p->data.dnum);
-
+#ifdef CURLDEBUG
+      assert(strlen(work) <= sizeof(work));
+#endif
       for (fptr = work; *fptr; fptr++)
         OUTCHAR(*fptr);
     } break;
@@ -1037,7 +1017,7 @@
   info.max = maxlength;
 
   retcode = dprintf_formatf(&info, addbyter, format, ap_save);
-  if (info.max) {
+  if ((retcode != -1) && info.max) {
     /* we terminate this with a zero byte */
     if (info.max == info.length)
       /* we're at maximum, scrap the last letter */
@@ -1071,16 +1051,19 @@
     infop->alloc = 32;
     infop->len = 0;
   } else if (infop->len + 1 >= infop->alloc) {
-    char *newptr;
+    char *newptr = NULL;
+    size_t newsize = infop->alloc * 2;
 
-    newptr = realloc(infop->buffer, infop->alloc * 2);
+    /* detect wrap-around or other overflow problems */
+    if (newsize > infop->alloc)
+      newptr = realloc(infop->buffer, newsize);
 
     if (!newptr) {
       infop->fail = 1;
       return -1; /* fail */
     }
     infop->buffer = newptr;
-    infop->alloc *= 2;
+    infop->alloc = newsize;
   }
 
   infop->buffer[infop->len] = outc;
@@ -1189,50 +1172,3 @@
 int curl_mvfprintf(FILE *whereto, const char *format, va_list ap_save) {
   return dprintf_formatf(whereto, fputc, format, ap_save);
 }
-
-#ifdef DPRINTF_DEBUG
-int main() {
-  char buffer[129];
-  char *ptr;
-#ifdef HAVE_LONG_LONG_TYPE
-  LONG_LONG_TYPE one = 99;
-  LONG_LONG_TYPE two = 100;
-  LONG_LONG_TYPE test = 0x1000000000LL;
-  curl_mprintf("%lld %lld %lld\n", one, two, test);
-#endif
-
-  curl_mprintf("%3d %5d\n", 10, 1998);
-
-  ptr = curl_maprintf("test this then baby %s%s%s%s%s%s %d %d %d loser baby "
-                      "get a kiss in yer face now!",
-                      "",
-                      "pretty long string pretty long string pretty long "
-                      "string pretty long string pretty long string",
-                      "/", "/", "/", "pretty long string", 1998, 1999, 2001);
-
-  puts(ptr);
-
-  memset(ptr, 55, strlen(ptr) + 1);
-
-  free(ptr);
-
-#if 1
-  curl_mprintf(buffer, "%s %s %d", "daniel", "stenberg", 19988);
-  puts(buffer);
-
-  curl_mfprintf(stderr, "%s %#08x\n", "dummy", 65);
-
-  printf("%s %#08x\n", "dummy", 65);
-  {
-    double tryout = 3.14156592;
-    curl_mprintf(buffer, "%.2g %G %f %e %E", tryout, tryout, tryout, tryout,
-                 tryout);
-    puts(buffer);
-    printf("%.2g %G %f %e %E\n", tryout, tryout, tryout, tryout, tryout);
-  }
-#endif
-
-  return 0;
-}
-
-#endif
