--- /home/V1SCAN/CWE-122/FormattedUsed/rdpdr-reactos-0.4.13.c	2023-12-12 03:51:20.988349875 +0900
+++ /home/V1SCAN/CWE-122/FormattedPatch/NEW##CVE-2018-8800##0##rdesktop@@rdesktop##rdpdr.c	2023-12-12 03:51:21.280070255 +0900
@@ -1,10 +1,13 @@
 /* -*- c-basic-offset: 8 -*-
    rdesktop: A Remote Desktop Protocol client.
-   Copyright (C) Matthew Chapman 1999-2005
+   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008
+   Copyright 2004-2011 Peter Astrand <astrand@cendio.se> for Cendio AB
+   Copyright 2010-2017 Henrik Andersson <hean01@cendio.se> for Cendio AB
+   Copyright 2017 Karl Mikaelsson <derfian@cendio.se> for Cendio AB
 
-   This program is free software; you can redistribute it and/or modify
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
+   the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -12,9 +15,8 @@
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 /*
@@ -55,16 +57,51 @@
 #define IRP_MN_QUERY_DIRECTORY 0x01
 #define IRP_MN_NOTIFY_CHANGE_DIRECTORY 0x02
 
+extern char g_hostname[16];
 extern DEVICE_FNS serial_fns;
 extern DEVICE_FNS printer_fns;
 extern DEVICE_FNS parallel_fns;
 extern DEVICE_FNS disk_fns;
+#ifdef WITH_SCARD
+extern DEVICE_FNS scard_fns;
+#endif
+extern FILEINFO g_fileinfo[];
+extern RD_BOOL g_notify_stamp;
+
+static VCHANNEL *rdpdr_channel;
+static uint32 g_epoch;
+
+/* If select() times out, the request for the device with handle
+ * g_min_timeout_fd is aborted */
+RD_NTHANDLE g_min_timeout_fd;
+uint32 g_num_devices;
+
+uint32 g_client_id;
+
+/* Table with information about rdpdr devices */
+RDPDR_DEVICE g_rdpdr_device[RDPDR_MAX_DEVICES];
+char *g_rdpdr_clientname = NULL;
+
+/* Used to store incoming io request, until they are ready to be completed */
+/* using a linked list ensures that they are processed in the right order, */
+/* if multiple IOs are being done on the same FD */
+struct async_iorequest {
+  uint32 fd, major, minor, offset, device, id, length, partial_len;
+  long timeout,    /* Total timeout */
+      itv_timeout; /* Interval timeout (between serial characters) */
+  uint8 *buffer;
+  DEVICE_FNS *fns;
+
+  struct async_iorequest *next; /* next element in list */
+};
+
+struct async_iorequest *g_iorequest;
 
 /* Return device_id for a given handle */
-int get_device_index(RDPCLIENT *This, NTHANDLE handle) {
+int get_device_index(RD_NTHANDLE handle) {
   int i;
   for (i = 0; i < RDPDR_MAX_DEVICES; i++) {
-    if (This->rdpdr_device[i].handle == handle)
+    if (g_rdpdr_device[i].handle == handle)
       return i;
   }
   return -1;
@@ -79,17 +116,17 @@
   }
 }
 
-static BOOL rdpdr_handle_ok(RDPCLIENT *This, int device, int handle) {
-  switch (This->rdpdr_device[device].device_type) {
+static RD_BOOL rdpdr_handle_ok(uint32 device, RD_NTHANDLE handle) {
+  switch (g_rdpdr_device[device].device_type) {
   case DEVICE_TYPE_PARALLEL:
   case DEVICE_TYPE_SERIAL:
   case DEVICE_TYPE_PRINTER:
   case DEVICE_TYPE_SCARD:
-    if (This->rdpdr_device[device].handle != handle)
+    if (g_rdpdr_device[device].handle != handle)
       return False;
     break;
   case DEVICE_TYPE_DISK:
-    if (This->fileinfo[handle].device_id != device)
+    if (g_fileinfo[handle].device_id != device)
       return False;
     break;
   }
@@ -98,23 +135,23 @@
 
 /* Add a new io request to the table containing pending io requests so it won't
  * block rdesktop */
-static BOOL add_async_iorequest(RDPCLIENT *This, uint32 device, uint32 file,
-                                uint32 id, uint32 major, uint32 length,
-                                DEVICE_FNS *fns, uint32 total_timeout,
-                                uint32 interval_timeout, uint8 *buffer,
-                                uint32 offset) {
+static RD_BOOL add_async_iorequest(uint32 device, uint32 file, uint32 id,
+                                   uint32 major, uint32 length, DEVICE_FNS *fns,
+                                   uint32 total_timeout,
+                                   uint32 interval_timeout, uint8 *buffer,
+                                   uint32 offset) {
   struct async_iorequest *iorq;
 
-  if (This->iorequest == NULL) {
-    This->iorequest =
+  if (g_iorequest == NULL) {
+    g_iorequest =
         (struct async_iorequest *)xmalloc(sizeof(struct async_iorequest));
-    if (!This->iorequest)
+    if (!g_iorequest)
       return False;
-    This->iorequest->fd = 0;
-    This->iorequest->next = NULL;
+    g_iorequest->fd = 0;
+    g_iorequest->next = NULL;
   }
 
-  iorq = This->iorequest;
+  iorq = g_iorequest;
 
   while (iorq->fd != 0) {
     /* create new element if needed */
@@ -142,51 +179,65 @@
   return True;
 }
 
-static void rdpdr_send_connect(RDPCLIENT *This) {
-  uint8 magic[4] = "rDCC";
+static void rdpdr_send_client_announce_reply(void) {
+  /* DR_CORE_CLIENT_ANNOUNCE_RSP */
   STREAM s;
-
-  s = channel_init(This, This->rdpdr.channel, 12);
-  out_uint8a(s, magic, 4);
-  out_uint16_le(s, 1); /* unknown */
-  out_uint16_le(s, 5);
-  out_uint32_be(s, 0x815ed39d); /* IP address (use 127.0.0.1) 0x815ed39d */
+  s = channel_init(rdpdr_channel, 12);
+  out_uint16_le(s, RDPDR_CTYP_CORE);
+  out_uint16_le(s, PAKID_CORE_CLIENTID_CONFIRM);
+  out_uint16_le(s, 1);           /* VersionMajor, MUST be set to 0x1 */
+  out_uint16_le(s, 5);           /* VersionMinor */
+  out_uint32_be(s, g_client_id); /* ClientID */
   s_mark_end(s);
-  channel_send(This, s, This->rdpdr.channel);
+  channel_send(s, rdpdr_channel);
 }
 
-static void rdpdr_send_name(RDPCLIENT *This) {
-  uint8 magic[4] = "rDNC";
+static void rdpdr_send_client_name_request(void) {
+  /* DR_CORE_CLIENT_NAME_REQ */
   STREAM s;
-  uint32 hostlen;
+  struct stream name = {0};
 
-  if (NULL == This->rdpdr_clientname) {
-    This->rdpdr_clientname = This->hostname;
+  if (NULL == g_rdpdr_clientname) {
+    g_rdpdr_clientname = g_hostname;
   }
-  hostlen = (strlen(This->rdpdr_clientname) + 1) * 2;
 
-  s = channel_init(This, This->rdpdr.channel, 16 + hostlen);
-  out_uint8a(s, magic, 4);
-  out_uint16_le(s, 0x63); /* unknown */
-  out_uint16_le(s, 0x72);
-  out_uint32(s, 0);
-  out_uint32_le(s, hostlen);
-  rdp_out_unistr(This, s, This->rdpdr_clientname, hostlen - 2);
+  s_realloc(&name, 512 * 4);
+  s_reset(&name);
+  out_utf16s(&name, g_rdpdr_clientname);
+  s_mark_end(&name);
+
+  s = channel_init(rdpdr_channel, 16 + s_length(&name));
+  out_uint16_le(s, RDPDR_CTYP_CORE);
+  out_uint16_le(s, PAKID_CORE_CLIENT_NAME);
+  out_uint32_le(s, 1);               /* UnicodeFlag */
+  out_uint32_le(s, 0);               /* CodePage */
+  out_uint32_le(s, s_length(&name)); /* ComputerNameLen */
+  out_stream(s, &name);
   s_mark_end(s);
-  channel_send(This, s, This->rdpdr.channel);
+  channel_send(s, rdpdr_channel);
 }
 
 /* Returns the size of the payload of the announce packet */
-static int announcedata_size(RDPCLIENT *This) {
-  int size, i;
+static size_t announcedata_size() {
+  size_t size, i;
   PRINTER *printerinfo;
+  DISK_DEVICE *diskinfo;
 
-  size = 8; /* static announce size */
-  size += This->num_devices * 0x14;
+  size = 8; /* Header + DeviceCount */
 
-  for (i = 0; i < This->num_devices; i++) {
-    if (This->rdpdr_device[i].device_type == DEVICE_TYPE_PRINTER) {
-      printerinfo = (PRINTER *)This->rdpdr_device[i].pdevice_data;
+  for (i = 0; i < g_num_devices; i++) {
+    size += 4; /* DeviceType */
+    size += 4; /* DeviceId */
+    size += 8; /* PreferredDosName */
+    size += 4; /* DeviceDataLength */
+
+    switch (g_rdpdr_device[i].device_type) {
+    case DEVICE_TYPE_DISK:
+      diskinfo = (DISK_DEVICE *)g_rdpdr_device[i].pdevice_data;
+      size += 2 * strlen(diskinfo->name) + 2;
+      break;
+    case DEVICE_TYPE_PRINTER:
+      printerinfo = (PRINTER *)g_rdpdr_device[i].pdevice_data;
       printerinfo->bloblen =
           printercache_load_blob(printerinfo->printer, &(printerinfo->blob));
 
@@ -194,49 +245,81 @@
       size += 2 * strlen(printerinfo->driver) + 2;
       size += 2 * strlen(printerinfo->printer) + 2;
       size += printerinfo->bloblen;
+      break;
+    default:
+      break;
     }
   }
 
   return size;
 }
 
-static void rdpdr_send_available(RDPCLIENT *This) {
-
-  uint8 magic[4] = "rDAD";
-  uint32 driverlen, printerlen, bloblen;
-  int i;
+static void rdpdr_send_client_device_list_announce(void) {
+  /* DR_CORE_CLIENT_ANNOUNCE_RSP */
+  uint32 bloblen, disklen, flags;
+  size_t i;
   STREAM s;
   PRINTER *printerinfo;
+  DISK_DEVICE *diskinfo;
+  struct stream drv = {0}, prt = {0};
 
-  s = channel_init(This, This->rdpdr.channel, announcedata_size(This));
-  out_uint8a(s, magic, 4);
-  out_uint32_le(s, This->num_devices);
-
-  for (i = 0; i < This->num_devices; i++) {
-    out_uint32_le(s, This->rdpdr_device[i].device_type);
+  s = channel_init(rdpdr_channel, announcedata_size());
+  out_uint16_le(s, RDPDR_CTYP_CORE);
+  out_uint16_le(s, PAKID_CORE_DEVICE_LIST_ANNOUNCE);
+
+  out_uint32_le(s, g_num_devices);
+
+  for (i = 0; i < g_num_devices; i++) /* DEVICE_ANNOUNCE */
+  {
+    out_uint32_le(s, g_rdpdr_device[i].device_type);
     out_uint32_le(s, i); /* RDP Device ID */
-    /* Is it possible to use share names longer than 8 chars?
-       /astrand */
-    out_uint8p(s, This->rdpdr_device[i].name, 8);
+    out_uint8p(s, g_rdpdr_device[i].name,
+               8); /* preferredDosName, limited to 8 characters */
+    switch (g_rdpdr_device[i].device_type) {
+    case DEVICE_TYPE_DISK:
+      diskinfo = (DISK_DEVICE *)g_rdpdr_device[i].pdevice_data;
+
+      /* The RDP specification says that the DeviceData is supposed to be
+         a null-terminated Unicode string, but that does not work. In
+         practice the string is expected to be an ASCII string, like a
+         variable-length preferredDosName. */
+
+      disklen = strlen(diskinfo->name) + 1;
+
+      out_uint32_le(s, disklen);              /* DeviceDataLength */
+      out_uint8p(s, diskinfo->name, disklen); /* DeviceData */
+      break;
 
-    switch (This->rdpdr_device[i].device_type) {
     case DEVICE_TYPE_PRINTER:
-      printerinfo = (PRINTER *)This->rdpdr_device[i].pdevice_data;
+      printerinfo = (PRINTER *)g_rdpdr_device[i].pdevice_data;
 
-      driverlen = 2 * strlen(printerinfo->driver) + 2;
-      printerlen = 2 * strlen(printerinfo->printer) + 2;
-      bloblen = printerinfo->bloblen;
+      s_realloc(&prt, 512 * 4);
+      s_reset(&prt);
+      out_utf16s(&prt, printerinfo->printer);
+      s_mark_end(&prt);
+
+      s_realloc(&drv, 512 * 4);
+      s_reset(&drv);
+      out_utf16s(&drv, printerinfo->driver);
+      s_mark_end(&drv);
 
-      out_uint32_le(s, 24 + driverlen + printerlen +
-                           bloblen); /* length of extra info */
-      out_uint32_le(s, printerinfo->default_printer ? 2 : 0);
-      out_uint8s(s, 8); /* unknown */
-      out_uint32_le(s, driverlen);
-      out_uint32_le(s, printerlen);
-      out_uint32_le(s, bloblen);
-      rdp_out_unistr(This, s, printerinfo->driver, driverlen - 2);
-      rdp_out_unistr(This, s, printerinfo->printer, printerlen - 2);
-      out_uint8a(s, printerinfo->blob, bloblen);
+      bloblen = printerinfo->bloblen;
+      flags = 0;
+      if (printerinfo->default_printer)
+        flags |= RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER;
+
+      out_uint32_le(s, 24 + s_length(&drv) + s_length(&prt) +
+                           bloblen);    /* DeviceDataLength */
+      out_uint32_le(s, flags);          /* Flags */
+      out_uint32_le(s, 0);              /* Codepage */
+      out_uint32_le(s, 0);              /* PnPNameLen */
+      out_uint32_le(s, s_length(&drv)); /* DriverNameLen */
+      out_uint32_le(s, s_length(&prt)); /* PrinterNameLen */
+      out_uint32_le(s, bloblen);        /* CachedFieldsLen */
+      // out_uint8s(s, 0);       /* PnPName (Skipped) */
+      out_stream(s, &drv);                       /* DriverName */
+      out_stream(s, &prt);                       /* PrinterName */
+      out_uint8a(s, printerinfo->blob, bloblen); /* CachedPrinterConfigData */
 
       if (printerinfo->blob)
         xfree(printerinfo->blob); /* Blob is sent twice if reconnecting */
@@ -245,52 +328,50 @@
       out_uint32(s, 0);
     }
   }
-#if 0
-	out_uint32_le(s, 0x20);	/* Device type 0x20 - smart card */
-	out_uint32_le(s, 0);
-	out_uint8p(s, "SCARD", 5);
-	out_uint8s(s, 3);
-	out_uint32(s, 0);
-#endif
 
   s_mark_end(s);
-  channel_send(This, s, This->rdpdr.channel);
+  channel_send(s, rdpdr_channel);
 }
 
-static void rdpdr_send_completion(RDPCLIENT *This, uint32 device, uint32 id,
-                                  uint32 status, uint32 result, uint8 *buffer,
-                                  uint32 length) {
-  uint8 magic[4] = "rDCI";
+void rdpdr_send_completion(uint32 device, uint32 id, uint32 status,
+                           uint32 result, uint8 *buffer, uint32 length) {
   STREAM s;
 
-  s = channel_init(This, This->rdpdr.channel, 20 + length);
-  out_uint8a(s, magic, 4);
+#ifdef WITH_SCARD
+  scard_lock(SCARD_LOCK_RDPDR);
+#endif
+  s = channel_init(rdpdr_channel, 20 + length);
+  out_uint16_le(s, RDPDR_CTYP_CORE);
+  out_uint16_le(s, PAKID_CORE_DEVICE_IOCOMPLETION);
   out_uint32_le(s, device);
   out_uint32_le(s, id);
   out_uint32_le(s, status);
   out_uint32_le(s, result);
   out_uint8p(s, buffer, length);
   s_mark_end(s);
-  /* JIF */
-#ifdef WITH_DEBUG_RDP5
-  printf("--> rdpdr_send_completion\n");
+
+  logger(Protocol, Debug, "rdpdr_send_completion()");
   /* hexdump(s->channel_hdr + 8, s->end - s->channel_hdr - 8); */
+
+  channel_send(s, rdpdr_channel);
+#ifdef WITH_SCARD
+  scard_unlock(SCARD_LOCK_RDPDR);
 #endif
-  channel_send(This, s, This->rdpdr.channel);
 }
 
-static void rdpdr_process_irp(RDPCLIENT *This, STREAM s) {
+static void rdpdr_process_irp(STREAM s) {
   uint32 result = 0, length = 0, desired_access = 0, request, file, info_level,
-         buffer_len, id, major, minor, device, offset, bytes_in, bytes_out,
-         error_mode, share_mode, disposition, total_timeout, interval_timeout,
-         flags_and_attributes = 0;
+         buffer_len, id, major, minor, device, offset, bytes_out, share_mode,
+         disposition, total_timeout, interval_timeout, flags_and_attributes = 0;
+
+  char *filename;
+  uint32 filename_len;
 
-  char filename[PATH_MAX];
   uint8 *buffer, *pst_buf;
   struct stream out;
   DEVICE_FNS *fns;
-  BOOL rw_blocking = True;
-  NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
+  RD_BOOL rw_blocking = True;
+  RD_NTSTATUS status = RD_STATUS_INVALID_DEVICE_REQUEST;
 
   in_uint32_le(s, device);
   in_uint32_le(s, file);
@@ -298,11 +379,22 @@
   in_uint32_le(s, major);
   in_uint32_le(s, minor);
 
+  filename = NULL;
+
   buffer_len = 0;
   buffer = (uint8 *)xmalloc(1024);
   buffer[0] = 0;
 
-  switch (This->rdpdr_device[device].device_type) {
+  if (device >= RDPDR_MAX_DEVICES) {
+    logger(Protocol, Error,
+           "rdpdr_process_irp(), invalid irp device=0x%lx, file=0x%lx, "
+           "id=0x%lx, major=0x%lx, minor=0x%lx",
+           device, file, id, major, minor);
+    xfree(buffer);
+    return;
+  }
+
+  switch (g_rdpdr_device[device].device_type) {
   case DEVICE_TYPE_SERIAL:
 
     fns = &serial_fns;
@@ -327,9 +419,16 @@
     break;
 
   case DEVICE_TYPE_SCARD:
+#ifdef WITH_SCARD
+    fns = &scard_fns;
+    rw_blocking = False;
+    break;
+#endif
   default:
-
-    error("IRP for bad device %ld\n", device);
+    logger(Protocol, Error,
+           "rdpdr_process_irp(), received IRP for unknown device type %ld",
+           device);
+    xfree(buffer);
     return;
   }
 
@@ -338,52 +437,56 @@
 
     in_uint32_be(s, desired_access);
     in_uint8s(s, 0x08); /* unknown */
-    in_uint32_le(s, error_mode);
+    in_uint8s(s, 4);    /* skip error_mode */
     in_uint32_le(s, share_mode);
     in_uint32_le(s, disposition);
     in_uint32_le(s, flags_and_attributes);
     in_uint32_le(s, length);
 
     if (length && (length / 2) < 256) {
-      rdp_in_unistr(This, s, filename, length);
-      convert_to_unix_filename(filename);
-    } else {
-      filename[0] = 0;
+      rdp_in_unistr(s, length, &filename, &filename_len);
+      if (filename)
+        convert_to_unix_filename(filename);
     }
 
     if (!fns->create) {
-      status = STATUS_NOT_SUPPORTED;
+      status = RD_STATUS_NOT_SUPPORTED;
+      free(filename);
       break;
     }
 
-    status = fns->create(This, device, desired_access, share_mode, disposition,
+    status = fns->create(device, desired_access, share_mode, disposition,
                          flags_and_attributes, filename, &result);
+
+    free(filename);
     buffer_len = 1;
     break;
 
   case IRP_MJ_CLOSE:
     if (!fns->close) {
-      status = STATUS_NOT_SUPPORTED;
+      status = RD_STATUS_NOT_SUPPORTED;
       break;
     }
 
-    status = fns->close(This, file);
+    status = fns->close(file);
     break;
 
   case IRP_MJ_READ:
 
     if (!fns->read) {
-      status = STATUS_NOT_SUPPORTED;
+      status = RD_STATUS_NOT_SUPPORTED;
       break;
     }
 
     in_uint32_le(s, length);
     in_uint32_le(s, offset);
-#if WITH_DEBUG_RDP5
-    DEBUG(("RDPDR IRP Read (length: %d, offset: %d)\n", length, offset));
-#endif
-    if (!rdpdr_handle_ok(This, device, file)) {
-      status = STATUS_INVALID_HANDLE;
+
+    logger(Protocol, Debug,
+           "rdpdr_process_irp(), IRP Read length=%d, offset=%d", length,
+           offset);
+
+    if (!rdpdr_handle_ok(device, file)) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
 
@@ -391,10 +494,10 @@
     {
       buffer = (uint8 *)xrealloc((void *)buffer, length);
       if (!buffer) {
-        status = STATUS_CANCELLED;
+        status = RD_STATUS_CANCELLED;
         break;
       }
-      status = fns->read(This, file, buffer, length, offset, &result);
+      status = fns->read(file, buffer, length, offset, &result);
       buffer_len = result;
       break;
     }
@@ -402,81 +505,81 @@
     /* Add request to table */
     pst_buf = (uint8 *)xmalloc(length);
     if (!pst_buf) {
-      status = STATUS_CANCELLED;
+      status = RD_STATUS_CANCELLED;
       break;
     }
-    serial_get_timeout(This, file, length, &total_timeout, &interval_timeout);
-    if (add_async_iorequest(This, device, file, id, major, length, fns,
-                            total_timeout, interval_timeout, pst_buf, offset)) {
-      status = STATUS_PENDING;
+    serial_get_timeout(file, length, &total_timeout, &interval_timeout);
+    if (add_async_iorequest(device, file, id, major, length, fns, total_timeout,
+                            interval_timeout, pst_buf, offset)) {
+      status = RD_STATUS_PENDING;
       break;
     }
 
-    status = STATUS_CANCELLED;
+    status = RD_STATUS_CANCELLED;
     break;
   case IRP_MJ_WRITE:
 
     buffer_len = 1;
 
     if (!fns->write) {
-      status = STATUS_NOT_SUPPORTED;
+      status = RD_STATUS_NOT_SUPPORTED;
       break;
     }
 
     in_uint32_le(s, length);
     in_uint32_le(s, offset);
     in_uint8s(s, 0x18);
-#if WITH_DEBUG_RDP5
-    DEBUG(("RDPDR IRP Write (length: %d)\n", result));
-#endif
-    if (!rdpdr_handle_ok(This, device, file)) {
-      status = STATUS_INVALID_HANDLE;
+
+    logger(Protocol, Debug, "rdpdr_process_irp(), IRP Write length=%d", result);
+
+    if (!rdpdr_handle_ok(device, file)) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
 
     if (rw_blocking) /* Complete immediately */
     {
-      status = fns->write(This, file, s->p, length, offset, &result);
+      status = fns->write(file, s->p, length, offset, &result);
       break;
     }
 
     /* Add to table */
     pst_buf = (uint8 *)xmalloc(length);
     if (!pst_buf) {
-      status = STATUS_CANCELLED;
+      status = RD_STATUS_CANCELLED;
       break;
     }
 
     in_uint8a(s, pst_buf, length);
 
-    if (add_async_iorequest(This, device, file, id, major, length, fns, 0, 0,
-                            pst_buf, offset)) {
-      status = STATUS_PENDING;
+    if (add_async_iorequest(device, file, id, major, length, fns, 0, 0, pst_buf,
+                            offset)) {
+      status = RD_STATUS_PENDING;
       break;
     }
 
-    status = STATUS_CANCELLED;
+    status = RD_STATUS_CANCELLED;
     break;
 
   case IRP_MJ_QUERY_INFORMATION:
 
-    if (This->rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
-      status = STATUS_INVALID_HANDLE;
+    if (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
     in_uint32_le(s, info_level);
 
     out.data = out.p = buffer;
     out.size = sizeof(buffer);
-    status = disk_query_information(This, file, info_level, &out);
+    status = disk_query_information(file, info_level, &out);
     result = buffer_len = out.p - out.data;
 
     break;
 
   case IRP_MJ_SET_INFORMATION:
 
-    if (This->rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
-      status = STATUS_INVALID_HANDLE;
+    if (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
 
@@ -484,14 +587,14 @@
 
     out.data = out.p = buffer;
     out.size = sizeof(buffer);
-    status = disk_set_information(This, file, info_level, s, &out);
+    status = disk_set_information(file, info_level, s, &out);
     result = buffer_len = out.p - out.data;
     break;
 
   case IRP_MJ_QUERY_VOLUME_INFORMATION:
 
-    if (This->rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
-      status = STATUS_INVALID_HANDLE;
+    if (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
 
@@ -499,14 +602,14 @@
 
     out.data = out.p = buffer;
     out.size = sizeof(buffer);
-    status = disk_query_volume_information(This, file, info_level, &out);
+    status = disk_query_volume_information(file, info_level, &out);
     result = buffer_len = out.p - out.data;
     break;
 
   case IRP_MJ_DIRECTORY_CONTROL:
 
-    if (This->rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
-      status = STATUS_INVALID_HANDLE;
+    if (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
 
@@ -518,17 +621,19 @@
       in_uint32_le(s, length);
       in_uint8s(s, 0x17);
       if (length && length < 2 * 255) {
-        rdp_in_unistr(This, s, filename, length);
-        convert_to_unix_filename(filename);
-      } else {
-        filename[0] = 0;
+        rdp_in_unistr(s, length, &filename, &filename_len);
+        if (filename)
+          convert_to_unix_filename(filename);
       }
+
       out.data = out.p = buffer;
       out.size = sizeof(buffer);
-      status = disk_query_directory(This, file, info_level, filename, &out);
+      status = disk_query_directory(file, info_level, filename, &out);
       result = buffer_len = out.p - out.data;
       if (!buffer_len)
         buffer_len++;
+
+      free(filename);
       break;
 
     case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
@@ -539,61 +644,70 @@
 
       in_uint32_le(s, info_level); /* notify mask */
 
-      This->notify_stamp = True;
-
-      status = disk_create_notify(This, file, info_level);
+      status = disk_create_notify(file, info_level);
       result = 0;
 
-      if (status == STATUS_PENDING)
-        add_async_iorequest(This, device, file, id, major, length, fns, 0, 0,
-                            NULL, 0);
+      if (status == RD_STATUS_PENDING)
+        add_async_iorequest(device, file, id, major, length, fns, 0, 0, NULL,
+                            0);
       break;
 
     default:
 
-      status = STATUS_INVALID_PARAMETER;
+      status = RD_STATUS_INVALID_PARAMETER;
       /* JIF */
-      unimpl("IRP major=0x%x minor=0x%x\n", major, minor);
+      logger(
+          Protocol, Warning,
+          "rdpdr_process_irp(), unhandled minor opcode, major=0x%x, minor=0x%x",
+          major, minor);
     }
     break;
 
   case IRP_MJ_DEVICE_CONTROL:
 
     if (!fns->device_control) {
-      status = STATUS_NOT_SUPPORTED;
+      status = RD_STATUS_NOT_SUPPORTED;
       break;
     }
 
     in_uint32_le(s, bytes_out);
-    in_uint32_le(s, bytes_in);
+    in_uint8s(s, 4); /* skip  bytes_in */
     in_uint32_le(s, request);
     in_uint8s(s, 0x14);
 
     buffer = (uint8 *)xrealloc((void *)buffer, bytes_out + 0x14);
     if (!buffer) {
-      status = STATUS_CANCELLED;
+      status = RD_STATUS_CANCELLED;
       break;
     }
 
     out.data = out.p = buffer;
     out.size = sizeof(buffer);
-    status = fns->device_control(This, file, request, s, &out);
+
+#ifdef WITH_SCARD
+    scardSetInfo(g_epoch, device, id, bytes_out + 0x14);
+#endif
+    status = fns->device_control(file, request, s, &out);
     result = buffer_len = out.p - out.data;
 
     /* Serial SERIAL_WAIT_ON_MASK */
-    if (status == STATUS_PENDING) {
-      if (add_async_iorequest(This, device, file, id, major, length, fns, 0, 0,
-                              NULL, 0)) {
-        status = STATUS_PENDING;
+    if (status == RD_STATUS_PENDING) {
+      if (add_async_iorequest(device, file, id, major, length, fns, 0, 0, NULL,
+                              0)) {
+        status = RD_STATUS_PENDING;
         break;
       }
     }
+#ifdef WITH_SCARD
+    else if (status == (RD_STATUS_PENDING | 0xC0000000))
+      status = RD_STATUS_PENDING;
+#endif
     break;
 
   case IRP_MJ_LOCK_CONTROL:
 
-    if (This->rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
-      status = STATUS_INVALID_HANDLE;
+    if (g_rdpdr_device[device].device_type != DEVICE_TYPE_DISK) {
+      status = RD_STATUS_INVALID_HANDLE;
       break;
     }
 
@@ -603,129 +717,185 @@
     out.size = sizeof(buffer);
     /* FIXME: Perhaps consider actually *do*
        something here :-) */
-    status = STATUS_SUCCESS;
+    status = RD_STATUS_SUCCESS;
     result = buffer_len = out.p - out.data;
     break;
 
   default:
-    unimpl("IRP major=0x%x minor=0x%x\n", major, minor);
+    logger(
+        Protocol, Warning,
+        "rdpdr_process_irp(), unhandled major opcode, major=0x%x, minor=0x%x",
+        major, minor);
     break;
   }
 
-  if (status != STATUS_PENDING) {
-    rdpdr_send_completion(This, device, id, status, result, buffer, buffer_len);
+  if (status != RD_STATUS_PENDING) {
+    rdpdr_send_completion(device, id, status, result, buffer, buffer_len);
   }
   if (buffer)
     xfree(buffer);
   buffer = NULL;
 }
 
-static void rdpdr_send_clientcapabilty(RDPCLIENT *This) {
-  uint8 magic[4] = "rDPC";
+static void rdpdr_send_client_capability_response(void) {
+  /* DR_CORE_CAPABILITY_RSP */
   STREAM s;
+  s = channel_init(rdpdr_channel, 0x50);
 
-  s = channel_init(This, This->rdpdr.channel, 0x50);
-  out_uint8a(s, magic, 4);
-  out_uint32_le(s, 5);    /* count */
-  out_uint16_le(s, 1);    /* first */
-  out_uint16_le(s, 0x28); /* length */
-  out_uint32_le(s, 1);
-  out_uint32_le(s, 2);
-  out_uint16_le(s, 2);
-  out_uint16_le(s, 5);
-  out_uint16_le(s, 1);
-  out_uint16_le(s, 5);
-  out_uint16_le(s, 0xFFFF);
-  out_uint16_le(s, 0);
-  out_uint32_le(s, 0);
-  out_uint32_le(s, 3);
-  out_uint32_le(s, 0);
-  out_uint32_le(s, 0);
-  out_uint16_le(s, 2); /* second */
-  out_uint16_le(s, 8); /* length */
-  out_uint32_le(s, 1);
-  out_uint16_le(s, 3); /* third */
-  out_uint16_le(s, 8); /* length */
-  out_uint32_le(s, 1);
-  out_uint16_le(s, 4); /* fourth */
-  out_uint16_le(s, 8); /* length */
-  out_uint32_le(s, 1);
-  out_uint16_le(s, 5); /* fifth */
-  out_uint16_le(s, 8); /* length */
-  out_uint32_le(s, 1);
+  out_uint16_le(s, RDPDR_CTYP_CORE);              /* Header */
+  out_uint16_le(s, PAKID_CORE_CLIENT_CAPABILITY); /* Header */
+  out_uint16_le(s, 5);                            /* numCapabilities */
+  out_uint16_le(s, 0);                            /* Padding */
+
+  out_uint16_le(s, CAP_GENERAL_TYPE);              /* CapabilityType */
+  out_uint16_le(s, 0x28);                          /* CapabilityLength */
+  out_uint32_le(s, GENERAL_CAPABILITY_VERSION_01); /* Version */
+  out_uint32_le(s, 0);                             /* osType */
+  out_uint32_le(s, 0);                             /* osVersion */
+  out_uint16_le(s, 1);                             /* protocolMajorVersion */
+  out_uint16_le(s, 5);                             /* protocolMinorVersion */
+  out_uint32_le(s, ALL_RDPDR_IRP_MJ);              /* ioCode1 */
+  out_uint32_le(s, 0);                             /* ioCode2 */
+  out_uint32_le(s, RDPDR_DEVICE_REMOVE_PDUS |
+                       RDPDR_CLIENT_DISPLAY_NAME_PDU); /* extendedPDU */
+  out_uint32_le(s, 0);                                 /* extraFlags1 */
+  out_uint32_le(s, 0);                                 /* extraFlags2 */
+
+  out_uint16_le(s, CAP_PRINTER_TYPE);            /* CapabilityType */
+  out_uint16_le(s, 8);                           /* CapabilityLength */
+  out_uint32_le(s, PRINT_CAPABILITY_VERSION_01); /* Version */
+
+  out_uint16_le(s, CAP_PORT_TYPE);              /* CapabilityType */
+  out_uint16_le(s, 8);                          /* CapabilityLength */
+  out_uint32_le(s, PORT_CAPABILITY_VERSION_01); /* Version */
+
+  out_uint16_le(s, CAP_DRIVE_TYPE);              /* CapabilityType */
+  out_uint16_le(s, 8);                           /* CapabilityLength */
+  out_uint32_le(s, DRIVE_CAPABILITY_VERSION_02); /* Version */
+
+  out_uint16_le(s, CAP_SMARTCARD_TYPE);              /* CapabilityType */
+  out_uint16_le(s, 8);                               /* CapabilityLength */
+  out_uint32_le(s, SMARTCARD_CAPABILITY_VERSION_01); /* Version */
 
   s_mark_end(s);
-  channel_send(This, s, This->rdpdr.channel);
+  channel_send(s, rdpdr_channel);
 }
 
-static void rdpdr_process(RDPCLIENT *This, STREAM s) {
+static void rdpdr_process(STREAM s) {
   uint32 handle;
-  uint8 *magic;
+  uint16 vmin;
+  uint16 component;
+  uint16 pakid;
+  struct stream packet = *s;
+
+  logger(Protocol, Debug, "rdpdr_process()");
+  /* hexdump(s->p, s->end - s->p); */
+
+  in_uint16(s, component);
+  in_uint16(s, pakid);
+
+  if (component == RDPDR_CTYP_CORE) {
+    switch (pakid) {
+    case PAKID_CORE_DEVICE_IOREQUEST:
+      rdpdr_process_irp(s);
+      break;
+
+    case PAKID_CORE_SERVER_ANNOUNCE:
+      /* DR_CORE_SERVER_ANNOUNCE_REQ */
+      in_uint8s(s, 2);       /* skip versionMajor */
+      in_uint16_le(s, vmin); /* VersionMinor */
+
+      in_uint32_le(s, g_client_id); /* ClientID */
+
+      /* g_client_id is sent back to server,
+         so lets check that we actually got
+         valid data from stream to prevent
+         that we leak back data to server */
+      if (!s_check(s)) {
+        rdp_protocol_error(
+            "rdpdr_process(), consume of g_client_id from stream did overrun",
+            &packet);
+      }
+
+      /* The RDP client is responsibility to provide a random client id
+         if server version is < 12 */
+      if (vmin < 0x000c)
+        g_client_id = 0x815ed39d; /* IP address (use 127.0.0.1) 0x815ed39d */
+      g_epoch++;
+
+#if WITH_SCARD
+      /*
+       * We need to release all SCARD contexts to end all
+       * current transactions and pending calls
+       */
+      scard_release_all_contexts();
+
+      /*
+       * According to [MS-RDPEFS] 3.2.5.1.2:
+       *
+       * If this packet appears after a sequence of other packets,
+       * it is a signal that the server has reconnected to a new session
+       * and the whole sequence has been reset. The client MUST treat
+       * this packet as the beginning of a new sequence.
+       * The client MUST also cancel all outstanding requests and release
+       * previous references to all devices.
+       *
+       * If any problem arises in the future, please, pay attention to the
+       * "If this packet appears after a sequence of other packets" part
+       *
+       */
 
-#if WITH_DEBUG_RDP5
-  printf("--- rdpdr_process ---\n");
-  hexdump(s->p, s->end - s->p);
 #endif
-  in_uint8p(s, magic, 4);
 
-  if ((magic[0] == 'r') && (magic[1] == 'D')) {
-    if ((magic[2] == 'R') && (magic[3] == 'I')) {
-      rdpdr_process_irp(This, s);
-      return;
-    }
-    if ((magic[2] == 'n') && (magic[3] == 'I')) {
-      rdpdr_send_connect(This);
-      rdpdr_send_name(This);
-      return;
-    }
-    if ((magic[2] == 'C') && (magic[3] == 'C')) {
-      /* connect from server */
-      rdpdr_send_clientcapabilty(This);
-      rdpdr_send_available(This);
-      return;
-    }
-    if ((magic[2] == 'r') && (magic[3] == 'd')) {
-      /* connect to a specific resource */
+      rdpdr_send_client_announce_reply();
+      rdpdr_send_client_name_request();
+      break;
+
+    case PAKID_CORE_CLIENTID_CONFIRM:
+      rdpdr_send_client_device_list_announce();
+      break;
+
+    case PAKID_CORE_DEVICE_REPLY:
       in_uint32(s, handle);
-#if WITH_DEBUG_RDP5
-      DEBUG(("RDPDR: Server connected to resource %d\n", handle));
-#endif
-      return;
-    }
-    if ((magic[2] == 'P') && (magic[3] == 'S')) {
-      /* server capability */
-      return;
-    }
-  }
-  if ((magic[0] == 'R') && (magic[1] == 'P')) {
-    if ((magic[2] == 'C') && (magic[3] == 'P')) {
-      printercache_process(This, s);
-      return;
+      logger(Protocol, Debug,
+             "rdpdr_process(), server connected to resource %d", handle);
+      break;
+
+    case PAKID_CORE_SERVER_CAPABILITY:
+      rdpdr_send_client_capability_response();
+      break;
+
+    default:
+      logger(Protocol, Debug, "rdpdr_process(), pakid 0x%x of component 0x%x",
+             pakid, component);
+      break;
     }
-  }
-  unimpl("RDPDR packet type %c%c%c%c\n", magic[0], magic[1], magic[2],
-         magic[3]);
+  } else if (component == RDPDR_CTYP_PRN) {
+    if (pakid == PAKID_PRN_CACHE_DATA)
+      printercache_process(s);
+  } else
+    logger(Protocol, Warning, "rdpdr_process(), unhandled component 0x%x",
+           component);
 }
 
-BOOL rdpdr_init(RDPCLIENT *This) {
-  if (This->num_devices > 0) {
-    This->rdpdr.channel = channel_register(
-        This, "rdpdr", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_COMPRESS_RDP,
-        rdpdr_process);
-  }
+RD_BOOL
+rdpdr_init() {
+  rdpdr_channel = channel_register(
+      "rdpdr", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_COMPRESS_RDP,
+      rdpdr_process);
 
-  return (This->rdpdr.channel != NULL);
+  return (rdpdr_channel != NULL);
 }
 
 /* Add file descriptors of pending io request to select() */
-void rdpdr_add_fds(RDPCLIENT *This, int *n, fd_set *rfds, fd_set *wfds,
-                   struct timeval *tv, BOOL *timeout) {
+void rdpdr_add_fds(int *n, fd_set *rfds, fd_set *wfds, struct timeval *tv,
+                   RD_BOOL *timeout) {
   uint32 select_timeout =
-      0; /* Timeout value to be used for select() (in millisecons). */
+      0; /* Timeout value to be used for select() (in milliseconds). */
   struct async_iorequest *iorq;
   char c;
 
-  iorq = This->iorequest;
+  iorq = g_iorequest;
   while (iorq != NULL) {
     if (iorq->fd != 0) {
       switch (iorq->major) {
@@ -736,14 +906,14 @@
            support for reconnects. */
 
         FD_SET(iorq->fd, rfds);
-        *n = MAX(*n, iorq->fd);
+        *n = MAX(*n, (int)iorq->fd);
 
         /* Check if io request timeout is smaller than current (but not 0). */
         if (iorq->timeout &&
             (select_timeout == 0 || iorq->timeout < select_timeout)) {
           /* Set new timeout */
           select_timeout = iorq->timeout;
-          This->min_timeout_fd = iorq->fd; /* Remember fd */
+          g_min_timeout_fd = iorq->fd; /* Remember fd */
           tv->tv_sec = select_timeout / 1000;
           tv->tv_usec = (select_timeout % 1000) * 1000;
           *timeout = True;
@@ -753,7 +923,7 @@
             (select_timeout == 0 || iorq->itv_timeout < select_timeout)) {
           /* Set new timeout */
           select_timeout = iorq->itv_timeout;
-          This->min_timeout_fd = iorq->fd; /* Remember fd */
+          g_min_timeout_fd = iorq->fd; /* Remember fd */
           tv->tv_sec = select_timeout / 1000;
           tv->tv_usec = (select_timeout % 1000) * 1000;
           *timeout = True;
@@ -767,7 +937,7 @@
           break;
 
         FD_SET(iorq->fd, wfds);
-        *n = MAX(*n, iorq->fd);
+        *n = MAX(*n, (int)iorq->fd);
         break;
 
       case IRP_MJ_DEVICE_CONTROL:
@@ -781,8 +951,7 @@
   }
 }
 
-struct async_iorequest *rdpdr_remove_iorequest(RDPCLIENT *This,
-                                               struct async_iorequest *prev,
+struct async_iorequest *rdpdr_remove_iorequest(struct async_iorequest *prev,
                                                struct async_iorequest *iorq) {
   if (!iorq)
     return NULL;
@@ -795,7 +964,7 @@
     iorq = prev->next;
   } else {
     /* Even if NULL */
-    This->iorequest = iorq->next;
+    g_iorequest = iorq->next;
     xfree(iorq);
     iorq = NULL;
   }
@@ -804,9 +973,8 @@
 
 /* Check if select() returned with one of the rdpdr file descriptors, and
  * complete io if it did */
-static void _rdpdr_check_fds(RDPCLIENT *This, fd_set *rfds, fd_set *wfds,
-                             BOOL timed_out) {
-  NTSTATUS status;
+static void _rdpdr_check_fds(fd_set *rfds, fd_set *wfds, RD_BOOL timed_out) {
+  RD_NTSTATUS status;
   uint32 result = 0;
   DEVICE_FNS *fns;
   struct async_iorequest *iorq;
@@ -819,21 +987,20 @@
   if (timed_out) {
     /* check serial iv_timeout */
 
-    iorq = This->iorequest;
+    iorq = g_iorequest;
     prev = NULL;
     while (iorq != NULL) {
-      if (iorq->fd == This->min_timeout_fd) {
+      if (iorq->fd == g_min_timeout_fd) {
         if ((iorq->partial_len > 0) &&
-            (This->rdpdr_device[iorq->device].device_type ==
-             DEVICE_TYPE_SERIAL)) {
+            (g_rdpdr_device[iorq->device].device_type == DEVICE_TYPE_SERIAL)) {
 
           /* iv_timeout between 2 chars, send partial_len */
           /*printf("RDPDR: IVT total %u bytes read of %u\n", iorq->partial_len,
            * iorq->length); */
-          rdpdr_send_completion(This, iorq->device, iorq->id, STATUS_SUCCESS,
+          rdpdr_send_completion(iorq->device, iorq->id, RD_STATUS_SUCCESS,
                                 iorq->partial_len, iorq->buffer,
                                 iorq->partial_len);
-          iorq = rdpdr_remove_iorequest(This, prev, iorq);
+          iorq = rdpdr_remove_iorequest(prev, iorq);
           return;
         } else {
           break;
@@ -848,11 +1015,11 @@
         iorq = iorq->next;
     }
 
-    rdpdr_abort_io(This, This->min_timeout_fd, 0, STATUS_TIMEOUT);
+    rdpdr_abort_io(g_min_timeout_fd, 0, RD_STATUS_TIMEOUT);
     return;
   }
 
-  iorq = This->iorequest;
+  iorq = g_iorequest;
   prev = NULL;
   while (iorq != NULL) {
     if (iorq->fd != 0) {
@@ -867,27 +1034,27 @@
                          : (iorq->length - iorq->partial_len);
           /* never read larger chunks than 8k - chances are that it will block
            */
-          status = fns->read(This, iorq->fd, iorq->buffer + iorq->partial_len,
+          status = fns->read(iorq->fd, iorq->buffer + iorq->partial_len,
                              req_size, iorq->offset, &result);
 
           if ((long)result > 0) {
             iorq->partial_len += result;
             iorq->offset += result;
           }
-#if WITH_DEBUG_RDP5
-          DEBUG(("RDPDR: %d bytes of data read\n", result));
-#endif
+
+          logger(Protocol, Debug, "_rdpdr_check_fds(), %d bytes of data read",
+                 result);
+
           /* only delete link if all data has been transfered */
           /* or if result was 0 and status success - EOF      */
           if ((iorq->partial_len == iorq->length) || (result == 0)) {
-#if WITH_DEBUG_RDP5
-            DEBUG(("RDPDR: AIO total %u bytes read of %u\n", iorq->partial_len,
-                   iorq->length));
-#endif
-            rdpdr_send_completion(This, iorq->device, iorq->id, status,
+            logger(Protocol, Debug,
+                   "_rdpdr_check_fds(), AIO total %u bytes read of %u",
+                   iorq->partial_len, iorq->length);
+            rdpdr_send_completion(iorq->device, iorq->id, status,
                                   iorq->partial_len, iorq->buffer,
                                   iorq->partial_len);
-            iorq = rdpdr_remove_iorequest(This, prev, iorq);
+            iorq = rdpdr_remove_iorequest(prev, iorq);
           }
         }
         break;
@@ -902,7 +1069,7 @@
 
           /* never write larger chunks than 8k - chances are that it will block
            */
-          status = fns->write(This, iorq->fd, iorq->buffer + iorq->partial_len,
+          status = fns->write(iorq->fd, iorq->buffer + iorq->partial_len,
                               req_size, iorq->offset, &result);
 
           if ((long)result > 0) {
@@ -910,35 +1077,34 @@
             iorq->offset += result;
           }
 
-#if WITH_DEBUG_RDP5
-          DEBUG(("RDPDR: %d bytes of data written\n", result));
-#endif
+          logger(Protocol, Debug,
+                 "_rdpdr_check_fds(), %d bytes of data written", result);
+
           /* only delete link if all data has been transfered */
           /* or we couldn't write */
           if ((iorq->partial_len == iorq->length) || (result == 0)) {
-#if WITH_DEBUG_RDP5
-            DEBUG(("RDPDR: AIO total %u bytes written of %u\n",
-                   iorq->partial_len, iorq->length));
-#endif
-            rdpdr_send_completion(This, iorq->device, iorq->id, status,
+            logger(Protocol, Debug,
+                   "_rdpdr_check_fds(), AIO total %u bytes written of %u",
+                   iorq->partial_len, iorq->length);
+            rdpdr_send_completion(iorq->device, iorq->id, status,
                                   iorq->partial_len, (uint8 *)"", 1);
 
-            iorq = rdpdr_remove_iorequest(This, prev, iorq);
+            iorq = rdpdr_remove_iorequest(prev, iorq);
           }
         }
         break;
       case IRP_MJ_DEVICE_CONTROL:
-        if (serial_get_event(This, iorq->fd, &result)) {
+        if (serial_get_event(iorq->fd, &result)) {
           buffer = (uint8 *)xrealloc((void *)buffer, 0x14);
           out.data = out.p = buffer;
           out.size = sizeof(buffer);
           out_uint32_le(&out, result);
           result = buffer_len = out.p - out.data;
-          status = STATUS_SUCCESS;
-          rdpdr_send_completion(This, iorq->device, iorq->id, status, result,
-                                buffer, buffer_len);
+          status = RD_STATUS_SUCCESS;
+          rdpdr_send_completion(iorq->device, iorq->id, status, result, buffer,
+                                buffer_len);
           xfree(buffer);
-          iorq = rdpdr_remove_iorequest(This, prev, iorq);
+          iorq = rdpdr_remove_iorequest(prev, iorq);
         }
 
         break;
@@ -950,22 +1116,21 @@
   }
 
   /* Check notify */
-  iorq = This->iorequest;
+  iorq = g_iorequest;
   prev = NULL;
   while (iorq != NULL) {
     if (iorq->fd != 0) {
       switch (iorq->major) {
 
       case IRP_MJ_DIRECTORY_CONTROL:
-        if (This->rdpdr_device[iorq->device].device_type == DEVICE_TYPE_DISK) {
+        if (g_rdpdr_device[iorq->device].device_type == DEVICE_TYPE_DISK) {
 
-          if (This->notify_stamp) {
-            This->notify_stamp = False;
-            status = disk_check_notify(This, iorq->fd);
-            if (status != STATUS_PENDING) {
-              rdpdr_send_completion(This, iorq->device, iorq->id, status, 0,
-                                    NULL, 0);
-              iorq = rdpdr_remove_iorequest(This, prev, iorq);
+          if (g_notify_stamp) {
+            g_notify_stamp = False;
+            status = disk_check_notify(iorq->fd);
+            if (status != RD_STATUS_PENDING) {
+              rdpdr_send_completion(iorq->device, iorq->id, status, 0, NULL, 0);
+              iorq = rdpdr_remove_iorequest(prev, iorq);
             }
           }
         }
@@ -979,8 +1144,7 @@
   }
 }
 
-void rdpdr_check_fds(RDPCLIENT *This, fd_set *rfds, fd_set *wfds,
-                     BOOL timed_out) {
+void rdpdr_check_fds(fd_set *rfds, fd_set *wfds, RD_BOOL timed_out) {
   fd_set dummy;
 
   FD_ZERO(&dummy);
@@ -989,27 +1153,28 @@
      any serial wait event must be done before read block will be sent
    */
 
-  _rdpdr_check_fds(This, &dummy, &dummy, False);
-  _rdpdr_check_fds(This, rfds, wfds, timed_out);
+  _rdpdr_check_fds(&dummy, &dummy, False);
+  _rdpdr_check_fds(rfds, wfds, timed_out);
 }
 
 /* Abort a pending io request for a given handle and major */
-BOOL rdpdr_abort_io(RDPCLIENT *This, uint32 fd, uint32 major, NTSTATUS status) {
+RD_BOOL
+rdpdr_abort_io(uint32 fd, uint32 major, RD_NTSTATUS status) {
   uint32 result;
   struct async_iorequest *iorq;
   struct async_iorequest *prev;
 
-  iorq = This->iorequest;
+  iorq = g_iorequest;
   prev = NULL;
   while (iorq != NULL) {
     /* Only remove from table when major is not set, or when correct major is
        supplied. Abort read should not abort a write io request. */
     if ((iorq->fd == fd) && (major == 0 || iorq->major == major)) {
       result = 0;
-      rdpdr_send_completion(This, iorq->device, iorq->id, status, result,
-                            (uint8 *)"", 1);
+      rdpdr_send_completion(iorq->device, iorq->id, status, result, (uint8 *)"",
+                            1);
 
-      iorq = rdpdr_remove_iorequest(This, prev, iorq);
+      iorq = rdpdr_remove_iorequest(prev, iorq);
       return True;
     }
 
