--- /home/V1SCAN/CWE-122/FormattedUsed/orders-reactos-0.4.13.c	2023-12-12 03:51:20.938350018 +0900
+++ /home/V1SCAN/CWE-122/FormattedPatch/NEW##CVE-2018-8800##0##rdesktop@@rdesktop##orders.c	2023-12-12 03:51:21.230070399 +0900
@@ -1,11 +1,11 @@
 /* -*- c-basic-offset: 8 -*-
    rdesktop: A Remote Desktop Protocol client.
    RDP order processing
-   Copyright (C) Matthew Chapman 1999-2005
+   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008
 
-   This program is free software; you can redistribute it and/or modify
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
+   the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -13,14 +13,17 @@
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "orders.h"
 #include "rdesktop.h"
 
+extern uint8 *g_next_packet;
+static RDP_ORDER_STATE g_order_state;
+extern RDP_VERSION g_rdp_version;
+
 /* Read field indicating which parameters are present */
 static void rdp_in_present(STREAM s, uint32 *present, uint8 flags, int size) {
   uint8 bits;
@@ -45,7 +48,7 @@
 }
 
 /* Read a co-ordinate (16-bit, or 8-bit delta) */
-static void rdp_in_coord(STREAM s, sint16 *coord, BOOL delta) {
+static void rdp_in_coord(STREAM s, sint16 *coord, RD_BOOL delta) {
   sint8 change;
 
   if (delta) {
@@ -84,7 +87,7 @@
 }
 
 /* Parse bounds information */
-static BOOL rdp_parse_bounds(STREAM s, BOUNDS *bounds) {
+static RD_BOOL rdp_parse_bounds(STREAM s, BOUNDS *bounds) {
   uint8 present;
 
   in_uint8(s, present);
@@ -113,7 +116,7 @@
 }
 
 /* Parse a pen */
-static BOOL rdp_parse_pen(STREAM s, PEN *pen, uint32 present) {
+static RD_BOOL rdp_parse_pen(STREAM s, PEN *pen, uint32 present) {
   if (present & 1)
     in_uint8(s, pen->style);
 
@@ -126,8 +129,31 @@
   return s_check(s);
 }
 
+static void setup_brush(BRUSH *out_brush, BRUSH *in_brush) {
+  BRUSHDATA *brush_data;
+  uint8 cache_idx;
+  uint8 colour_code;
+
+  memcpy(out_brush, in_brush, sizeof(BRUSH));
+  if (out_brush->style & 0x80) {
+    colour_code = out_brush->style & 0x0f;
+    cache_idx = out_brush->pattern[0];
+    brush_data = cache_get_brush_data(colour_code, cache_idx);
+    if ((brush_data == NULL) || (brush_data->data == NULL)) {
+      logger(Graphics, Error,
+             "setup_brush(), error getting brush data, style %x",
+             out_brush->style);
+      out_brush->bd = NULL;
+      memset(out_brush->pattern, 0, 8);
+    } else {
+      out_brush->bd = brush_data;
+    }
+    out_brush->style = 3;
+  }
+}
+
 /* Parse a brush */
-static BOOL rdp_parse_brush(STREAM s, BRUSH *brush, uint32 present) {
+static RD_BOOL rdp_parse_brush(STREAM s, BRUSH *brush, uint32 present) {
   if (present & 1)
     in_uint8(s, brush->xorigin);
 
@@ -147,8 +173,8 @@
 }
 
 /* Process a destination blt order */
-static void process_destblt(RDPCLIENT *This, STREAM s, DESTBLT_ORDER *os,
-                            uint32 present, BOOL delta) {
+static void process_destblt(STREAM s, DESTBLT_ORDER *os, uint32 present,
+                            RD_BOOL delta) {
   if (present & 0x01)
     rdp_in_coord(s, &os->x, delta);
 
@@ -164,19 +190,18 @@
   if (present & 0x10)
     in_uint8(s, os->opcode);
 
-  DEBUG(("DESTBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d)\n", os->opcode, os->x, os->y,
-         os->cx, os->cy));
+  logger(Graphics, Debug,
+         "process_destblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d", os->opcode,
+         os->x, os->y, os->cx, os->cy);
 
-#if 0
-	ui_destblt(This, ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy);
-#else
-  ui_destblt(This, os->opcode, os->x, os->y, os->cx, os->cy);
-#endif
+  ui_destblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy);
 }
 
 /* Process a pattern blt order */
-static void process_patblt(RDPCLIENT *This, STREAM s, PATBLT_ORDER *os,
-                           uint32 present, BOOL delta) {
+static void process_patblt(STREAM s, PATBLT_ORDER *os, uint32 present,
+                           RD_BOOL delta) {
+  BRUSH brush;
+
   if (present & 0x0001)
     rdp_in_coord(s, &os->x, delta);
 
@@ -200,22 +225,21 @@
 
   rdp_parse_brush(s, &os->brush, present >> 7);
 
-  DEBUG(("PATBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,bs=%d,bg=0x%x,fg=0x%x)\n",
+  logger(Graphics, Debug,
+         "process_patblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, bs=%d, bg=0x%x, "
+         "fg=0x%x)",
          os->opcode, os->x, os->y, os->cx, os->cy, os->brush.style,
-         os->bgcolour, os->fgcolour));
+         os->bgcolour, os->fgcolour);
 
-#if 0
-	ui_patblt(This, ROP2_P(os->opcode), os->x, os->y, os->cx, os->cy,
-		  &os->brush, os->bgcolour, os->fgcolour);
-#else
-  ui_patblt(This, os->opcode, os->x, os->y, os->cx, os->cy, &os->brush,
+  setup_brush(&brush, &os->brush);
+
+  ui_patblt(ROP2_P(os->opcode), os->x, os->y, os->cx, os->cy, &brush,
             os->bgcolour, os->fgcolour);
-#endif
 }
 
 /* Process a screen blt order */
-static void process_screenblt(RDPCLIENT *This, STREAM s, SCREENBLT_ORDER *os,
-                              uint32 present, BOOL delta) {
+static void process_screenblt(STREAM s, SCREENBLT_ORDER *os, uint32 present,
+                              RD_BOOL delta) {
   if (present & 0x0001)
     rdp_in_coord(s, &os->x, delta);
 
@@ -237,20 +261,18 @@
   if (present & 0x0040)
     rdp_in_coord(s, &os->srcy, delta);
 
-  DEBUG(("SCREENBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,srcx=%d,srcy=%d)\n",
-         os->opcode, os->x, os->y, os->cx, os->cy, os->srcx, os->srcy));
+  logger(Graphics, Debug,
+         "process_screenblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, srcx=%d, "
+         "srcy=%d)",
+         os->opcode, os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);
 
-#if 0
-	ui_screenblt(This, ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, os->srcx, os->srcy);
-#else
-  ui_screenblt(This, os->opcode, os->x, os->y, os->cx, os->cy, os->srcx,
+  ui_screenblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, os->srcx,
                os->srcy);
-#endif
 }
 
 /* Process a line order */
-static void process_line(RDPCLIENT *This, STREAM s, LINE_ORDER *os,
-                         uint32 present, BOOL delta) {
+static void process_line(STREAM s, LINE_ORDER *os, uint32 present,
+                         RD_BOOL delta) {
   if (present & 0x0001)
     in_uint16_le(s, os->mixmode);
 
@@ -274,25 +296,22 @@
 
   rdp_parse_pen(s, &os->pen, present >> 7);
 
-  DEBUG(("LINE(op=0x%x,sx=%d,sy=%d,dx=%d,dy=%d,fg=0x%x)\n", os->opcode,
-         os->startx, os->starty, os->endx, os->endy, os->pen.colour));
+  logger(Graphics, Debug,
+         "process_line(), op=0x%x, sx=%d, sy=%d, dx=%d, dy=%d, fg=0x%x)",
+         os->opcode, os->startx, os->starty, os->endx, os->endy,
+         os->pen.colour);
 
   if (os->opcode < 0x01 || os->opcode > 0x10) {
-    error("bad ROP2 0x%x\n", os->opcode);
+    logger(Graphics, Error, "process_line(), bad ROP2 0x%x", os->opcode);
     return;
   }
 
-#if 0
-	ui_line(This, os->opcode - 1, os->startx, os->starty, os->endx, os->endy, &os->pen);
-#else
-  ui_line(This, os->opcode, os->startx, os->starty, os->endx, os->endy,
-          &os->pen);
-#endif
+  ui_line(os->opcode - 1, os->startx, os->starty, os->endx, os->endy, &os->pen);
 }
 
 /* Process an opaque rectangle order */
-static void process_rect(RDPCLIENT *This, STREAM s, RECT_ORDER *os,
-                         uint32 present, BOOL delta) {
+static void process_rect(STREAM s, RECT_ORDER *os, uint32 present,
+                         RD_BOOL delta) {
   uint32 i;
   if (present & 0x01)
     rdp_in_coord(s, &os->x, delta);
@@ -321,15 +340,15 @@
     os->colour = (os->colour & 0xff00ffff) | (i << 16);
   }
 
-  DEBUG(("RECT(x=%d,y=%d,cx=%d,cy=%d,fg=0x%x)\n", os->x, os->y, os->cx, os->cy,
-         os->colour));
+  logger(Graphics, Debug, "process_rect(), x=%d, y=%d, cx=%d, cy=%d, fg=0x%x",
+         os->x, os->y, os->cx, os->cy, os->colour);
 
-  ui_rect(This, os->x, os->y, os->cx, os->cy, os->colour);
+  ui_rect(os->x, os->y, os->cx, os->cy, os->colour);
 }
 
 /* Process a desktop save order */
-static void process_desksave(RDPCLIENT *This, STREAM s, DESKSAVE_ORDER *os,
-                             uint32 present, BOOL delta) {
+static void process_desksave(STREAM s, DESKSAVE_ORDER *os, uint32 present,
+                             RD_BOOL delta) {
   int width, height;
 
   if (present & 0x01)
@@ -350,22 +369,23 @@
   if (present & 0x20)
     in_uint8(s, os->action);
 
-  DEBUG(("DESKSAVE(l=%d,t=%d,r=%d,b=%d,off=%d,op=%d)\n", os->left, os->top,
-         os->right, os->bottom, os->offset, os->action));
+  logger(Graphics, Debug,
+         "process_desksave(), l=%d, t=%d, r=%d, b=%d, off=%d, op=%d", os->left,
+         os->top, os->right, os->bottom, os->offset, os->action);
 
   width = os->right - os->left + 1;
   height = os->bottom - os->top + 1;
 
   if (os->action == 0)
-    ui_desktop_save(This, os->offset, os->left, os->top, width, height);
+    ui_desktop_save(os->offset, os->left, os->top, width, height);
   else
-    ui_desktop_restore(This, os->offset, os->left, os->top, width, height);
+    ui_desktop_restore(os->offset, os->left, os->top, width, height);
 }
 
 /* Process a memory blt order */
-static void process_memblt(RDPCLIENT *This, STREAM s, MEMBLT_ORDER *os,
-                           uint32 present, BOOL delta) {
-  HBITMAP bitmap;
+static void process_memblt(STREAM s, MEMBLT_ORDER *os, uint32 present,
+                           RD_BOOL delta) {
+  RD_HBITMAP bitmap;
 
   if (present & 0x0001) {
     in_uint8(s, os->cache_id);
@@ -396,25 +416,23 @@
   if (present & 0x0100)
     in_uint16_le(s, os->cache_idx);
 
-  DEBUG(("MEMBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,id=%d,idx=%d)\n", os->opcode,
-         os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx));
+  logger(Graphics, Debug,
+         "process_memblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, id=%d, idx=%d",
+         os->opcode, os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx);
 
-  bitmap = cache_get_bitmap(This, os->cache_id, os->cache_idx);
+  bitmap = cache_get_bitmap(os->cache_id, os->cache_idx);
   if (bitmap == NULL)
     return;
 
-#if 0
-	ui_memblt(This, ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, bitmap, os->srcx, os->srcy);
-#else
-  ui_memblt(This, os->opcode, os->x, os->y, os->cx, os->cy, bitmap, os->srcx,
+  ui_memblt(ROP2_S(os->opcode), os->x, os->y, os->cx, os->cy, bitmap, os->srcx,
             os->srcy);
-#endif
 }
 
 /* Process a 3-way blt order */
-static void process_triblt(RDPCLIENT *This, STREAM s, TRIBLT_ORDER *os,
-                           uint32 present, BOOL delta) {
-  HBITMAP bitmap;
+static void process_triblt(STREAM s, TRIBLT_ORDER *os, uint32 present,
+                           RD_BOOL delta) {
+  RD_HBITMAP bitmap;
+  BRUSH brush;
 
   if (present & 0x000001) {
     in_uint8(s, os->cache_id);
@@ -456,25 +474,28 @@
   if (present & 0x010000)
     in_uint16_le(s, os->unknown);
 
-  DEBUG(("TRIBLT(op=0x%x,x=%d,y=%d,cx=%d,cy=%d,id=%d,idx=%d,bs=%d,bg=0x%x,fg="
-         "0x%x)\n",
+  logger(Graphics, Debug,
+         "process_triblt(), op=0x%x, x=%d, y=%d, cx=%d, cy=%d, id=%d, idx=%d, "
+         "bs=%d, bg=0x%x, fg=0x%x",
          os->opcode, os->x, os->y, os->cx, os->cy, os->cache_id, os->cache_idx,
-         os->brush.style, os->bgcolour, os->fgcolour));
+         os->brush.style, os->bgcolour, os->fgcolour);
 
-  bitmap = cache_get_bitmap(This, os->cache_id, os->cache_idx);
+  bitmap = cache_get_bitmap(os->cache_id, os->cache_idx);
   if (bitmap == NULL)
     return;
 
-  ui_triblt(This, os->opcode, os->x, os->y, os->cx, os->cy, bitmap, os->srcx,
-            os->srcy, &os->brush, os->bgcolour, os->fgcolour);
+  setup_brush(&brush, &os->brush);
+
+  ui_triblt(os->opcode, os->x, os->y, os->cx, os->cy, bitmap, os->srcx,
+            os->srcy, &brush, os->bgcolour, os->fgcolour);
 }
 
 /* Process a polygon order */
-static void process_polygon(RDPCLIENT *This, STREAM s, POLYGON_ORDER *os,
-                            uint32 present, BOOL delta) {
+static void process_polygon(STREAM s, POLYGON_ORDER *os, uint32 present,
+                            RD_BOOL delta) {
   int index, data, next;
   uint8 flags = 0;
-  POINT *points;
+  RD_POINT *points;
 
   if (present & 0x01)
     rdp_in_coord(s, &os->x, delta);
@@ -499,27 +520,18 @@
     in_uint8a(s, os->data, os->datasize);
   }
 
-  DEBUG(("POLYGON(x=%d,y=%d,op=0x%x,fm=%d,fg=0x%x,n=%d,sz=%d)\n", os->x, os->y,
-         os->opcode, os->fillmode, os->fgcolour, os->npoints, os->datasize));
-
-  DEBUG(("Data: "));
-
-  for (index = 0; index < os->datasize; index++)
-    DEBUG(("%02x ", os->data[index]));
-
-  DEBUG(("\n"));
+  logger(Graphics, Debug,
+         "process_polygon(), x=%d, y=%d, op=0x%x, fm=%d, fg=0x%x, n=%d, sz=%d",
+         os->x, os->y, os->opcode, os->fillmode, os->fgcolour, os->npoints,
+         os->datasize);
 
   if (os->opcode < 0x01 || os->opcode > 0x10) {
-    error("bad ROP2 0x%x\n", os->opcode);
+    logger(Graphics, Error, "process_polygon(), bad ROP2 0x%x", os->opcode);
     return;
   }
 
-  points = (POINT *)malloc((os->npoints + 1) * sizeof(POINT));
-
-  if (points == NULL)
-    return;
-
-  memset(points, 0, (os->npoints + 1) * sizeof(POINT));
+  points = (RD_POINT *)xmalloc((os->npoints + 1) * sizeof(RD_POINT));
+  memset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));
 
   points[0].x = os->x;
   points[0].y = os->y;
@@ -541,24 +553,21 @@
   }
 
   if (next - 1 == os->npoints)
-#if 0
-		ui_polygon(This, os->opcode - 1, os->fillmode, points, os->npoints + 1, NULL, 0,
-			   os->fgcolour);
-#else
-    ui_polygon(This, os->opcode, os->fillmode, points, os->npoints + 1, NULL, 0,
+    ui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1, NULL, 0,
                os->fgcolour);
-#endif
-    else error("polygon parse error\n");
+  else
+    logger(Graphics, Error, "process_polygon(), polygon parse error");
 
-  free(points);
+  xfree(points);
 }
 
 /* Process a polygon2 order */
-static void process_polygon2(RDPCLIENT *This, STREAM s, POLYGON2_ORDER *os,
-                             uint32 present, BOOL delta) {
+static void process_polygon2(STREAM s, POLYGON2_ORDER *os, uint32 present,
+                             RD_BOOL delta) {
   int index, data, next;
   uint8 flags = 0;
-  POINT *points;
+  RD_POINT *points;
+  BRUSH brush;
 
   if (present & 0x0001)
     rdp_in_coord(s, &os->x, delta);
@@ -588,28 +597,21 @@
     in_uint8a(s, os->data, os->datasize);
   }
 
-  DEBUG(("POLYGON2(x=%d,y=%d,op=0x%x,fm=%d,bs=%d,bg=0x%x,fg=0x%x,n=%d,sz=%d)\n",
+  logger(Graphics, Debug,
+         "process_polygon2(), x=%d, y=%d, op=0x%x, fm=%d, bs=%d, bg=0x%x, "
+         "fg=0x%x, n=%d, sz=%d)",
          os->x, os->y, os->opcode, os->fillmode, os->brush.style, os->bgcolour,
-         os->fgcolour, os->npoints, os->datasize));
-
-  DEBUG(("Data: "));
-
-  for (index = 0; index < os->datasize; index++)
-    DEBUG(("%02x ", os->data[index]));
-
-  DEBUG(("\n"));
+         os->fgcolour, os->npoints, os->datasize);
 
   if (os->opcode < 0x01 || os->opcode > 0x10) {
-    error("bad ROP2 0x%x\n", os->opcode);
+    logger(Graphics, Error, "process_polygon2(), bad ROP2 0x%x", os->opcode);
     return;
   }
 
-  points = (POINT *)malloc((os->npoints + 1) * sizeof(POINT));
+  setup_brush(&brush, &os->brush);
 
-  if (points == NULL)
-    return;
-
-  memset(points, 0, (os->npoints + 1) * sizeof(POINT));
+  points = (RD_POINT *)xmalloc((os->npoints + 1) * sizeof(RD_POINT));
+  memset(points, 0, (os->npoints + 1) * sizeof(RD_POINT));
 
   points[0].x = os->x;
   points[0].y = os->y;
@@ -631,25 +633,21 @@
   }
 
   if (next - 1 == os->npoints)
-#if 0
-		ui_polygon(This, os->opcode - 1, os->fillmode, points, os->npoints + 1,
-			   &os->brush, os->bgcolour, os->fgcolour);
-#else
-    ui_polygon(This, os->opcode, os->fillmode, points, os->npoints + 1,
-               &os->brush, os->bgcolour, os->fgcolour);
-#endif
-    else error("polygon2 parse error\n");
+    ui_polygon(os->opcode - 1, os->fillmode, points, os->npoints + 1, &brush,
+               os->bgcolour, os->fgcolour);
+  else
+    logger(Graphics, Error, "process_polygon2(), polygon parse error");
 
-  free(points);
+  xfree(points);
 }
 
 /* Process a polyline order */
-static void process_polyline(RDPCLIENT *This, STREAM s, POLYLINE_ORDER *os,
-                             uint32 present, BOOL delta) {
+static void process_polyline(STREAM s, POLYLINE_ORDER *os, uint32 present,
+                             RD_BOOL delta) {
   int index, next, data;
   uint8 flags = 0;
   PEN pen;
-  POINT *points;
+  RD_POINT *points;
 
   if (present & 0x01)
     rdp_in_coord(s, &os->x, delta);
@@ -671,27 +669,17 @@
     in_uint8a(s, os->data, os->datasize);
   }
 
-  DEBUG(("POLYLINE(x=%d,y=%d,op=0x%x,fg=0x%x,n=%d,sz=%d)\n", os->x, os->y,
-         os->opcode, os->fgcolour, os->lines, os->datasize));
-
-  DEBUG(("Data: "));
-
-  for (index = 0; index < os->datasize; index++)
-    DEBUG(("%02x ", os->data[index]));
-
-  DEBUG(("\n"));
+  logger(Graphics, Debug,
+         "process_polyline(), x=%d, y=%d, op=0x%x, fg=0x%x, n=%d, sz=%d)",
+         os->x, os->y, os->opcode, os->fgcolour, os->lines, os->datasize);
 
   if (os->opcode < 0x01 || os->opcode > 0x10) {
-    error("bad ROP2 0x%x\n", os->opcode);
+    logger(Graphics, Error, "process_polyline(), bad ROP2 0x%x", os->opcode);
     return;
   }
 
-  points = (POINT *)malloc((os->lines + 1) * sizeof(POINT));
-
-  if (points == NULL)
-    return;
-
-  memset(points, 0, (os->lines + 1) * sizeof(POINT));
+  points = (RD_POINT *)xmalloc((os->lines + 1) * sizeof(RD_POINT));
+  memset(points, 0, (os->lines + 1) * sizeof(RD_POINT));
 
   points[0].x = os->x;
   points[0].y = os->y;
@@ -714,19 +702,16 @@
   }
 
   if (next - 1 == os->lines)
-#if 0
-		ui_polyline(This, os->opcode - 1, points, os->lines + 1, &pen);
-#else
-    ui_polyline(This, os->opcode, points, os->lines + 1, &pen);
-#endif
-    else error("polyline parse error\n");
+    ui_polyline(os->opcode - 1, points, os->lines + 1, &pen);
+  else
+    logger(Graphics, Error, "process_polyline(), parse error");
 
-  free(points);
+  xfree(points);
 }
 
 /* Process an ellipse order */
-static void process_ellipse(RDPCLIENT *This, STREAM s, ELLIPSE_ORDER *os,
-                            uint32 present, BOOL delta) {
+static void process_ellipse(STREAM s, ELLIPSE_ORDER *os, uint32 present,
+                            RD_BOOL delta) {
   if (present & 0x01)
     rdp_in_coord(s, &os->left, delta);
 
@@ -748,22 +733,20 @@
   if (present & 0x40)
     rdp_in_colour(s, &os->fgcolour);
 
-  DEBUG(("ELLIPSE(l=%d,t=%d,r=%d,b=%d,op=0x%x,fm=%d,fg=0x%x)\n", os->left,
-         os->top, os->right, os->bottom, os->opcode, os->fillmode,
-         os->fgcolour));
+  logger(Graphics, Debug,
+         "process_ellipse(), l=%d, t=%d, r=%d, b=%d, op=0x%x, fm=%d, fg=0x%x",
+         os->left, os->top, os->right, os->bottom, os->opcode, os->fillmode,
+         os->fgcolour);
 
-#if 0
-	ui_ellipse(This, os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,
-		   os->bottom - os->top, NULL, 0, os->fgcolour);
-#else
-  ui_ellipse(This, os->opcode, os->fillmode, os->left, os->top,
+  ui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top,
              os->right - os->left, os->bottom - os->top, NULL, 0, os->fgcolour);
-#endif
 }
 
 /* Process an ellipse2 order */
-static void process_ellipse2(RDPCLIENT *This, STREAM s, ELLIPSE2_ORDER *os,
-                             uint32 present, BOOL delta) {
+static void process_ellipse2(STREAM s, ELLIPSE2_ORDER *os, uint32 present,
+                             RD_BOOL delta) {
+  BRUSH brush;
+
   if (present & 0x0001)
     rdp_in_coord(s, &os->left, delta);
 
@@ -790,24 +773,24 @@
 
   rdp_parse_brush(s, &os->brush, present >> 8);
 
-  DEBUG(("ELLIPSE2(l=%d,t=%d,r=%d,b=%d,op=0x%x,fm=%d,bs=%d,bg=0x%x,fg=0x%x)\n",
+  logger(Graphics, Debug,
+         "process_ellipse2(), l=%d, t=%d, r=%d, b=%d, op=0x%x, fm=%d, bs=%d, "
+         "bg=0x%x, fg=0x%x",
          os->left, os->top, os->right, os->bottom, os->opcode, os->fillmode,
-         os->brush.style, os->bgcolour, os->fgcolour));
+         os->brush.style, os->bgcolour, os->fgcolour);
 
-#if 0
-	ui_ellipse(This, os->opcode - 1, os->fillmode, os->left, os->top, os->right - os->left,
-		   os->bottom - os->top, &os->brush, os->bgcolour, os->fgcolour);
-#else
-  ui_ellipse(This, os->opcode, os->fillmode, os->left, os->top,
-             os->right - os->left, os->bottom - os->top, &os->brush,
-             os->bgcolour, os->fgcolour);
-#endif
+  setup_brush(&brush, &os->brush);
+
+  ui_ellipse(os->opcode - 1, os->fillmode, os->left, os->top,
+             os->right - os->left, os->bottom - os->top, &brush, os->bgcolour,
+             os->fgcolour);
 }
 
 /* Process a text order */
-static void process_text2(RDPCLIENT *This, STREAM s, TEXT2_ORDER *os,
-                          uint32 present, BOOL delta) {
-  int i;
+static void process_text2(STREAM s, TEXT2_ORDER *os, uint32 present,
+                          RD_BOOL delta) {
+  UNUSED(delta);
+  BRUSH brush;
 
   if (present & 0x000001)
     in_uint8(s, os->font);
@@ -864,41 +847,31 @@
     in_uint8a(s, os->text, os->length);
   }
 
-  DEBUG(("TEXT2(x=%d,y=%d,cl=%d,ct=%d,cr=%d,cb=%d,bl=%d,bt=%d,br=%d,bb=%d,bs=%"
-         "d,bg=0x%x,fg=0x%x,font=%d,fl=0x%x,op=0x%x,mix=%d,n=%d)\n",
+  logger(Graphics, Debug,
+         "process_text2(), x=%d, y=%d, cl=%d, ct=%d, cr=%d, cb=%d, bl=%d, "
+         "bt=%d, br=%d, bb=%d, bs=%d, bg=0x%x, fg=0x%x, font=%d, fl=0x%x, "
+         "op=0x%x, mix=%d, n=%d",
          os->x, os->y, os->clipleft, os->cliptop, os->clipright, os->clipbottom,
          os->boxleft, os->boxtop, os->boxright, os->boxbottom, os->brush.style,
          os->bgcolour, os->fgcolour, os->font, os->flags, os->opcode,
-         os->mixmode, os->length));
+         os->mixmode, os->length);
 
-  DEBUG(("Text: "));
+  setup_brush(&brush, &os->brush);
 
-  for (i = 0; i < os->length; i++)
-    DEBUG(("%02x ", os->text[i]));
-
-  DEBUG(("\n"));
-
-#if 0
-	ui_draw_text(This, os->font, os->flags, os->opcode - 1, os->mixmode, os->x, os->y,
-		     os->clipleft, os->cliptop, os->clipright - os->clipleft,
-		     os->clipbottom - os->cliptop, os->boxleft, os->boxtop,
-		     os->boxright - os->boxleft, os->boxbottom - os->boxtop,
-		     &os->brush, os->bgcolour, os->fgcolour, os->text, os->length);
-#else
-  ui_draw_text(This, os->font, os->flags, os->opcode, os->mixmode, os->x, os->y,
+  ui_draw_text(os->font, os->flags, os->opcode - 1, os->mixmode, os->x, os->y,
                os->clipleft, os->cliptop, os->clipright - os->clipleft,
                os->clipbottom - os->cliptop, os->boxleft, os->boxtop,
-               os->boxright - os->boxleft, os->boxbottom - os->boxtop,
-               &os->brush, os->bgcolour, os->fgcolour, os->text, os->length);
-#endif
+               os->boxright - os->boxleft, os->boxbottom - os->boxtop, &brush,
+               os->bgcolour, os->fgcolour, os->text, os->length);
 }
 
 /* Process a raw bitmap cache order */
-static void process_raw_bmpcache(RDPCLIENT *This, STREAM s) {
-  HBITMAP bitmap;
+static void process_raw_bmpcache(STREAM s) {
+  RD_HBITMAP bitmap;
   uint16 cache_idx, bufsize;
   uint8 cache_id, width, height, bpp, Bpp;
-  uint8 *data;
+  uint8 *data, *inverted;
+  int y;
 
   in_uint8(s, cache_id);
   in_uint8s(s, 1); /* pad */
@@ -910,30 +883,22 @@
   in_uint16_le(s, cache_idx);
   in_uint8p(s, data, bufsize);
 
-  DEBUG(("RAW_BMPCACHE(cx=%d,cy=%d,id=%d,idx=%d)\n", width, height, cache_id,
-         cache_idx));
-#if 0
-	inverted = (uint8 *) xmalloc(width * height * Bpp);
-	for (y = 0; y < height; y++)
-	{
-		memcpy(&inverted[(height - y - 1) * (width * Bpp)], &data[y * (width * Bpp)],
-		       width * Bpp);
-	}
-#endif
-
-#if 0
-	bitmap = ui_create_bitmap(This, width, height, inverted);
-	xfree(inverted);
-#else
-  bitmap = ui_create_bitmap(This, width, height, data);
-#endif
+  logger(Graphics, Debug, "process_raw_bpmcache(), cx=%d, cy=%d, id=%d, idx=%d",
+         width, height, cache_id, cache_idx);
+  inverted = (uint8 *)xmalloc(width * height * Bpp);
+  for (y = 0; y < height; y++) {
+    memcpy(&inverted[(height - y - 1) * (width * Bpp)],
+           &data[y * (width * Bpp)], width * Bpp);
+  }
 
-  cache_put_bitmap(This, cache_id, cache_idx, bitmap);
+  bitmap = ui_create_bitmap(width, height, inverted);
+  xfree(inverted);
+  cache_put_bitmap(cache_id, cache_idx, bitmap);
 }
 
 /* Process a bitmap cache order */
-static void process_bmpcache(RDPCLIENT *This, STREAM s) {
-  HBITMAP bitmap;
+static void process_bmpcache(STREAM s) {
+  RD_HBITMAP bitmap;
   uint16 cache_idx, size;
   uint8 cache_id, width, height, bpp, Bpp;
   uint8 *data, *bmpdata;
@@ -951,7 +916,7 @@
   in_uint16_le(s, bufsize); /* bufsize */
   in_uint16_le(s, cache_idx);
 
-  if (This->use_rdp5) {
+  if (g_rdp_version >= RDP_V5) {
     size = bufsize;
   } else {
 
@@ -963,31 +928,29 @@
     in_uint16_le(s, final_size);
   }
   in_uint8p(s, data, size);
-
-  DEBUG(("BMPCACHE(cx=%d,cy=%d,id=%d,idx=%d,bpp=%d,size=%d,pad1=%d,bufsize=%d,"
-         "pad2=%d,rs=%d,fs=%d)\n",
+  logger(Graphics, Debug,
+         "process_bmpcache(), cx=%d, cy=%d, id=%d, idx=%d, bpp=%d, size=%d, "
+         "pad1=%d, bufsize=%d, pad2=%d, rs=%d, fs=%d",
          width, height, cache_id, cache_idx, bpp, size, pad1, bufsize, pad2,
-         row_size, final_size));
+         row_size, final_size);
 
-  bmpdata = (uint8 *)malloc(width * height * Bpp);
-
-  if (bmpdata == NULL)
-    return;
+  bmpdata = (uint8 *)xmalloc(width * height * Bpp);
 
   if (bitmap_decompress(bmpdata, width, height, data, size, Bpp)) {
-    bitmap = ui_create_bitmap(This, width, height, bmpdata);
-    cache_put_bitmap(This, cache_id, cache_idx, bitmap);
+    bitmap = ui_create_bitmap(width, height, bmpdata);
+    cache_put_bitmap(cache_id, cache_idx, bitmap);
   } else {
-    DEBUG(("Failed to decompress bitmap data\n"));
+    logger(Graphics, Error,
+           "process_bmpcache(), Failed to decompress bitmap data");
   }
 
-  free(bmpdata);
+  xfree(bmpdata);
 }
 
 /* Process a bitmap cache v2 order */
-static void process_bmpcache2(RDPCLIENT *This, STREAM s, uint16 flags,
-                              BOOL compressed) {
-  HBITMAP bitmap;
+static void process_bmpcache2(STREAM s, uint16 flags, RD_BOOL compressed) {
+  RD_HBITMAP bitmap;
+  int y;
   uint8 cache_id, cache_idx_low, width, height, Bpp;
   uint16 cache_idx, bufsize;
   uint8 *data, *bmpdata, *bitmap_id;
@@ -1019,62 +982,52 @@
 
   in_uint8p(s, data, bufsize);
 
-  DEBUG(("BMPCACHE2(compr=%d,flags=%x,cx=%d,cy=%d,id=%d,idx=%d,Bpp=%d,bs=%d)\n",
-         compressed, flags, width, height, cache_id, cache_idx, Bpp, bufsize));
-
-  if (compressed) {
-    bmpdata = (uint8 *)malloc(width * height * Bpp);
+  logger(Graphics, Debug,
+         "process_bmpcache2(), compr=%d, flags=%x, cx=%d, cy=%d, id=%d, "
+         "idx=%d, Bpp=%d, bs=%d",
+         compressed, flags, width, height, cache_id, cache_idx, Bpp, bufsize);
 
-    if (bmpdata == NULL)
-      return;
+  bmpdata = (uint8 *)xmalloc(width * height * Bpp);
 
+  if (compressed) {
     if (!bitmap_decompress(bmpdata, width, height, data, bufsize, Bpp)) {
-      DEBUG(("Failed to decompress bitmap data\n"));
-      free(bmpdata);
+      logger(Graphics, Error,
+             "process_bmpcache2(), failed to decompress bitmap data");
+      xfree(bmpdata);
       return;
     }
   } else {
-#if 0
-		for (y = 0; y < height; y++)
-			memcpy(&bmpdata[(height - y - 1) * (width * Bpp)],
-			       &data[y * (width * Bpp)], width * Bpp);
-#else
-    bmpdata = data;
-#endif
+    for (y = 0; y < height; y++)
+      memcpy(&bmpdata[(height - y - 1) * (width * Bpp)],
+             &data[y * (width * Bpp)], width * Bpp);
   }
 
-  bitmap = ui_create_bitmap(This, width, height, bmpdata);
+  bitmap = ui_create_bitmap(width, height, bmpdata);
 
   if (bitmap) {
-    cache_put_bitmap(This, cache_id, cache_idx, bitmap);
+    cache_put_bitmap(cache_id, cache_idx, bitmap);
     if (flags & PERSIST)
-      pstcache_save_bitmap(This, cache_id, cache_idx, bitmap_id, width, height,
+      pstcache_save_bitmap(cache_id, cache_idx, bitmap_id, width, height,
                            width * height * Bpp, bmpdata);
   } else {
-    DEBUG(("process_bmpcache2: ui_create_bitmap failed\n"));
+    logger(Graphics, Error, "process_bmpcache2(), ui_create_bitmap(), failed");
   }
 
-  if (compressed)
-    free(bmpdata);
+  xfree(bmpdata);
 }
 
 /* Process a colourmap cache order */
-static void process_colcache(RDPCLIENT *This, STREAM s) {
+static void process_colcache(STREAM s) {
   COLOURENTRY *entry;
   COLOURMAP map;
-  HCOLOURMAP hmap;
+  RD_HCOLOURMAP hmap;
   uint8 cache_id;
   int i;
 
   in_uint8(s, cache_id);
   in_uint16_le(s, map.ncolours);
 
-  map.colours = (COLOURENTRY *)malloc(sizeof(COLOURENTRY) * map.ncolours);
-
-  if (map.colours == NULL) {
-    in_uint8s(s, map.ncolours * 4);
-    return;
-  }
+  map.colours = (COLOURENTRY *)xmalloc(sizeof(COLOURENTRY) * map.ncolours);
 
   for (i = 0; i < map.ncolours; i++) {
     entry = &map.colours[i];
@@ -1084,19 +1037,20 @@
     in_uint8s(s, 1); /* pad */
   }
 
-  DEBUG(("COLCACHE(id=%d,n=%d)\n", cache_id, map.ncolours));
+  logger(Graphics, Debug, "process_colcache(), id=%d, n=%d", cache_id,
+         map.ncolours);
 
-  hmap = ui_create_colourmap(This, &map);
+  hmap = ui_create_colourmap(&map);
 
   if (cache_id)
-    ui_set_colourmap(This, hmap);
+    ui_set_colourmap(hmap);
 
-  free(map.colours);
+  xfree(map.colours);
 }
 
 /* Process a font cache order */
-static void process_fontcache(RDPCLIENT *This, STREAM s) {
-  HGLYPH bitmap;
+static void process_fontcache(STREAM s) {
+  RD_HGLYPH bitmap;
   uint8 font, nglyphs;
   uint16 character, offset, baseline, width, height;
   int i, datasize;
@@ -1105,7 +1059,7 @@
   in_uint8(s, font);
   in_uint8(s, nglyphs);
 
-  DEBUG(("FONTCACHE(font=%d,n=%d)\n", font, nglyphs));
+  logger(Graphics, Debug, "process_fontcache(), font=%d, n=%d", font, nglyphs);
 
   for (i = 0; i < nglyphs; i++) {
     in_uint16_le(s, character);
@@ -1117,14 +1071,101 @@
     datasize = (height * ((width + 7) / 8) + 3) & ~3;
     in_uint8p(s, data, datasize);
 
-    bitmap = ui_create_glyph(This, width, height, data);
-    cache_put_font(This, font, character, offset, baseline, width, height,
-                   bitmap);
+    bitmap = ui_create_glyph(width, height, data);
+    cache_put_font(font, character, offset, baseline, width, height, bitmap);
+  }
+}
+
+static void process_compressed_8x8_brush_data(uint8 *in, uint8 *out, int Bpp) {
+  int x, y, pal_index, in_index, shift, do2, i;
+  uint8 *pal;
+
+  in_index = 0;
+  pal = in + 16;
+  /* read it bottom up */
+  for (y = 7; y >= 0; y--) {
+    /* 2 bytes per row */
+    x = 0;
+    for (do2 = 0; do2 < 2; do2++) {
+      /* 4 pixels per byte */
+      shift = 6;
+      while (shift >= 0) {
+        pal_index = (in[in_index] >> shift) & 3;
+        /* size of palette entries depends on Bpp */
+        for (i = 0; i < Bpp; i++) {
+          out[(y * 8 + x) * Bpp + i] = pal[pal_index * Bpp + i];
+        }
+        x++;
+        shift -= 2;
+      }
+      in_index++;
+    }
+  }
+}
+
+/* Process a brush cache order */
+static void process_brushcache(STREAM s, uint16 flags) {
+  UNUSED(flags);
+  BRUSHDATA brush_data;
+  uint8 cache_idx, colour_code, width, height, size, type;
+  uint8 *comp_brush;
+  int index;
+  int Bpp;
+
+  in_uint8(s, cache_idx);
+  in_uint8(s, colour_code);
+  in_uint8(s, width);
+  in_uint8(s, height);
+  in_uint8(s, type); /* type, 0x8x = cached */
+  in_uint8(s, size);
+
+  logger(Graphics, Debug,
+         "process_brushcache(), idx=%d, wd=%d, ht=%d, type=0x%x sz=%d",
+         cache_idx, width, height, type, size);
+
+  if ((width == 8) && (height == 8)) {
+    if (colour_code == 1) {
+      brush_data.colour_code = 1;
+      brush_data.data_size = 8;
+      brush_data.data = xmalloc(8);
+      if (size == 8) {
+        /* read it bottom up */
+        for (index = 7; index >= 0; index--) {
+          in_uint8(s, brush_data.data[index]);
+        }
+      } else {
+        logger(
+            Graphics, Warning,
+            "process_brushcache(), incompatible brush, colour_code %d size %d",
+            colour_code, size);
+      }
+      cache_put_brush_data(1, cache_idx, &brush_data);
+    } else if ((colour_code >= 3) && (colour_code <= 6)) {
+      Bpp = colour_code - 2;
+      brush_data.colour_code = colour_code;
+      brush_data.data_size = 8 * 8 * Bpp;
+      brush_data.data = xmalloc(8 * 8 * Bpp);
+      if (size == 16 + 4 * Bpp) {
+        in_uint8p(s, comp_brush, 16 + 4 * Bpp);
+        process_compressed_8x8_brush_data(comp_brush, brush_data.data, Bpp);
+      } else {
+        in_uint8a(s, brush_data.data, 8 * 8 * Bpp);
+      }
+      cache_put_brush_data(colour_code, cache_idx, &brush_data);
+    } else {
+      logger(Graphics, Warning,
+             "process_brushcache(), incompatible brush, colour_code %d size %d",
+             colour_code, size);
+    }
+  } else {
+    logger(Graphics, Warning,
+           "process_brushcache(), incompatible brush, width height %d %d",
+           width, height);
   }
 }
 
 /* Process a secondary order */
-static void process_secondary_order(RDPCLIENT *This, STREAM s) {
+static void process_secondary_order(STREAM s) {
   /* The length isn't calculated correctly by the server.
    * For very compact orders the length becomes negative
    * so a signed integer must be used. */
@@ -1132,63 +1173,75 @@
   uint16 flags;
   uint8 type;
   uint8 *next_order;
+  struct stream packet = *s;
 
   in_uint16_le(s, length);
   in_uint16_le(s, flags); /* used by bmpcache2 */
   in_uint8(s, type);
 
+  if (!s_check_rem(s, length + 7)) {
+    rdp_protocol_error(
+        "process_secondary_order(), next order pointer would overrun stream",
+        &packet);
+  }
+
   next_order = s->p + (sint16)length + 7;
 
   switch (type) {
   case RDP_ORDER_RAW_BMPCACHE:
-    process_raw_bmpcache(This, s);
+    process_raw_bmpcache(s);
     break;
 
   case RDP_ORDER_COLCACHE:
-    process_colcache(This, s);
+    process_colcache(s);
     break;
 
   case RDP_ORDER_BMPCACHE:
-    process_bmpcache(This, s);
+    process_bmpcache(s);
     break;
 
   case RDP_ORDER_FONTCACHE:
-    process_fontcache(This, s);
+    process_fontcache(s);
     break;
 
   case RDP_ORDER_RAW_BMPCACHE2:
-    process_bmpcache2(This, s, flags, False); /* uncompressed */
+    process_bmpcache2(s, flags, False); /* uncompressed */
     break;
 
   case RDP_ORDER_BMPCACHE2:
-    process_bmpcache2(This, s, flags, True); /* compressed */
+    process_bmpcache2(s, flags, True); /* compressed */
+    break;
+
+  case RDP_ORDER_BRUSHCACHE:
+    process_brushcache(s, flags);
     break;
 
   default:
-    unimpl("secondary order %d\n", type);
+    logger(Graphics, Warning,
+           "process_secondary_order(), unhandled secondary order %d", type);
   }
 
   s->p = next_order;
 }
 
 /* Process an order PDU */
-void process_orders(RDPCLIENT *This, STREAM s, uint16 num_orders) {
-  RDP_ORDER_STATE *os = &This->orders.order_state;
+void process_orders(STREAM s, uint16 num_orders) {
+  RDP_ORDER_STATE *os = &g_order_state;
   uint32 present;
   uint8 order_flags;
   int size, processed = 0;
-  BOOL delta;
+  RD_BOOL delta;
 
   while (processed < num_orders) {
     in_uint8(s, order_flags);
 
     if (!(order_flags & RDP_ORDER_STANDARD)) {
-      error("order parsing failed\n");
+      logger(Graphics, Error, "process_orders(), order parsing failed");
       break;
     }
 
     if (order_flags & RDP_ORDER_SECONDARY) {
-      process_secondary_order(This, s);
+      process_secondary_order(s);
     } else {
       if (order_flags & RDP_ORDER_CHANGE) {
         in_uint8(s, os->order_type);
@@ -1218,7 +1271,7 @@
         if (!(order_flags & RDP_ORDER_LASTBOUNDS))
           rdp_parse_bounds(s, &os->bounds);
 
-        ui_set_clip(This, os->bounds.left, os->bounds.top,
+        ui_set_clip(os->bounds.left, os->bounds.top,
                     os->bounds.right - os->bounds.left + 1,
                     os->bounds.bottom - os->bounds.top + 1);
       }
@@ -1227,81 +1280,83 @@
 
       switch (os->order_type) {
       case RDP_ORDER_DESTBLT:
-        process_destblt(This, s, &os->destblt, present, delta);
+        process_destblt(s, &os->destblt, present, delta);
         break;
 
       case RDP_ORDER_PATBLT:
-        process_patblt(This, s, &os->patblt, present, delta);
+        process_patblt(s, &os->patblt, present, delta);
         break;
 
       case RDP_ORDER_SCREENBLT:
-        process_screenblt(This, s, &os->screenblt, present, delta);
+        process_screenblt(s, &os->screenblt, present, delta);
         break;
 
       case RDP_ORDER_LINE:
-        process_line(This, s, &os->line, present, delta);
+        process_line(s, &os->line, present, delta);
         break;
 
       case RDP_ORDER_RECT:
-        process_rect(This, s, &os->rect, present, delta);
+        process_rect(s, &os->rect, present, delta);
         break;
 
       case RDP_ORDER_DESKSAVE:
-        process_desksave(This, s, &os->desksave, present, delta);
+        process_desksave(s, &os->desksave, present, delta);
         break;
 
       case RDP_ORDER_MEMBLT:
-        process_memblt(This, s, &os->memblt, present, delta);
+        process_memblt(s, &os->memblt, present, delta);
         break;
 
       case RDP_ORDER_TRIBLT:
-        process_triblt(This, s, &os->triblt, present, delta);
+        process_triblt(s, &os->triblt, present, delta);
         break;
 
       case RDP_ORDER_POLYGON:
-        process_polygon(This, s, &os->polygon, present, delta);
+        process_polygon(s, &os->polygon, present, delta);
         break;
 
       case RDP_ORDER_POLYGON2:
-        process_polygon2(This, s, &os->polygon2, present, delta);
+        process_polygon2(s, &os->polygon2, present, delta);
         break;
 
       case RDP_ORDER_POLYLINE:
-        process_polyline(This, s, &os->polyline, present, delta);
+        process_polyline(s, &os->polyline, present, delta);
         break;
 
       case RDP_ORDER_ELLIPSE:
-        process_ellipse(This, s, &os->ellipse, present, delta);
+        process_ellipse(s, &os->ellipse, present, delta);
         break;
 
       case RDP_ORDER_ELLIPSE2:
-        process_ellipse2(This, s, &os->ellipse2, present, delta);
+        process_ellipse2(s, &os->ellipse2, present, delta);
         break;
 
       case RDP_ORDER_TEXT2:
-        process_text2(This, s, &os->text2, present, delta);
+        process_text2(s, &os->text2, present, delta);
         break;
 
       default:
-        unimpl("order %d\n", os->order_type);
+        logger(Graphics, Warning, "process_orders(), unhandled order type %d",
+               os->order_type);
         return;
       }
 
       if (order_flags & RDP_ORDER_BOUNDS)
-        ui_reset_clip(This);
+        ui_reset_clip();
     }
 
     processed++;
   }
 #if 0
 	/* not true when RDP_COMPRESSION is set */
-	if (s->p != This->next_packet)
-		error("%d bytes remaining\n", (int) (This->next_packet - s->p));
+	if (s->p != g_next_packet)
+		logger(Graphics, Error, "process_orders(), %d bytes remaining",
+		       (int) (g_next_packet - s->p));
 #endif
 }
 
 /* Reset order state */
-void reset_order_state(RDPCLIENT *This) {
-  memset(&This->orders.order_state, 0, sizeof(This->orders.order_state));
-  This->orders.order_state.order_type = RDP_ORDER_PATBLT;
+void reset_order_state(void) {
+  memset(&g_order_state, 0, sizeof(g_order_state));
+  g_order_state.order_type = RDP_ORDER_PATBLT;
 }
