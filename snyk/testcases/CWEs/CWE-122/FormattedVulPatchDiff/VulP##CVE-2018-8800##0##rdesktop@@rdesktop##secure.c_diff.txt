--- /home/V1SCAN/CWE-122/FormattedVul/OLD##CVE-2018-8800##0##rdesktop@@rdesktop##secure.c	2023-12-12 03:51:30.140026305 +0900
+++ /home/V1SCAN/CWE-122/FormattedPatch/NEW##CVE-2018-8800##0##rdesktop@@rdesktop##secure.c	2023-12-12 03:51:30.430024614 +0900
@@ -269,6 +269,9 @@
 
 /* Decrypt data using RC4 */
 void sec_decrypt(uint8 *data, int length) {
+  if (length <= 0)
+    return;
+
   if (g_sec_decrypt_use_count == 4096) {
     sec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);
     rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);
@@ -778,14 +781,22 @@
   uint16 sec_flags;
   uint16 channel;
   STREAM s;
+  struct stream packet;
 
   while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL) {
+    packet = *s;
     if (*is_fastpath == True) {
       /* If fastpath packet is encrypted, read data
          signature and decrypt */
       /* FIXME: extracting flags from hdr could be made less obscure */
       fastpath_flags = (fastpath_hdr & 0xC0) >> 6;
       if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED) {
+        if (!s_check_rem(s, 8)) {
+          rdp_protocol_error("sec_recv(), consume fastpath signature from "
+                             "stream would overrun",
+                             &packet);
+        }
+
         in_uint8s(s, 8); /* signature */
         sec_decrypt(s->p, s->end - s->p);
       }
@@ -799,6 +810,12 @@
 
       if (g_encryption) {
         if (sec_flags & SEC_ENCRYPT) {
+          if (!s_check_rem(s, 8)) {
+            rdp_protocol_error("sec_recv(), consume encrypt signature from "
+                               "stream would overrun",
+                               &packet);
+          }
+
           in_uint8s(s, 8); /* signature */
           sec_decrypt(s->p, s->end - s->p);
         }
@@ -811,6 +828,12 @@
         if (sec_flags & SEC_REDIRECTION_PKT) {
           uint8 swapbyte;
 
+          if (!s_check_rem(s, 8)) {
+            rdp_protocol_error("sec_recv(), consume redirect signature from "
+                               "stream would overrun",
+                               &packet);
+          }
+
           in_uint8s(s, 8); /* signature */
           sec_decrypt(s->p, s->end - s->p);
 
