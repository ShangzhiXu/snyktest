--- /home/V1SCAN/CWE-122/FormattedUsed/secure-reactos-0.4.13.c	2023-12-12 03:51:16.038364049 +0900
+++ /home/V1SCAN/CWE-122/FormattedVul/OLD##CVE-2018-8800##0##rdesktop@@rdesktop##secure.c	2023-12-12 03:51:16.408362990 +0900
@@ -1,11 +1,13 @@
 /* -*- c-basic-offset: 8 -*-
    rdesktop: A Remote Desktop Protocol client.
    Protocol services - RDP encryption and licensing
-   Copyright (C) Matthew Chapman 1999-2005
+   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008
+   Copyright 2005-2011 Peter Astrand <astrand@cendio.se> for Cendio AB
+   Copyright 2017-2018 Henrik Andersson <hean01@cendio.se> for Cendio AB
 
-   This program is free software; you can redistribute it and/or modify
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
+   the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -13,20 +15,49 @@
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "rdesktop.h"
-#include <string.h>
+#include "ssl.h"
 
-// TODO: remove dependency on OpenSSL
-#include <openssl/bn.h>
-#include <openssl/md5.h>
-#include <openssl/rc4.h>
-#include <openssl/sha.h>
-#include <openssl/x509v3.h>
+extern char g_hostname[16];
+extern uint32 g_requested_session_width;
+extern uint32 g_requested_session_height;
+extern int g_dpi;
+extern unsigned int g_keylayout;
+extern int g_keyboard_type;
+extern int g_keyboard_subtype;
+extern int g_keyboard_functionkeys;
+extern RD_BOOL g_encryption;
+extern RD_BOOL g_licence_issued;
+extern RD_BOOL g_licence_error_result;
+extern RDP_VERSION g_rdp_version;
+extern RD_BOOL g_console_session;
+extern uint32 g_redirect_session_id;
+extern int g_server_depth;
+extern VCHANNEL g_channels[];
+extern unsigned int g_num_channels;
+extern uint8 g_client_random[SEC_RANDOM_SIZE];
+
+static int g_rc4_key_len;
+static RDSSL_RC4 g_rc4_decrypt_key;
+static RDSSL_RC4 g_rc4_encrypt_key;
+static uint32 g_server_public_key_len;
+
+static uint8 g_sec_sign_key[16];
+static uint8 g_sec_decrypt_key[16];
+static uint8 g_sec_encrypt_key[16];
+static uint8 g_sec_decrypt_update_key[16];
+static uint8 g_sec_encrypt_update_key[16];
+static uint8 g_sec_crypted_random[SEC_MAX_MODULUS_SIZE];
+
+uint16 g_server_rdp_version = 0;
+
+/* These values must be available to reset state - Session Directory */
+static int g_sec_encrypt_use_count = 0;
+static int g_sec_decrypt_use_count = 0;
 
 /*
  * I believe this is based on SSLv3 with the following differences:
@@ -46,24 +77,24 @@
                  uint8 salt) {
   uint8 shasig[20];
   uint8 pad[4];
-  SHA_CTX sha;
-  MD5_CTX md5;
+  RDSSL_SHA1 sha1;
+  RDSSL_MD5 md5;
   int i;
 
   for (i = 0; i < 3; i++) {
     memset(pad, salt + i, i + 1);
 
-    SHA1_Init(&sha);
-    SHA1_Update(&sha, pad, i + 1);
-    SHA1_Update(&sha, in, 48);
-    SHA1_Update(&sha, salt1, 32);
-    SHA1_Update(&sha, salt2, 32);
-    SHA1_Final(shasig, &sha);
-
-    MD5_Init(&md5);
-    MD5_Update(&md5, in, 48);
-    MD5_Update(&md5, shasig, 20);
-    MD5_Final(&out[i * 16], &md5);
+    rdssl_sha1_init(&sha1);
+    rdssl_sha1_update(&sha1, pad, i + 1);
+    rdssl_sha1_update(&sha1, in, 48);
+    rdssl_sha1_update(&sha1, salt1, 32);
+    rdssl_sha1_update(&sha1, salt2, 32);
+    rdssl_sha1_final(&sha1, shasig);
+
+    rdssl_md5_init(&md5);
+    rdssl_md5_update(&md5, in, 48);
+    rdssl_md5_update(&md5, shasig, 20);
+    rdssl_md5_final(&md5, &out[i * 16]);
   }
 }
 
@@ -71,13 +102,33 @@
  * 16-byte transformation used to generate export keys (6.2.2).
  */
 void sec_hash_16(uint8 *out, uint8 *in, uint8 *salt1, uint8 *salt2) {
-  MD5_CTX md5;
+  RDSSL_MD5 md5;
 
-  MD5_Init(&md5);
-  MD5_Update(&md5, in, 16);
-  MD5_Update(&md5, salt1, 32);
-  MD5_Update(&md5, salt2, 32);
-  MD5_Final(out, &md5);
+  rdssl_md5_init(&md5);
+  rdssl_md5_update(&md5, in, 16);
+  rdssl_md5_update(&md5, salt1, 32);
+  rdssl_md5_update(&md5, salt2, 32);
+  rdssl_md5_final(&md5, out);
+}
+
+/*
+ * 16-byte sha1 hash
+ */
+void sec_hash_sha1_16(uint8 *out, uint8 *in, uint8 *salt1) {
+  RDSSL_SHA1 sha1;
+  rdssl_sha1_init(&sha1);
+  rdssl_sha1_update(&sha1, in, 16);
+  rdssl_sha1_update(&sha1, salt1, 16);
+  rdssl_sha1_final(&sha1, out);
+}
+
+/* create string from hash */
+void sec_hash_to_string(char *out, int out_size, uint8 *in, int in_size) {
+  int k;
+  memset(out, 0, out_size);
+  for (k = 0; k < in_size; k++, out += 2) {
+    sprintf(out, "%.2x", in[k]);
+  }
 }
 
 /* Reduce key entropy from 64 to 40 bits */
@@ -88,8 +139,8 @@
 }
 
 /* Generate encryption keys given client and server randoms */
-static void sec_generate_keys(RDPCLIENT *This, uint8 *client_random,
-                              uint8 *server_random, int rc4_key_size) {
+static void sec_generate_keys(uint8 *client_random, uint8 *server_random,
+                              int rc4_key_size) {
   uint8 pre_master_secret[48];
   uint8 master_secret[48];
   uint8 key_block[48];
@@ -104,45 +155,44 @@
   sec_hash_48(key_block, master_secret, client_random, server_random, 'X');
 
   /* First 16 bytes of key material is MAC secret */
-  memcpy(This->secure.sign_key, key_block, 16);
+  memcpy(g_sec_sign_key, key_block, 16);
 
   /* Generate export keys from next two blocks of 16 bytes */
-  sec_hash_16(This->secure.decrypt_key, &key_block[16], client_random,
-              server_random);
-  sec_hash_16(This->secure.encrypt_key, &key_block[32], client_random,
-              server_random);
+  sec_hash_16(g_sec_decrypt_key, &key_block[16], client_random, server_random);
+  sec_hash_16(g_sec_encrypt_key, &key_block[32], client_random, server_random);
 
   if (rc4_key_size == 1) {
-    DEBUG(("40-bit encryption enabled\n"));
-    sec_make_40bit(This->secure.sign_key);
-    sec_make_40bit(This->secure.decrypt_key);
-    sec_make_40bit(This->secure.encrypt_key);
-    This->secure.rc4_key_len = 8;
+    logger(Protocol, Debug, "sec_generate_keys(), 40-bit encryption enabled");
+    sec_make_40bit(g_sec_sign_key);
+    sec_make_40bit(g_sec_decrypt_key);
+    sec_make_40bit(g_sec_encrypt_key);
+    g_rc4_key_len = 8;
   } else {
-    DEBUG(("rc_4_key_size == %d, 128-bit encryption enabled\n", rc4_key_size));
-    This->secure.rc4_key_len = 16;
+    logger(
+        Protocol, Debug,
+        "sec_generate_key(), rc_4_key_size == %d, 128-bit encryption enabled",
+        rc4_key_size);
+    g_rc4_key_len = 16;
   }
 
   /* Save initial RC4 keys as update keys */
-  memcpy(This->secure.decrypt_update_key, This->secure.decrypt_key, 16);
-  memcpy(This->secure.encrypt_update_key, This->secure.encrypt_key, 16);
+  memcpy(g_sec_decrypt_update_key, g_sec_decrypt_key, 16);
+  memcpy(g_sec_encrypt_update_key, g_sec_encrypt_key, 16);
 
   /* Initialise RC4 state arrays */
-  RC4_set_key(&This->secure.rc4_decrypt_key, This->secure.rc4_key_len,
-              This->secure.decrypt_key);
-  RC4_set_key(&This->secure.rc4_encrypt_key, This->secure.rc4_key_len,
-              This->secure.encrypt_key);
+  rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);
+  rdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);
 }
 
-static const uint8 pad_54[40] = {54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
-                                 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
-                                 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
-                                 54, 54, 54, 54, 54, 54, 54, 54, 54, 54};
-
-static const uint8 pad_92[48] = {
-    92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
-    92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
-    92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92};
+static uint8 pad_54[40] = {54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
+                           54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
+                           54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
+                           54, 54, 54, 54, 54, 54, 54, 54, 54, 54};
+
+static uint8 pad_92[48] = {92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
+                           92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
+                           92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
+                           92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92};
 
 /* Output a uint32 into a buffer (little-endian) */
 void buf_out_uint32(uint8 *buffer, uint32 value) {
@@ -158,207 +208,165 @@
   uint8 shasig[20];
   uint8 md5sig[16];
   uint8 lenhdr[4];
-  SHA_CTX sha;
-  MD5_CTX md5;
+  RDSSL_SHA1 sha1;
+  RDSSL_MD5 md5;
 
   buf_out_uint32(lenhdr, datalen);
 
-  SHA1_Init(&sha);
-  SHA1_Update(&sha, session_key, keylen);
-  SHA1_Update(&sha, pad_54, 40);
-  SHA1_Update(&sha, lenhdr, 4);
-  SHA1_Update(&sha, data, datalen);
-  SHA1_Final(shasig, &sha);
-
-  MD5_Init(&md5);
-  MD5_Update(&md5, session_key, keylen);
-  MD5_Update(&md5, pad_92, 48);
-  MD5_Update(&md5, shasig, 20);
-  MD5_Final(md5sig, &md5);
+  rdssl_sha1_init(&sha1);
+  rdssl_sha1_update(&sha1, session_key, keylen);
+  rdssl_sha1_update(&sha1, pad_54, 40);
+  rdssl_sha1_update(&sha1, lenhdr, 4);
+  rdssl_sha1_update(&sha1, data, datalen);
+  rdssl_sha1_final(&sha1, shasig);
+
+  rdssl_md5_init(&md5);
+  rdssl_md5_update(&md5, session_key, keylen);
+  rdssl_md5_update(&md5, pad_92, 48);
+  rdssl_md5_update(&md5, shasig, 20);
+  rdssl_md5_final(&md5, md5sig);
 
   memcpy(signature, md5sig, siglen);
 }
 
 /* Update an encryption key */
-static void sec_update(RDPCLIENT *This, uint8 *key, uint8 *update_key) {
+static void sec_update(uint8 *key, uint8 *update_key) {
   uint8 shasig[20];
-  SHA_CTX sha;
-  MD5_CTX md5;
-  RC4_KEY update;
-
-  SHA1_Init(&sha);
-  SHA1_Update(&sha, update_key, This->secure.rc4_key_len);
-  SHA1_Update(&sha, pad_54, 40);
-  SHA1_Update(&sha, key, This->secure.rc4_key_len);
-  SHA1_Final(shasig, &sha);
-
-  MD5_Init(&md5);
-  MD5_Update(&md5, update_key, This->secure.rc4_key_len);
-  MD5_Update(&md5, pad_92, 48);
-  MD5_Update(&md5, shasig, 20);
-  MD5_Final(key, &md5);
+  RDSSL_SHA1 sha1;
+  RDSSL_MD5 md5;
+  RDSSL_RC4 update;
+
+  rdssl_sha1_init(&sha1);
+  rdssl_sha1_update(&sha1, update_key, g_rc4_key_len);
+  rdssl_sha1_update(&sha1, pad_54, 40);
+  rdssl_sha1_update(&sha1, key, g_rc4_key_len);
+  rdssl_sha1_final(&sha1, shasig);
+
+  rdssl_md5_init(&md5);
+  rdssl_md5_update(&md5, update_key, g_rc4_key_len);
+  rdssl_md5_update(&md5, pad_92, 48);
+  rdssl_md5_update(&md5, shasig, 20);
+  rdssl_md5_final(&md5, key);
 
-  RC4_set_key(&update, This->secure.rc4_key_len, key);
-  RC4(&update, This->secure.rc4_key_len, key, key);
+  rdssl_rc4_set_key(&update, key, g_rc4_key_len);
+  rdssl_rc4_crypt(&update, key, key, g_rc4_key_len);
 
-  if (This->secure.rc4_key_len == 8)
+  if (g_rc4_key_len == 8)
     sec_make_40bit(key);
 }
 
 /* Encrypt data using RC4 */
-static void sec_encrypt(RDPCLIENT *This, uint8 *data, int length) {
-  if (This->secure.encrypt_use_count == 4096) {
-    sec_update(This, This->secure.encrypt_key, This->secure.encrypt_update_key);
-    RC4_set_key(&This->secure.rc4_encrypt_key, This->secure.rc4_key_len,
-                This->secure.encrypt_key);
-    This->secure.encrypt_use_count = 0;
+static void sec_encrypt(uint8 *data, int length) {
+  if (g_sec_encrypt_use_count == 4096) {
+    sec_update(g_sec_encrypt_key, g_sec_encrypt_update_key);
+    rdssl_rc4_set_key(&g_rc4_encrypt_key, g_sec_encrypt_key, g_rc4_key_len);
+    g_sec_encrypt_use_count = 0;
   }
 
-  RC4(&This->secure.rc4_encrypt_key, length, data, data);
-  This->secure.encrypt_use_count++;
+  rdssl_rc4_crypt(&g_rc4_encrypt_key, data, data, length);
+  g_sec_encrypt_use_count++;
 }
 
 /* Decrypt data using RC4 */
-void sec_decrypt(RDPCLIENT *This, uint8 *data, int length) {
-  if (This->secure.decrypt_use_count == 4096) {
-    sec_update(This, This->secure.decrypt_key, This->secure.decrypt_update_key);
-    RC4_set_key(&This->secure.rc4_decrypt_key, This->secure.rc4_key_len,
-                This->secure.decrypt_key);
-    This->secure.decrypt_use_count = 0;
-  }
-
-  RC4(&This->secure.rc4_decrypt_key, length, data, data);
-  This->secure.decrypt_use_count++;
-}
-
-static void reverse(uint8 *p, int len) {
-  int i, j;
-  uint8 temp;
-
-  for (i = 0, j = len - 1; i < j; i++, j--) {
-    temp = p[i];
-    p[i] = p[j];
-    p[j] = temp;
+void sec_decrypt(uint8 *data, int length) {
+  if (g_sec_decrypt_use_count == 4096) {
+    sec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);
+    rdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);
+    g_sec_decrypt_use_count = 0;
   }
+
+  rdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);
+  g_sec_decrypt_use_count++;
 }
 
 /* Perform an RSA public key encryption operation */
 static void sec_rsa_encrypt(uint8 *out, uint8 *in, int len, uint32 modulus_size,
                             uint8 *modulus, uint8 *exponent) {
-  BN_CTX *ctx;
-  BIGNUM mod, exp, x, y;
-  uint8 inr[SEC_MAX_MODULUS_SIZE];
-  int outlen;
-
-  reverse(modulus, modulus_size);
-  reverse(exponent, SEC_EXPONENT_SIZE);
-  memcpy(inr, in, len);
-  reverse(inr, len);
-
-  ctx = BN_CTX_new();
-  BN_init(&mod);
-  BN_init(&exp);
-  BN_init(&x);
-  BN_init(&y);
-
-  BN_bin2bn(modulus, modulus_size, &mod);
-  BN_bin2bn(exponent, SEC_EXPONENT_SIZE, &exp);
-  BN_bin2bn(inr, len, &x);
-  BN_mod_exp(&y, &x, &exp, &mod, ctx);
-  outlen = BN_bn2bin(&y, out);
-  reverse(out, outlen);
-  if ((uint32)outlen < modulus_size)
-    memset(out + outlen, 0, modulus_size - outlen);
-
-  BN_free(&y);
-  BN_clear_free(&x);
-  BN_free(&exp);
-  BN_free(&mod);
-  BN_CTX_free(ctx);
+  rdssl_rsa_encrypt(out, in, len, modulus_size, modulus, exponent);
 }
 
 /* Initialise secure transport packet */
 STREAM
-sec_init(RDPCLIENT *This, uint32 flags, int maxlen) {
+sec_init(uint32 flags, int maxlen) {
   int hdrlen;
   STREAM s;
 
-  if (!This->licence_issued)
+  if (!g_licence_issued && !g_licence_error_result)
     hdrlen = (flags & SEC_ENCRYPT) ? 12 : 4;
   else
     hdrlen = (flags & SEC_ENCRYPT) ? 12 : 0;
-  s = mcs_init(This, maxlen + hdrlen);
-
-  if (s == NULL)
-    return s;
-
+  s = mcs_init(maxlen + hdrlen);
   s_push_layer(s, sec_hdr, hdrlen);
 
   return s;
 }
 
 /* Transmit secure transport packet over specified channel */
-
-// !!! we need a lock here !!!
-BOOL sec_send_to_channel(RDPCLIENT *This, STREAM s, uint32 flags,
-                         uint16 channel) {
+void sec_send_to_channel(STREAM s, uint32 flags, uint16 channel) {
   int datalen;
 
+#ifdef WITH_SCARD
+  scard_lock(SCARD_LOCK_SEC);
+#endif
+
   s_pop_layer(s, sec_hdr);
-  if (!This->licence_issued || (flags & SEC_ENCRYPT))
+  if ((!g_licence_issued && !g_licence_error_result) || (flags & SEC_ENCRYPT))
     out_uint32_le(s, flags);
 
   if (flags & SEC_ENCRYPT) {
     flags &= ~SEC_ENCRYPT;
-    datalen = (int)(s->end - s->p - 8);
-
-#if WITH_DEBUG
-    DEBUG(("Sending encrypted packet:\n"));
-    hexdump(s->p + 8, datalen);
-#endif
-
-    sec_sign(s->p, 8, This->secure.sign_key, This->secure.rc4_key_len, s->p + 8,
-             datalen);
-    sec_encrypt(This, s->p + 8, datalen);
+    datalen = s->end - s->p - 8;
+    sec_sign(s->p, 8, g_sec_sign_key, g_rc4_key_len, s->p + 8, datalen);
+    sec_encrypt(s->p + 8, datalen);
   }
 
-  return mcs_send_to_channel(This, s, channel);
+  mcs_send_to_channel(s, channel);
+
+#ifdef WITH_SCARD
+  scard_unlock(SCARD_LOCK_SEC);
+#endif
 }
 
 /* Transmit secure transport packet */
 
-BOOL sec_send(RDPCLIENT *This, STREAM s, uint32 flags) {
-  return sec_send_to_channel(This, s, flags, MCS_GLOBAL_CHANNEL);
+void sec_send(STREAM s, uint32 flags) {
+  sec_send_to_channel(s, flags, MCS_GLOBAL_CHANNEL);
 }
 
 /* Transfer the client random to the server */
-static void sec_establish_key(RDPCLIENT *This) {
-  uint32 length = This->secure.server_public_key_len + SEC_PADDING_SIZE;
-  uint32 flags = SEC_CLIENT_RANDOM;
+static void sec_establish_key(void) {
+  uint32 length = g_server_public_key_len + SEC_PADDING_SIZE;
+  uint32 flags = SEC_EXCHANGE_PKT;
   STREAM s;
 
-  s = sec_init(This, flags, length + 4);
+  s = sec_init(flags, length + 4);
 
   out_uint32_le(s, length);
-  out_uint8p(s, This->secure.crypted_random,
-             This->secure.server_public_key_len);
+  out_uint8p(s, g_sec_crypted_random, g_server_public_key_len);
   out_uint8s(s, SEC_PADDING_SIZE);
 
   s_mark_end(s);
-  sec_send(This, s, flags);
+  sec_send(s, flags);
 }
 
 /* Output connect initial data blob */
-static void sec_out_mcs_data(RDPCLIENT *This, STREAM s, wchar_t *hostname) {
-  int hostlen = 2 * (int)wcslen(hostname);
-  int length = 158 + 76 + 12 + 4;
+static void sec_out_mcs_connect_initial_pdu(STREAM s,
+                                            uint32 selected_protocol) {
+  int length = 162 + 76 + 12 + 4 + (g_dpi > 0 ? 18 : 0);
   unsigned int i;
+  uint32 rdpversion = RDP_40;
+  uint16 capflags = RNS_UD_CS_SUPPORT_ERRINFO_PDU;
+  uint16 colorsupport =
+      RNS_UD_24BPP_SUPPORT | RNS_UD_16BPP_SUPPORT | RNS_UD_32BPP_SUPPORT;
+  uint32 physwidth, physheight, desktopscale, devicescale;
+
+  logger(Protocol, Debug, "%s()", __func__);
 
-  if (This->num_channels > 0)
-    length += This->num_channels * 12 + 8;
+  if (g_rdp_version >= RDP_V5)
+    rdpversion = RDP_50;
 
-  if (hostlen > 30)
-    hostlen = 30;
+  if (g_num_channels > 0)
+    length += g_num_channels * 12 + 8;
 
   /* Generic Conference Control (T.124) ConferenceCreateRequest */
   out_uint16_be(s, 5);
@@ -377,62 +385,85 @@
   out_uint32_le(s, 0x61637544); /* OEM ID: "Duca", as in Ducati. */
   out_uint16_be(s, ((length - 14) | 0x8000)); /* remaining length */
 
-  /* Client information */
-  out_uint16_le(s, SEC_TAG_CLI_INFO);
-  out_uint16_le(s, 212); /* length */
-  out_uint16_le(s, This->use_rdp5 ? 4
-                                  : 1); /* RDP version. 1 == RDP4, 4 == RDP5. */
-  out_uint16_le(s, 8);
-  out_uint16_le(s, This->width);
-  out_uint16_le(s, This->height);
-  out_uint16_le(s, 0xca01);
-  out_uint16_le(s, 0xaa03);
-  out_uint32_le(s, This->keylayout);
+  /* Client information (TS_UD_CS_CORE) */
+  out_uint16_le(s, CS_CORE);                    /* type */
+  out_uint16_le(s, 216 + (g_dpi > 0 ? 18 : 0)); /* length */
+  out_uint32_le(s, rdpversion);                 /* version */
+  out_uint16_le(s, g_requested_session_width);  /* desktopWidth */
+  out_uint16_le(s, g_requested_session_height); /* desktopHeight */
+  out_uint16_le(s, RNS_UD_COLOR_8BPP);          /* colorDepth */
+  out_uint16_le(s, RNS_UD_SAS_DEL);             /* SASSequence */
+  out_uint32_le(s, g_keylayout);                /* keyboardLayout */
   out_uint32_le(s, 2600); /* Client build. We are now 2600 compatible :-) */
 
   /* Unicode name of client, padded to 32 bytes */
-  rdp_out_unistr(This, s, hostname, hostlen);
-  out_uint8s(s, 30 - hostlen);
-
-  /* See
-     http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wceddk40/html/cxtsksupportingremotedesktopprotocol.asp
-   */
-  out_uint32_le(s, This->keyboard_type);
-  out_uint32_le(s, This->keyboard_subtype);
-  out_uint32_le(s, This->keyboard_functionkeys);
-  out_uint8s(s, 64);        /* reserved? 4 + 12 doublewords */
-  out_uint16_le(s, 0xca01); /* colour depth? */
-  out_uint16_le(s, 1);
-
-  out_uint32(s, 0);
-  out_uint8(s, This->server_depth);
-  out_uint16_le(s, 0x0700);
-  out_uint8(s, 0);
-  out_uint32_le(s, 1);
-  out_uint8s(s, 64); /* End of client info */
+  out_utf16s_padded(s, g_hostname, 32, 0x00);
 
-  out_uint16_le(s, SEC_TAG_CLI_4);
-  out_uint16_le(s, 12);
-  out_uint32_le(s, This->console_session ? 0xb : 9);
-  out_uint32(s, 0);
-
-  /* Client encryption settings */
-  out_uint16_le(s, SEC_TAG_CLI_CRYPT);
-  out_uint16_le(s, 12); /* length */
-  out_uint32_le(s, This->encryption
-                       ? 0x3
-                       : 0); /* encryption supported, 128-bit supported */
-  out_uint32(s, 0);          /* Unknown */
-
-  DEBUG_RDP5(("This->num_channels is %d\n", This->num_channels));
-  if (This->num_channels > 0) {
-    out_uint16_le(s, SEC_TAG_CLI_CHANNELS);
-    out_uint16_le(s, This->num_channels * 12 + 8); /* length */
-    out_uint32_le(s, This->num_channels); /* number of virtual channels */
-    for (i = 0; i < This->num_channels; i++) {
-      DEBUG_RDP5(("Requesting channel %s\n", This->channels[i].name));
-      out_uint8a(s, This->channel_defs[i].name, 8);
-      out_uint32_be(s, This->channel_defs[i].options);
+  out_uint32_le(s, g_keyboard_type);         /* keyboardType */
+  out_uint32_le(s, g_keyboard_subtype);      /* keyboardSubtype */
+  out_uint32_le(s, g_keyboard_functionkeys); /* keyboardFunctionKey */
+  out_uint8s(s, 64);                         /* imeFileName */
+  out_uint16_le(
+      s, RNS_UD_COLOR_8BPP); /* postBeta2ColorDepth (overrides colorDepth) */
+  out_uint16_le(s, 1);       /* clientProductId (should be 1) */
+  out_uint32_le(s, 0);       /* serialNumber (should be 0) */
+
+  /* highColorDepth (overrides postBeta2ColorDepth). Capped at 24BPP.
+     To get 32BPP sessions, we need to set a capability flag. */
+  out_uint16_le(s, MIN(g_server_depth, 24));
+  if (g_server_depth == 32)
+    capflags |= RNS_UD_CS_WANT_32BPP_SESSION;
+
+  out_uint16_le(s, colorsupport);      /* supportedColorDepths */
+  out_uint16_le(s, capflags);          /* earlyCapabilityFlags */
+  out_uint8s(s, 64);                   /* clientDigProductId */
+  out_uint8(s, 0);                     /* connectionType */
+  out_uint8(s, 0);                     /* pad */
+  out_uint32_le(s, selected_protocol); /* serverSelectedProtocol */
+  if (g_dpi > 0) {
+    /* Extended client info describing monitor geometry */
+    utils_calculate_dpi_scale_factors(
+        g_requested_session_width, g_requested_session_height, g_dpi,
+        &physwidth, &physheight, &desktopscale, &devicescale);
+    out_uint32_le(s, physwidth);             /* physicalwidth */
+    out_uint32_le(s, physheight);            /* physicalheight */
+    out_uint16_le(s, ORIENTATION_LANDSCAPE); /* Orientation */
+    out_uint32_le(s, desktopscale);          /* DesktopScaleFactor */
+    out_uint32_le(s, devicescale);           /* DeviceScaleFactor */
+  }
+
+  /* Write a Client Cluster Data (TS_UD_CS_CLUSTER) */
+  uint32 cluster_flags = 0;
+  out_uint16_le(s, CS_CLUSTER); /* header.type */
+  out_uint16_le(s, 12);         /* length */
+
+  cluster_flags |= SEC_CC_REDIRECTION_SUPPORTED;
+  cluster_flags |= (SEC_CC_REDIRECT_VERSION_3 << 2);
+
+  if (g_console_session || g_redirect_session_id != 0)
+    cluster_flags |= SEC_CC_REDIRECT_SESSIONID_FIELD_VALID;
+
+  out_uint32_le(s, cluster_flags);
+  out_uint32(s, g_redirect_session_id);
+
+  /* Client encryption settings (TS_UD_CS_SEC) */
+  out_uint16_le(s, CS_SECURITY);            /* type */
+  out_uint16_le(s, 12);                     /* length */
+  out_uint32_le(s, g_encryption ? 0x3 : 0); /* encryptionMethods */
+  out_uint32(s, 0);                         /* extEncryptionMethods */
+
+  /* Channel definitions (TS_UD_CS_NET) */
+  logger(Protocol, Debug, "sec_out_mcs_data(), g_num_channels is %d",
+         g_num_channels);
+  if (g_num_channels > 0) {
+    out_uint16_le(s, CS_NET);                  /* type */
+    out_uint16_le(s, g_num_channels * 12 + 8); /* length */
+    out_uint32_le(s, g_num_channels);          /* number of virtual channels */
+    for (i = 0; i < g_num_channels; i++) {
+      logger(Protocol, Debug, "sec_out_mcs_data(), requesting channel %s",
+             g_channels[i].name);
+      out_uint8a(s, g_channels[i].name, 8);
+      out_uint32_be(s, g_channels[i].flags);
     }
   }
 
@@ -440,84 +471,81 @@
 }
 
 /* Parse a public key structure */
-static BOOL sec_parse_public_key(RDPCLIENT *This, STREAM s, uint8 **modulus,
-                                 uint8 **exponent) {
+static RD_BOOL sec_parse_public_key(STREAM s, uint8 *modulus, uint8 *exponent) {
   uint32 magic, modulus_len;
 
   in_uint32_le(s, magic);
   if (magic != SEC_RSA_MAGIC) {
-    error("RSA magic 0x%x\n", magic);
+    logger(Protocol, Error,
+           "sec_parse_public_key(), magic (0x%x) != SEC_RSA_MAGIC", magic);
     return False;
   }
 
   in_uint32_le(s, modulus_len);
   modulus_len -= SEC_PADDING_SIZE;
-  if ((modulus_len < 64) || (modulus_len > SEC_MAX_MODULUS_SIZE)) {
-    error("Bad server public key size (%u bits)\n", modulus_len * 8);
+  if ((modulus_len < SEC_MODULUS_SIZE) ||
+      (modulus_len > SEC_MAX_MODULUS_SIZE)) {
+    logger(
+        Protocol, Error,
+        "sec_parse_public_key(), invalid public key size (%u bits) from server",
+        modulus_len * 8);
     return False;
   }
 
   in_uint8s(s, 8); /* modulus_bits, unknown */
-  in_uint8p(s, *exponent, SEC_EXPONENT_SIZE);
-  in_uint8p(s, *modulus, modulus_len);
+  in_uint8a(s, exponent, SEC_EXPONENT_SIZE);
+  in_uint8a(s, modulus, modulus_len);
   in_uint8s(s, SEC_PADDING_SIZE);
-  This->secure.server_public_key_len = modulus_len;
+  g_server_public_key_len = modulus_len;
 
   return s_check(s);
 }
 
-static BOOL sec_parse_x509_key(RDPCLIENT *This, X509 *cert) {
-  EVP_PKEY *epk = NULL;
-  /* By some reason, Microsoft sets the OID of the Public RSA key to
-     the oid for "MD5 with RSA Encryption" instead of "RSA Encryption"
-
-     Kudos to Richard Levitte for the following (. intiutive .)
-     lines of code that resets the OID and let's us extract the key. */
-  if (OBJ_obj2nid(cert->cert_info->key->algor->algorithm) ==
-      NID_md5WithRSAEncryption) {
-    DEBUG_RDP5(("Re-setting algorithm type to RSA in server certificate\n"));
-    ASN1_OBJECT_free(cert->cert_info->key->algor->algorithm);
-    cert->cert_info->key->algor->algorithm = OBJ_nid2obj(NID_rsaEncryption);
-  }
-  epk = X509_get_pubkey(cert);
-  if (NULL == epk) {
-    error("Failed to extract public key from certificate\n");
-    return False;
-  }
-
-  This->secure.server_public_key = RSAPublicKey_dup((RSA *)epk->pkey.ptr);
-  EVP_PKEY_free(epk);
-
-  This->secure.server_public_key_len = RSA_size(This->secure.server_public_key);
-  if ((This->secure.server_public_key_len < 64) ||
-      (This->secure.server_public_key_len > SEC_MAX_MODULUS_SIZE)) {
-    error("Bad server public key size (%u bits)\n",
-          This->secure.server_public_key_len * 8);
-    return False;
-  }
-
-  return True;
+/* Parse a public signature structure */
+static RD_BOOL sec_parse_public_sig(STREAM s, uint32 len, uint8 *modulus,
+                                    uint8 *exponent) {
+  uint8 signature[SEC_MAX_MODULUS_SIZE];
+  uint32 sig_len;
+
+  if (len != 72) {
+    return True;
+  }
+  memset(signature, 0, sizeof(signature));
+  sig_len = len - 8;
+  in_uint8a(s, signature, sig_len);
+  return rdssl_sig_ok(exponent, SEC_EXPONENT_SIZE, modulus,
+                      g_server_public_key_len, signature, sig_len);
 }
 
 /* Parse a crypto information structure */
-static BOOL sec_parse_crypt_info(RDPCLIENT *This, STREAM s,
-                                 uint32 *rc4_key_size, uint8 **server_random,
-                                 uint8 **modulus, uint8 **exponent) {
+static RD_BOOL sec_parse_crypt_info(STREAM s, uint32 *rc4_key_size,
+                                    uint8 **server_random, uint8 *modulus,
+                                    uint8 *exponent) {
   uint32 crypt_level, random_len, rsa_info_len;
   uint32 cacert_len, cert_len, flags;
-  X509 *cacert, *server_cert;
+  RDSSL_CERT *cacert, *server_cert;
+  RDSSL_RKEY *server_public_key;
   uint16 tag, length;
   uint8 *next_tag, *end;
 
+  logger(Protocol, Debug, "%s()", __func__);
+
   in_uint32_le(s, *rc4_key_size); /* 1 = 40-bit, 2 = 128-bit */
   in_uint32_le(s, crypt_level);   /* 1 = low, 2 = medium, 3 = high */
-  if (crypt_level == 0)           /* no encryption */
+  if (crypt_level == 0) {
+    /* no encryption */
+    logger(Protocol, Debug,
+           "sec_parse_crypt_info(), got ENCRYPTION_LEVEL_NONE");
     return False;
+  }
+
   in_uint32_le(s, random_len);
   in_uint32_le(s, rsa_info_len);
 
   if (random_len != SEC_RANDOM_SIZE) {
-    error("random len %d, expected %d\n", random_len, SEC_RANDOM_SIZE);
+    logger(Protocol, Error,
+           "sec_parse_crypt_info(), got random len %d, expected %d", random_len,
+           SEC_RANDOM_SIZE);
     return False;
   }
 
@@ -525,12 +553,15 @@
 
   /* RSA info */
   end = s->p + rsa_info_len;
-  if (end > s->end)
+  if (end > s->end) {
+    logger(Protocol, Error, "sec_parse_crypt_info(), end > s->end");
     return False;
+  }
 
   in_uint32_le(s, flags); /* 1 = RDP4-style, 0x80000002 = X.509 */
   if (flags & 1) {
-    DEBUG_RDP5(("We're going for the RDP4-style encryption\n"));
+    logger(Protocol, Debug,
+           "sec_parse_crypt_info(), We're going for the RDP4-style encryption");
     in_uint8s(s, 8); /* unknown */
 
     while (s->p < end) {
@@ -541,22 +572,24 @@
 
       switch (tag) {
       case SEC_TAG_PUBKEY:
-        if (!sec_parse_public_key(This, s, modulus, exponent))
+        if (!sec_parse_public_key(s, modulus, exponent)) {
+          logger(Protocol, Error, "sec_parse_crypt_info(), invalid public key");
           return False;
-        DEBUG_RDP5(("Got Public key, RDP4-style\n"));
+        }
+        logger(Protocol, Debug, "sec_parse_crypt_info(), got public key");
 
         break;
 
       case SEC_TAG_KEYSIG:
-        /* Is this a Microsoft key that we just got? */
-        /* Care factor: zero! */
-        /* Actually, it would probably be a good idea to check if the public key
-           is signed with this key, and then store this key as a known key of
-           the hostname. This would prevent some MITM-attacks. */
+        if (!sec_parse_public_sig(s, length, modulus, exponent)) {
+          logger(Protocol, Error, "sec_parse_crypt_info(), invalid public sig");
+          return False;
+        }
         break;
 
       default:
-        unimpl("crypt tag 0x%x\n", tag);
+        logger(Protocol, Warning,
+               "sec_parse_crypt_info(), unhandled crypt tag 0x%x", tag);
       }
 
       s->p = next_tag;
@@ -564,37 +597,29 @@
   } else {
     uint32 certcount;
 
-    DEBUG_RDP5(("We're going for the RDP5-style encryption\n"));
+    logger(Protocol, Debug,
+           "sec_parse_crypt_info(), We're going for the RDP5-style encryption");
     in_uint32_le(s, certcount); /* Number of certificates */
-
     if (certcount < 2) {
-      error("Server didn't send enough X509 certificates\n");
-      This->disconnect_reason = 1798;
+      logger(Protocol, Error,
+             "sec_parse_crypt_info(), server didn't send enough x509 "
+             "certificates");
       return False;
     }
-
     for (; certcount > 2; certcount--) { /* ignore all the certificates between
                                             the root and the signing CA */
       uint32 ignorelen;
-      X509 *ignorecert;
-
-      DEBUG_RDP5(("Ignored certs left: %d\n", certcount));
+      RDSSL_CERT *ignorecert;
 
       in_uint32_le(s, ignorelen);
-      DEBUG_RDP5(("Ignored Certificate length is %d\n", ignorelen));
-      ignorecert = d2i_X509(NULL, &(s->p), ignorelen);
-
+      ignorecert = rdssl_cert_read(s->p, ignorelen);
+      in_uint8s(s, ignorelen);
       if (ignorecert == NULL) { /* XXX: error out? */
-        DEBUG_RDP5(("got a bad cert: this will probably screw up the rest of "
-                    "the communication\n"));
+        logger(Protocol, Error,
+               "sec_parse_crypt_info(), got a bad cert: this will probably "
+               "screw up the rest of the communication");
       }
-
-#ifdef WITH_DEBUG_RDP5
-      DEBUG_RDP5(("cert #%d (ignored):\n", certcount));
-      X509_print_fp(stdout, ignorecert);
-#endif
     }
-
     /* Do da funky X.509 stuffy
 
        "How did I find out about this?  I looked up and saw a
@@ -603,116 +628,104 @@
        - Peter Gutman in a early version of
        http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt
      */
-
     in_uint32_le(s, cacert_len);
-    DEBUG_RDP5(("CA Certificate length is %d\n", cacert_len));
-    cacert = d2i_X509(NULL, &(s->p), cacert_len);
-    /* Note: We don't need to move s->p here - d2i_X509 is
-       "kind" enough to do it for us */
+    logger(Protocol, Debug,
+           "sec_parse_crypt_info(), server CA Certificate length is %d",
+           cacert_len);
+    cacert = rdssl_cert_read(s->p, cacert_len);
+    in_uint8s(s, cacert_len);
     if (NULL == cacert) {
-      error("Couldn't load CA Certificate from server\n");
-      This->disconnect_reason = 1798;
+      logger(
+          Protocol, Error,
+          "sec_parse_crypt_info(), couldn't load CA Certificate from server");
       return False;
     }
-
-    /* Currently, we don't use the CA Certificate.
-       FIXME:
-       *) Verify the server certificate (server_cert) with the
-       CA certificate.
-       *) Store the CA Certificate with the hostname of the
-       server we are connecting to as key, and compare it
-       when we connect the next time, in order to prevent
-       MITM-attacks.
-     */
-
-    X509_free(cacert);
-
     in_uint32_le(s, cert_len);
-    DEBUG_RDP5(("Certificate length is %d\n", cert_len));
-    server_cert = d2i_X509(NULL, &(s->p), cert_len);
+    logger(Protocol, Debug, "sec_parse_crypt_info(), certificate length is %d",
+           cert_len);
+    server_cert = rdssl_cert_read(s->p, cert_len);
+    in_uint8s(s, cert_len);
     if (NULL == server_cert) {
-      error("Couldn't load Certificate from server\n");
-      This->disconnect_reason = 1798;
+      rdssl_cert_free(cacert);
+      logger(Protocol, Error,
+             "sec_parse_crypt_info(), couldn't load Certificate from server");
       return False;
     }
-
+    if (!rdssl_certs_ok(server_cert, cacert)) {
+      rdssl_cert_free(server_cert);
+      rdssl_cert_free(cacert);
+      logger(Protocol, Error,
+             "sec_parse_crypt_info(), security error, CA Certificate invalid");
+      return False;
+    }
+    rdssl_cert_free(cacert);
     in_uint8s(s, 16); /* Padding */
-
-    /* Note: Verifying the server certificate must be done here,
-       before sec_parse_public_key since we'll have to apply
-       serious violence to the key after this */
-
-    if (!sec_parse_x509_key(This, server_cert)) {
-      DEBUG_RDP5(("Didn't parse X509 correctly\n"));
-      X509_free(server_cert);
-      This->disconnect_reason = 1798;
+    server_public_key =
+        rdssl_cert_to_rkey(server_cert, &g_server_public_key_len);
+    if (NULL == server_public_key) {
+      logger(Protocol, Debug,
+             "sec_parse_crypt_info(). failed to parse X509 correctly");
+      rdssl_cert_free(server_cert);
+      return False;
+    }
+    rdssl_cert_free(server_cert);
+    if ((g_server_public_key_len < SEC_MODULUS_SIZE) ||
+        (g_server_public_key_len > SEC_MAX_MODULUS_SIZE)) {
+      logger(Protocol, Error,
+             "sec_parse_crypt_info(), bad server public key size (%u bits)",
+             g_server_public_key_len * 8);
+      rdssl_rkey_free(server_public_key);
+      return False;
+    }
+    if (rdssl_rkey_get_exp_mod(server_public_key, exponent, SEC_EXPONENT_SIZE,
+                               modulus, SEC_MAX_MODULUS_SIZE) != 0) {
+      logger(
+          Protocol, Error,
+          "sec_parse_crypt_info(), problem extracting RSA exponent, modulus");
+      rdssl_rkey_free(server_public_key);
       return False;
     }
-    X509_free(server_cert);
+    rdssl_rkey_free(server_public_key);
     return True; /* There's some garbage here we don't care about */
   }
   return s_check_end(s);
 }
 
 /* Process crypto information blob */
-static void sec_process_crypt_info(RDPCLIENT *This, STREAM s) {
-  uint8 *server_random, *modulus, *exponent;
-  uint8 client_random[SEC_RANDOM_SIZE];
+static void sec_process_crypt_info(STREAM s) {
+  uint8 *server_random = NULL;
+  uint8 modulus[SEC_MAX_MODULUS_SIZE];
+  uint8 exponent[SEC_EXPONENT_SIZE];
   uint32 rc4_key_size;
 
-  if (!sec_parse_crypt_info(This, s, &rc4_key_size, &server_random, &modulus,
-                            &exponent)) {
-    DEBUG(("Failed to parse crypt info\n"));
-    return;
-  }
-
-  DEBUG(("Generating client random\n"));
-  generate_random(client_random);
+  logger(Protocol, Debug, "%s()", __func__);
 
-  if (NULL != This->secure.server_public_key) { /* Which means we should use
-                                                   RDP5-style encryption */
-    uint8 inr[SEC_MAX_MODULUS_SIZE];
-    uint32 padding_len = This->secure.server_public_key_len - SEC_RANDOM_SIZE;
-
-    /* This is what the MS client do: */
-    memset(inr, 0, padding_len);
-    /*  *ARIGL!* Plaintext attack, anyone?
-       I tried doing:
-       generate_random(inr);
-       ..but that generates connection errors now and then (yes,
-       "now and then". Something like 0 to 3 attempts needed before a
-       successful connection. Nice. Not!
-     */
-    memcpy(inr + padding_len, client_random, SEC_RANDOM_SIZE);
-    reverse(inr + padding_len, SEC_RANDOM_SIZE);
+  memset(modulus, 0, sizeof(modulus));
+  memset(exponent, 0, sizeof(exponent));
+  if (!sec_parse_crypt_info(s, &rc4_key_size, &server_random, modulus,
+                            exponent))
+    return;
 
-    RSA_public_encrypt(This->secure.server_public_key_len, inr,
-                       This->secure.crypted_random,
-                       This->secure.server_public_key, RSA_NO_PADDING);
-
-    reverse(This->secure.crypted_random, This->secure.server_public_key_len);
-
-    RSA_free(This->secure.server_public_key);
-    This->secure.server_public_key = NULL;
-  } else { /* RDP4-style encryption */
-    sec_rsa_encrypt(This->secure.crypted_random, client_random, SEC_RANDOM_SIZE,
-                    This->secure.server_public_key_len, modulus, exponent);
-  }
-  sec_generate_keys(This, client_random, server_random, rc4_key_size);
+  logger(Protocol, Debug, "sec_parse_crypt_info(), generating client random");
+  generate_random(g_client_random);
+  sec_rsa_encrypt(g_sec_crypted_random, g_client_random, SEC_RANDOM_SIZE,
+                  g_server_public_key_len, modulus, exponent);
+  sec_generate_keys(g_client_random, server_random, rc4_key_size);
 }
 
 /* Process SRV_INFO, find RDP version supported by server */
-static void sec_process_srv_info(RDPCLIENT *This, STREAM s) {
-  in_uint16_le(s, This->server_rdp_version);
-  DEBUG_RDP5(("Server RDP version is %d\n", This->server_rdp_version));
-  if (1 == This->server_rdp_version) {
-    This->use_rdp5 = 0;
-    This->server_depth = 8;
+static void sec_process_srv_info(STREAM s) {
+  in_uint16_le(s, g_server_rdp_version);
+  logger(Protocol, Debug, "sec_process_srv_info(), server RDP version is %d",
+         g_server_rdp_version);
+  if (1 == g_server_rdp_version) {
+    g_rdp_version = RDP_V4;
+    g_server_depth = 8;
   }
 }
 
 /* Process connect response data blob */
-void sec_process_mcs_data(RDPCLIENT *This, STREAM s) {
+void sec_process_mcs_data(STREAM s) {
   uint16 tag, length;
   uint8 *next_tag;
   uint8 len;
@@ -721,6 +734,7 @@
   in_uint8(s, len);
   if (len & 0x80)
     in_uint8(s, len);
+  logger(Protocol, Debug, "%s()", __func__);
 
   while (s->p < s->end) {
     in_uint16_le(s, tag);
@@ -733,21 +747,24 @@
 
     switch (tag) {
     case SEC_TAG_SRV_INFO:
-      sec_process_srv_info(This, s);
+      logger(Protocol, Debug, "%s(), SEC_TAG_SRV_INFO", __func__);
+      sec_process_srv_info(s);
       break;
 
     case SEC_TAG_SRV_CRYPT:
-      sec_process_crypt_info(This, s);
+      logger(Protocol, Debug, "%s(), SEC_TAG_SRV_CRYPT", __func__);
+      sec_process_crypt_info(s);
       break;
 
     case SEC_TAG_SRV_CHANNELS:
+      logger(Protocol, Debug, "%s(), SEC_TAG_SRV_CHANNELS", __func__);
       /* FIXME: We should parse this information and
          use it to map RDP5 channels to MCS
          channels */
       break;
 
     default:
-      unimpl("response tag 0x%x\n", tag);
+      logger(Protocol, Warning, "Unhandled response tag 0x%x", tag);
     }
 
     s->p = next_tag;
@@ -756,72 +773,80 @@
 
 /* Receive secure transport packet */
 STREAM
-sec_recv(RDPCLIENT *This, uint8 *rdpver) {
-  uint32 sec_flags;
+sec_recv(RD_BOOL *is_fastpath) {
+  uint8 fastpath_hdr, fastpath_flags;
+  uint16 sec_flags;
   uint16 channel;
   STREAM s;
 
-  while ((s = mcs_recv(This, &channel, rdpver)) != NULL) {
-    if (rdpver != NULL) {
-      if (*rdpver != 3) {
-        if (*rdpver & 0x80) {
-          in_uint8s(s, 8); /* signature */
-          sec_decrypt(This, s->p, (int)(s->end - s->p));
-        }
-        return s;
+  while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL) {
+    if (*is_fastpath == True) {
+      /* If fastpath packet is encrypted, read data
+         signature and decrypt */
+      /* FIXME: extracting flags from hdr could be made less obscure */
+      fastpath_flags = (fastpath_hdr & 0xC0) >> 6;
+      if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED) {
+        in_uint8s(s, 8); /* signature */
+        sec_decrypt(s->p, s->end - s->p);
       }
+      return s;
     }
-    if (This->encryption || !This->licence_issued) {
-      in_uint32_le(s, sec_flags);
 
-      if (sec_flags & SEC_ENCRYPT) {
-        in_uint8s(s, 8); /* signature */
-        sec_decrypt(This, s->p, (int)(s->end - s->p));
-      }
+    if (g_encryption || (!g_licence_issued && !g_licence_error_result)) {
+      /* TS_SECURITY_HEADER */
+      in_uint16_le(s, sec_flags);
+      in_uint8s(s, 2); /* skip sec_flags_hi */
 
-      if (sec_flags & SEC_LICENCE_NEG) {
-        licence_process(This, s);
-        continue;
-      }
+      if (g_encryption) {
+        if (sec_flags & SEC_ENCRYPT) {
+          in_uint8s(s, 8); /* signature */
+          sec_decrypt(s->p, s->end - s->p);
+        }
 
-      if (sec_flags & 0x0400) /* SEC_REDIRECT_ENCRYPT */
-      {
-        uint8 swapbyte;
+        if (sec_flags & SEC_LICENSE_PKT) {
+          licence_process(s);
+          continue;
+        }
 
-        in_uint8s(s, 8); /* signature */
-        sec_decrypt(This, s->p, (int)(s->end - s->p));
+        if (sec_flags & SEC_REDIRECTION_PKT) {
+          uint8 swapbyte;
+
+          in_uint8s(s, 8); /* signature */
+          sec_decrypt(s->p, s->end - s->p);
 
-        /* Check for a redirect packet, starts with 00 04 */
-        if (s->p[0] == 0 && s->p[1] == 4) {
-          /* for some reason the PDU and the length seem to be swapped.
-             This isn't good, but we're going to do a byte for byte
-             swap.  So the first foure value appear as: 00 04 XX YY,
-             where XX YY is the little endian length. We're going to
-             use 04 00 as the PDU type, so after our swap this will look
-             like: XX YY 04 00 */
-          swapbyte = s->p[0];
-          s->p[0] = s->p[2];
-          s->p[2] = swapbyte;
-
-          swapbyte = s->p[1];
-          s->p[1] = s->p[3];
-          s->p[3] = swapbyte;
-
-          swapbyte = s->p[2];
-          s->p[2] = s->p[3];
-          s->p[3] = swapbyte;
+          /* Check for a redirect packet, starts with 00 04 */
+          if (s->p[0] == 0 && s->p[1] == 4) {
+            /* for some reason the PDU and the length seem to be swapped.
+               This isn't good, but we're going to do a byte for byte
+               swap.  So the first four value appear as: 00 04 XX YY,
+               where XX YY is the little endian length. We're going to
+               use 04 00 as the PDU type, so after our swap this will look
+               like: XX YY 04 00 */
+            swapbyte = s->p[0];
+            s->p[0] = s->p[2];
+            s->p[2] = swapbyte;
+
+            swapbyte = s->p[1];
+            s->p[1] = s->p[3];
+            s->p[3] = swapbyte;
+
+            swapbyte = s->p[2];
+            s->p[2] = s->p[3];
+            s->p[3] = swapbyte;
+          }
         }
-#ifdef WITH_DEBUG
-        /* warning!  this debug statement will show passwords in the clear! */
-        hexdump(s->p, s->end - s->p);
-#endif
+      } else {
+        if (sec_flags & SEC_LICENSE_PKT) {
+          licence_process(s);
+          continue;
+        }
+        s->p -= 4;
       }
     }
 
     if (channel != MCS_GLOBAL_CHANNEL) {
-      channel_process(This, s, channel);
-      *rdpver = 0xff;
-      return s;
+      channel_process(s, channel);
+      continue;
     }
 
     return s;
@@ -831,64 +856,46 @@
 }
 
 /* Establish a secure connection */
-BOOL sec_connect(RDPCLIENT *This, char *server, wchar_t *hostname,
-                 char *cookie) {
+RD_BOOL
+sec_connect(char *server, char *username, char *domain, char *password,
+            RD_BOOL reconnect) {
+  uint32 selected_proto;
   struct stream mcs_data;
-  void *p = malloc(512);
 
-  if (p == NULL) {
-    This->disconnect_reason = 262;
+  /* Start a MCS connect sequence */
+  if (!mcs_connect_start(server, username, domain, password, reconnect,
+                         &selected_proto))
     return False;
-  }
 
   /* We exchange some RDP data during the MCS-Connect */
   mcs_data.size = 512;
-  mcs_data.p = mcs_data.data = (uint8 *)p;
-  sec_out_mcs_data(This, &mcs_data, hostname);
+  mcs_data.p = mcs_data.data = (uint8 *)xmalloc(mcs_data.size);
+  sec_out_mcs_connect_initial_pdu(&mcs_data, selected_proto);
 
-  if (!mcs_connect(This, server, cookie, &mcs_data))
+  /* finalize the MCS connect sequence */
+  if (!mcs_connect_finalize(&mcs_data))
     return False;
 
-  /*      sec_process_mcs_data(&mcs_data); */
-  if (This->encryption)
-    sec_establish_key(This);
-  free(mcs_data.data);
-  return True;
-}
-
-/* Establish a secure connection */
-BOOL sec_reconnect(RDPCLIENT *This, char *server, wchar_t *hostname,
-                   char *cookie) {
-  struct stream mcs_data;
-  void *p = malloc(512);
-
-  if (p == NULL) {
-    This->disconnect_reason = 262;
-    return False;
-  }
-
-  /* We exchange some RDP data during the MCS-Connect */
-  mcs_data.size = 512;
-  mcs_data.p = mcs_data.data = (uint8 *)p;
-  sec_out_mcs_data(This, &mcs_data, hostname);
-
-  if (!mcs_reconnect(This, server, cookie, &mcs_data))
-    return False;
-
-  /*      sec_process_mcs_data(&mcs_data); */
-  if (This->encryption)
-    sec_establish_key(This);
-  free(mcs_data.data);
+  /* sec_process_mcs_data(&mcs_data); */
+  if (g_encryption)
+    sec_establish_key();
+  xfree(mcs_data.data);
   return True;
 }
 
 /* Disconnect a connection */
-void sec_disconnect(RDPCLIENT *This) { mcs_disconnect(This); }
+void sec_disconnect(void) {
+  /* Perform a User-initiated disconnect sequence, see
+     [MS-RDPBCGR] 1.3.1.4 Disconnect Sequences */
+  mcs_disconnect(RN_USER_REQUESTED);
+}
 
 /* reset the state of the sec layer */
-void sec_reset_state(RDPCLIENT *This) {
-  This->server_rdp_version = 0;
-  This->secure.encrypt_use_count = 0;
-  This->secure.decrypt_use_count = 0;
-  mcs_reset_state(This);
+void sec_reset_state(void) {
+  g_server_rdp_version = 0;
+  g_sec_encrypt_use_count = 0;
+  g_sec_decrypt_use_count = 0;
+  g_licence_issued = 0;
+  g_licence_error_result = 0;
+  mcs_reset_state();
 }
