--- /home/V1SCAN/CWE-122/FormattedUsed/mprintf-TizenRT-3.0GBM.c	2023-12-12 03:51:15.818364857 +0900
+++ /home/V1SCAN/CWE-122/FormattedVul/OLD##CVE-2016-9586##0##curl@@curl##mprintf.c	2023-12-12 03:51:16.158363705 +0900
@@ -5,7 +5,7 @@
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1999 - 2017, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1999 - 2016, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
@@ -42,10 +42,18 @@
 /* The last #include file should be: */
 #include "memdebug.h"
 
+#ifndef SIZEOF_LONG_DOUBLE
+#define SIZEOF_LONG_DOUBLE 0
+#endif
+
 /*
  * If SIZEOF_SIZE_T has not been defined, default to the size of long.
  */
 
+#ifndef SIZEOF_SIZE_T
+#define SIZEOF_SIZE_T CURL_SIZEOF_LONG
+#endif
+
 #ifdef HAVE_LONGLONG
 #define LONG_LONG_TYPE long long
 #define HAVE_LONG_LONG_TYPE
@@ -83,9 +91,7 @@
 #define mp_uintmax_t unsigned long
 #endif
 
-#define BUFFSIZE                                                               \
-  326 /* buffer for long-to-str and float-to-str calcs, should                 \
-         fit negative DBL_MAX (317 letters) */
+#define BUFFSIZE 256       /* buffer for long-to-str and float-to-str calcs */
 #define MAX_PARAMETERS 128 /* lame static limit */
 
 #ifdef __AMIGA__
@@ -334,7 +340,7 @@
             break;
 #if defined(MP_HAVE_INT_EXTENSIONS)
           case 'I':
-#if (SIZEOF_CURL_OFF_T > SIZEOF_LONG)
+#if (CURL_SIZEOF_CURL_OFF_T > CURL_SIZEOF_LONG)
             flags |= FLAGS_LONGLONG;
 #else
             flags |= FLAGS_LONG;
@@ -356,14 +362,14 @@
           case 'z':
             /* the code below generates a warning if -Wunreachable-code is
                used */
-#if (SIZEOF_SIZE_T > SIZEOF_LONG)
+#if (SIZEOF_SIZE_T > CURL_SIZEOF_LONG)
             flags |= FLAGS_LONGLONG;
 #else
           flags |= FLAGS_LONG;
 #endif
             break;
           case 'O':
-#if (SIZEOF_CURL_OFF_T > SIZEOF_LONG)
+#if (CURL_SIZEOF_CURL_OFF_T > CURL_SIZEOF_LONG)
             flags |= FLAGS_LONGLONG;
 #else
           flags |= FLAGS_LONG;
@@ -621,7 +627,7 @@
     int is_neg;
 
     /* Base of a number to be written.  */
-    unsigned long base;
+    long base;
 
     /* Integral values to be written.  */
     mp_uintmax_t num;
@@ -916,25 +922,12 @@
       *fptr = 0;
 
       if (width >= 0) {
-        if (width >= (long)sizeof(work))
-          width = sizeof(work) - 1;
         /* RECURSIVE USAGE */
         len = curl_msnprintf(fptr, left, "%ld", width);
         fptr += len;
         left -= len;
       }
       if (prec >= 0) {
-        /* for each digit in the integer part, we can have one less
-           precision */
-        size_t maxprec = sizeof(work) - 2;
-        double val = p->data.dnum;
-        while (val >= 10.0) {
-          val /= 10;
-          maxprec--;
-        }
-
-        if (prec > (long)maxprec)
-          prec = (long)maxprec - 1;
         /* RECURSIVE USAGE */
         len = curl_msnprintf(fptr, left, ".%ld", prec);
         fptr += len;
@@ -954,7 +947,7 @@
       /* NOTE NOTE NOTE!! Not all sprintf implementations return number of
          output characters */
       (sprintf)(work, formatbuf, p->data.dnum);
-      DEBUGASSERT(strlen(work) <= sizeof(work));
+
       for (fptr = work; *fptr; fptr++)
         OUTCHAR(*fptr);
     } break;
@@ -1084,8 +1077,8 @@
   if (info.alloc) {
     info.buffer[info.len] = 0; /* we terminate this with a zero byte */
     return info.buffer;
-  }
-  return strdup("");
+  } else
+    return strdup("");
 }
 
 char *curl_mvaprintf(const char *format, va_list ap_save) {
@@ -1107,8 +1100,8 @@
   if (info.alloc) {
     info.buffer[info.len] = 0; /* we terminate this with a zero byte */
     return info.buffer;
-  }
-  return strdup("");
+  } else
+    return strdup("");
 }
 
 static int storebuffer(int output, FILE *data) {
