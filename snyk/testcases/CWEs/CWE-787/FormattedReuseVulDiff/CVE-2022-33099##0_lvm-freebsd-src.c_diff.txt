--- /home/V1SCAN/CWE-787/FormattedUsed/lvm-freebsd-src.c	2023-12-13 06:17:19.089354869 +0900
+++ /home/V1SCAN/CWE-787/FormattedVul/OLD##CVE-2022-33099##0##lua@@lua##lvm.c	2023-12-13 06:17:21.389353163 +0900
@@ -49,7 +49,6 @@
 ** 'l_intfitsf' checks whether a given integer is in the range that
 ** can be converted to a float without rounding. Used in comparisons.
 */
-#if !defined(l_intfitsf) && LUA_FLOAT_TYPE != LUA_FLOAT_INT64
 
 /* number of bits in the mantissa of a float */
 #define NBM (l_floatatt(MANT_DIG))
@@ -76,12 +75,6 @@
 
 #endif
 
-#endif /* !defined(l_intfitsf) && LUA_FLOAT_TYPE != LUA_FLOAT_INT64 */
-
-#ifndef l_intfitsf
-#define l_intfitsf(i) 1
-#endif
-
 /*
 ** Try to convert a value from string to a number value.
 ** If the value is not a string or is a string not representing
@@ -230,11 +223,11 @@
     lua_Number init;
     lua_Number limit;
     lua_Number step;
-    if (unlikely(!tonumber(plimit, &limit)))
+    if (l_unlikely(!tonumber(plimit, &limit)))
       luaG_forerror(L, plimit, "limit");
-    if (unlikely(!tonumber(pstep, &step)))
+    if (l_unlikely(!tonumber(pstep, &step)))
       luaG_forerror(L, pstep, "step");
-    if (unlikely(!tonumber(pinit, &init)))
+    if (l_unlikely(!tonumber(pinit, &init)))
       luaG_forerror(L, pinit, "initial value");
     if (step == 0)
       luaG_runerror(L, "'for' step is zero");
@@ -282,7 +275,7 @@
     if (slot == NULL) { /* 't' is not a table? */
       lua_assert(!ttistable(t));
       tm = luaT_gettmbyobj(L, t, TM_INDEX);
-      if (unlikely(notm(tm)))
+      if (l_unlikely(notm(tm)))
         luaG_typeerror(L, t, "index"); /* no metamethod */
       /* else will try the metamethod */
     } else { /* 't' is a table */
@@ -325,10 +318,7 @@
       lua_assert(isempty(slot));                 /* slot must be empty */
       tm = fasttm(L, h->metatable, TM_NEWINDEX); /* get metamethod */
       if (tm == NULL) {                          /* no metamethod? */
-        if (isabstkey(slot))                     /* no previous entry? */
-          slot = luaH_newkey(L, h, key);         /* create one */
-        /* no metamethod and (now) there is an entry with given key */
-        setobj2t(L, cast(TValue *, slot), val); /* set its new value */
+        luaH_finishset(L, h, key, slot, val);    /* set new value */
         invalidateTMcache(h);
         luaC_barrierback(L, obj2gco(h), val);
         return;
@@ -336,7 +326,7 @@
       /* else will try the metamethod */
     } else { /* not a table; check metamethod */
       tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);
-      if (unlikely(notm(tm)))
+      if (l_unlikely(notm(tm)))
         luaG_typeerror(L, t, "index");
     }
     /* try the metamethod */
@@ -397,7 +387,7 @@
 ** from float to int.)
 ** When 'f' is NaN, comparisons must result in false.
 */
-static int LTintfloat(lua_Integer i, lua_Number f) {
+l_sinline int LTintfloat(lua_Integer i, lua_Number f) {
   if (l_intfitsf(i))
     return luai_numlt(cast_num(i), f); /* compare them as floats */
   else {                               /* i < f <=> i < ceil(f) */
@@ -413,7 +403,7 @@
 ** Check whether integer 'i' is less than or equal to float 'f'.
 ** See comments on previous function.
 */
-static int LEintfloat(lua_Integer i, lua_Number f) {
+l_sinline int LEintfloat(lua_Integer i, lua_Number f) {
   if (l_intfitsf(i))
     return luai_numle(cast_num(i), f); /* compare them as floats */
   else {                               /* i <= f <=> i <= floor(f) */
@@ -429,7 +419,7 @@
 ** Check whether float 'f' is less than integer 'i'.
 ** See comments on previous function.
 */
-static int LTfloatint(lua_Number f, lua_Integer i) {
+l_sinline int LTfloatint(lua_Number f, lua_Integer i) {
   if (l_intfitsf(i))
     return luai_numlt(f, cast_num(i)); /* compare them as floats */
   else {                               /* f < i <=> floor(f) < i */
@@ -445,7 +435,7 @@
 ** Check whether float 'f' is less than or equal to integer 'i'.
 ** See comments on previous function.
 */
-static int LEfloatint(lua_Number f, lua_Integer i) {
+l_sinline int LEfloatint(lua_Number f, lua_Integer i) {
   if (l_intfitsf(i))
     return luai_numle(f, cast_num(i)); /* compare them as floats */
   else {                               /* f <= i <=> ceil(f) <= i */
@@ -460,7 +450,7 @@
 /*
 ** Return 'l < r', for numbers.
 */
-static int LTnum(const TValue *l, const TValue *r) {
+l_sinline int LTnum(const TValue *l, const TValue *r) {
   lua_assert(ttisnumber(l) && ttisnumber(r));
   if (ttisinteger(l)) {
     lua_Integer li = ivalue(l);
@@ -480,7 +470,7 @@
 /*
 ** Return 'l <= r', for numbers.
 */
-static int LEnum(const TValue *l, const TValue *r) {
+l_sinline int LEnum(const TValue *l, const TValue *r) {
   lua_assert(ttisnumber(l) && ttisnumber(r));
   if (ttisinteger(l)) {
     lua_Integer li = ivalue(l);
@@ -549,8 +539,12 @@
     if (ttype(t1) != ttype(t2) || ttype(t1) != LUA_TNUMBER)
       return 0; /* only numbers can be equal with different variants */
     else {      /* two numbers with different variants */
-      lua_Integer i1, i2; /* compare them as integers */
-      return (tointegerns(t1, &i1) && tointegerns(t2, &i2) && i1 == i2);
+      /* One of them is an integer. If the other does not have an
+         integer value, they cannot be equal; otherwise, compare their
+         integer values. */
+      lua_Integer i1, i2;
+      return (luaV_tointegerns(t1, &i1, F2Ieq) &&
+              luaV_tointegerns(t2, &i2, F2Ieq) && i1 == i2);
     }
   }
   /* values have same type and same variant */
@@ -642,7 +636,7 @@
       /* collect total length and number of strings */
       for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {
         size_t l = vslen(s2v(top - n - 1));
-        if (unlikely(l >= (MAX_SIZE / sizeof(char)) - tl))
+        if (l_unlikely(l >= (MAX_SIZE / sizeof(char)) - tl))
           luaG_runerror(L, "string length overflow");
         tl += l;
       }
@@ -685,7 +679,7 @@
   }
   default: { /* try metamethod */
     tm = luaT_gettmbyobj(L, rb, TM_LEN);
-    if (unlikely(notm(tm))) /* no metamethod? */
+    if (l_unlikely(notm(tm))) /* no metamethod? */
       luaG_typeerror(L, rb, "get length of");
     break;
   }
@@ -700,7 +694,7 @@
 ** otherwise 'floor(q) == trunc(q) - 1'.
 */
 lua_Integer luaV_idiv(lua_State *L, lua_Integer m, lua_Integer n) {
-  if (unlikely(l_castS2U(n) + 1u <= 1u)) { /* special cases: -1 or 0 */
+  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) { /* special cases: -1 or 0 */
     if (n == 0)
       luaG_runerror(L, "attempt to divide by zero");
     return intop(-, 0, m); /* n==-1; avoid overflow with 0x80000...//-1 */
@@ -718,7 +712,7 @@
 ** about luaV_idiv.)
 */
 lua_Integer luaV_mod(lua_State *L, lua_Integer m, lua_Integer n) {
-  if (unlikely(l_castS2U(n) + 1u <= 1u)) { /* special cases: -1 or 0 */
+  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) { /* special cases: -1 or 0 */
     if (n == 0)
       luaG_runerror(L, "attempt to perform 'n%%0'");
     return 0; /* m % -1 == 0; avoid overflow with 0x80000...%-1 */
@@ -745,7 +739,7 @@
 /*
 ** Shift left operation. (Shift right just negates 'y'.)
 */
-#define luaV_shiftr(x, y) luaV_shiftl(x, -(y))
+#define luaV_shiftr(x, y) luaV_shiftl(x, intop(-, 0, y))
 
 lua_Integer luaV_shiftl(lua_Integer x, lua_Integer y) {
   if (y < 0) { /* shift right? */
@@ -837,6 +831,19 @@
     luaV_concat(L, total);      /* concat them (may yield again) */
     break;
   }
+  case OP_CLOSE: {     /* yielded closing variables */
+    ci->u.l.savedpc--; /* repeat instruction to close other vars. */
+    break;
+  }
+  case OP_RETURN: { /* yielded closing variables */
+    StkId ra = base + GETARG_A(inst);
+    /* adjust top to signal correct number of returns, in case the
+       return is "up to top" ('isIT') */
+    L->top = ra + ci->u2.nres;
+    /* repeat instruction to close other vars. and complete the return */
+    ci->u.l.savedpc--;
+    break;
+  }
   default: {
     /* only these other opcodes can yield */
     lua_assert(op == OP_TFORCALL || op == OP_CALL || op == OP_TAILCALL ||
@@ -871,6 +878,7 @@
 */
 #define op_arithI(L, iop, fop)                                                 \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     TValue *v1 = vRB(i);                                                       \
     int imm = GETARG_sC(i);                                                    \
     if (ttisinteger(v1)) {                                                     \
@@ -904,6 +912,7 @@
 */
 #define op_arithf(L, fop)                                                      \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     TValue *v1 = vRB(i);                                                       \
     TValue *v2 = vRC(i);                                                       \
     op_arithf_aux(L, v1, v2, fop);                                             \
@@ -914,8 +923,10 @@
 */
 #define op_arithfK(L, fop)                                                     \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     TValue *v1 = vRB(i);                                                       \
     TValue *v2 = KC(i);                                                        \
+    lua_assert(ttisnumber(v2));                                                \
     op_arithf_aux(L, v1, v2, fop);                                             \
   }
 
@@ -924,6 +935,7 @@
 */
 #define op_arith_aux(L, v1, v2, iop, fop)                                      \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     if (ttisinteger(v1) && ttisinteger(v2)) {                                  \
       lua_Integer i1 = ivalue(v1);                                             \
       lua_Integer i2 = ivalue(v2);                                             \
@@ -950,6 +962,7 @@
   {                                                                            \
     TValue *v1 = vRB(i);                                                       \
     TValue *v2 = KC(i);                                                        \
+    lua_assert(ttisnumber(v2));                                                \
     op_arith_aux(L, v1, v2, iop, fop);                                         \
   }
 
@@ -958,6 +971,7 @@
 */
 #define op_bitwiseK(L, op)                                                     \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     TValue *v1 = vRB(i);                                                       \
     TValue *v2 = KC(i);                                                        \
     lua_Integer i1;                                                            \
@@ -973,6 +987,7 @@
 */
 #define op_bitwise(L, op)                                                      \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     TValue *v1 = vRB(i);                                                       \
     TValue *v2 = vRC(i);                                                       \
     lua_Integer i1;                                                            \
@@ -990,6 +1005,7 @@
 */
 #define op_order(L, opi, opn, other)                                           \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     int cond;                                                                  \
     TValue *rb = vRB(i);                                                       \
     if (ttisinteger(s2v(ra)) && ttisinteger(rb)) {                             \
@@ -1009,6 +1025,7 @@
 */
 #define op_orderI(L, opi, opf, inv, tm)                                        \
   {                                                                            \
+    StkId ra = RA(i);                                                          \
     int cond;                                                                  \
     int im = GETARG_sB(i);                                                     \
     if (ttisinteger(s2v(ra)))                                                  \
@@ -1051,7 +1068,7 @@
 
 #define updatestack(ci)                                                        \
   {                                                                            \
-    if (trap) {                                                                \
+    if (l_unlikely(trap)) {                                                    \
       updatebase(ci);                                                          \
       ra = RA(i);                                                              \
     }                                                                          \
@@ -1106,7 +1123,7 @@
 #define ProtectNT(exp) (savepc(L), (exp), updatetrap(ci))
 
 /*
-** Protect code that can only raise errors. (That is, it cannnot change
+** Protect code that can only raise errors. (That is, it cannot change
 ** the stack or hooks.)
 */
 #define halfProtect(exp) (savestate(L, ci), (exp))
@@ -1121,12 +1138,11 @@
 /* fetch an instruction and prepare its execution */
 #define vmfetch()                                                              \
   {                                                                            \
-    if (trap) {                     /* stack reallocation or hooks? */         \
+    if (l_unlikely(trap)) {         /* stack reallocation or hooks? */         \
       trap = luaG_traceexec(L, pc); /* handle hooks */                         \
       updatebase(ci);               /* correct stack */                        \
     }                                                                          \
     i = *(pc++);                                                               \
-    ra = RA(i); /* WARNING: any stack reallocation invalidates 'ra' */         \
   }
 
 #define vmdispatch(o) switch (o)
@@ -1148,7 +1164,7 @@
   cl = clLvalue(s2v(ci->func));
   k = cl->p->k;
   pc = ci->u.l.savedpc;
-  if (trap) {
+  if (l_unlikely(trap)) {
     if (pc == cl->p->code) { /* first instruction (not resuming)? */
       if (cl->p->is_vararg)
         trap = 0; /* hooks will start after VARARGPREP instruction */
@@ -1161,33 +1177,41 @@
   /* main loop of interpreter */
   for (;;) {
     Instruction i; /* instruction being executed */
-    StkId ra;      /* instruction's A register */
     vmfetch();
+#if 0
+      /* low-level line tracing for debugging Lua */
+      printf("line: %d\n", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));
+#endif
     lua_assert(base == ci->func + 1);
-    lua_assert(base <= L->top && L->top < L->stack_last);
+    lua_assert(base <= L->top && L->top <= L->stack_last);
     /* invalidate top for instructions not expecting it */
     lua_assert(isIT(i) || (cast_void(L->top = base), 1));
     vmdispatch(GET_OPCODE(i)) {
       vmcase(OP_MOVE) {
+        StkId ra = RA(i);
         setobjs2s(L, ra, RB(i));
         vmbreak;
       }
       vmcase(OP_LOADI) {
+        StkId ra = RA(i);
         lua_Integer b = GETARG_sBx(i);
         setivalue(s2v(ra), b);
         vmbreak;
       }
       vmcase(OP_LOADF) {
+        StkId ra = RA(i);
         int b = GETARG_sBx(i);
         setfltvalue(s2v(ra), cast_num(b));
         vmbreak;
       }
       vmcase(OP_LOADK) {
+        StkId ra = RA(i);
         TValue *rb = k + GETARG_Bx(i);
         setobj2s(L, ra, rb);
         vmbreak;
       }
       vmcase(OP_LOADKX) {
+        StkId ra = RA(i);
         TValue *rb;
         rb = k + GETARG_Ax(*pc);
         pc++;
@@ -1195,19 +1219,23 @@
         vmbreak;
       }
       vmcase(OP_LOADFALSE) {
+        StkId ra = RA(i);
         setbfvalue(s2v(ra));
         vmbreak;
       }
       vmcase(OP_LFALSESKIP) {
+        StkId ra = RA(i);
         setbfvalue(s2v(ra));
         pc++; /* skip next instruction */
         vmbreak;
       }
       vmcase(OP_LOADTRUE) {
+        StkId ra = RA(i);
         setbtvalue(s2v(ra));
         vmbreak;
       }
       vmcase(OP_LOADNIL) {
+        StkId ra = RA(i);
         int b = GETARG_B(i);
         do {
           setnilvalue(s2v(ra++));
@@ -1215,17 +1243,20 @@
         vmbreak;
       }
       vmcase(OP_GETUPVAL) {
+        StkId ra = RA(i);
         int b = GETARG_B(i);
         setobj2s(L, ra, cl->upvals[b]->v);
         vmbreak;
       }
       vmcase(OP_SETUPVAL) {
+        StkId ra = RA(i);
         UpVal *uv = cl->upvals[GETARG_B(i)];
         setobj(L, uv->v, s2v(ra));
         luaC_barrier(L, uv, s2v(ra));
         vmbreak;
       }
       vmcase(OP_GETTABUP) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *upval = cl->upvals[GETARG_B(i)]->v;
         TValue *rc = KC(i);
@@ -1237,6 +1268,7 @@
         vmbreak;
       }
       vmcase(OP_GETTABLE) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *rb = vRB(i);
         TValue *rc = vRC(i);
@@ -1250,6 +1282,7 @@
         vmbreak;
       }
       vmcase(OP_GETI) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *rb = vRB(i);
         int c = GETARG_C(i);
@@ -1263,6 +1296,7 @@
         vmbreak;
       }
       vmcase(OP_GETFIELD) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *rb = vRB(i);
         TValue *rc = KC(i);
@@ -1286,6 +1320,7 @@
         vmbreak;
       }
       vmcase(OP_SETTABLE) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *rb = vRB(i); /* key (table is in 'ra') */
         TValue *rc = RKC(i); /* value */
@@ -1300,6 +1335,7 @@
         vmbreak;
       }
       vmcase(OP_SETI) {
+        StkId ra = RA(i);
         const TValue *slot;
         int c = GETARG_B(i);
         TValue *rc = RKC(i);
@@ -1313,6 +1349,7 @@
         vmbreak;
       }
       vmcase(OP_SETFIELD) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *rb = KB(i);
         TValue *rc = RKC(i);
@@ -1324,6 +1361,7 @@
         vmbreak;
       }
       vmcase(OP_NEWTABLE) {
+        StkId ra = RA(i);
         int b = GETARG_B(i); /* log2(hash size) + 1 */
         int c = GETARG_C(i); /* array size */
         Table *t;
@@ -1342,6 +1380,7 @@
         vmbreak;
       }
       vmcase(OP_SELF) {
+        StkId ra = RA(i);
         const TValue *slot;
         TValue *rb = vRB(i);
         TValue *rc = RKC(i);
@@ -1398,6 +1437,7 @@
         vmbreak;
       }
       vmcase(OP_SHRI) {
+        StkId ra = RA(i);
         TValue *rb = vRB(i);
         int ic = GETARG_sC(i);
         lua_Integer ib;
@@ -1408,6 +1448,7 @@
         vmbreak;
       }
       vmcase(OP_SHLI) {
+        StkId ra = RA(i);
         TValue *rb = vRB(i);
         int ic = GETARG_sC(i);
         lua_Integer ib;
@@ -1466,6 +1507,7 @@
         vmbreak;
       }
       vmcase(OP_MMBIN) {
+        StkId ra = RA(i);
         Instruction pi = *(pc - 2); /* original arith. expression */
         TValue *rb = vRB(i);
         TMS tm = (TMS)GETARG_C(i);
@@ -1475,6 +1517,7 @@
         vmbreak;
       }
       vmcase(OP_MMBINI) {
+        StkId ra = RA(i);
         Instruction pi = *(pc - 2); /* original arith. expression */
         int imm = GETARG_sB(i);
         TMS tm = (TMS)GETARG_C(i);
@@ -1484,6 +1527,7 @@
         vmbreak;
       }
       vmcase(OP_MMBINK) {
+        StkId ra = RA(i);
         Instruction pi = *(pc - 2); /* original arith. expression */
         TValue *imm = KB(i);
         TMS tm = (TMS)GETARG_C(i);
@@ -1493,6 +1537,7 @@
         vmbreak;
       }
       vmcase(OP_UNM) {
+        StkId ra = RA(i);
         TValue *rb = vRB(i);
         lua_Number nb;
         if (ttisinteger(rb)) {
@@ -1505,6 +1550,7 @@
         vmbreak;
       }
       vmcase(OP_BNOT) {
+        StkId ra = RA(i);
         TValue *rb = vRB(i);
         lua_Integer ib;
         if (tointegerns(rb, &ib)) {
@@ -1514,6 +1560,7 @@
         vmbreak;
       }
       vmcase(OP_NOT) {
+        StkId ra = RA(i);
         TValue *rb = vRB(i);
         if (l_isfalse(rb))
           setbtvalue(s2v(ra));
@@ -1522,10 +1569,12 @@
         vmbreak;
       }
       vmcase(OP_LEN) {
+        StkId ra = RA(i);
         Protect(luaV_objlen(L, ra, vRB(i)));
         vmbreak;
       }
       vmcase(OP_CONCAT) {
+        StkId ra = RA(i);
         int n = GETARG_B(i); /* number of elements to concatenate */
         L->top = ra + n;     /* mark the end of concat operands */
         ProtectNT(luaV_concat(L, n));
@@ -1533,10 +1582,12 @@
         vmbreak;
       }
       vmcase(OP_CLOSE) {
-        Protect(luaF_close(L, ra, LUA_OK));
+        StkId ra = RA(i);
+        Protect(luaF_close(L, ra, LUA_OK, 1));
         vmbreak;
       }
       vmcase(OP_TBC) {
+        StkId ra = RA(i);
         /* create new to-be-closed upvalue */
         halfProtect(luaF_newtbcupval(L, ra));
         vmbreak;
@@ -1546,6 +1597,7 @@
         vmbreak;
       }
       vmcase(OP_EQ) {
+        StkId ra = RA(i);
         int cond;
         TValue *rb = vRB(i);
         Protect(cond = luaV_equalobj(L, s2v(ra), rb));
@@ -1561,6 +1613,7 @@
         vmbreak;
       }
       vmcase(OP_EQK) {
+        StkId ra = RA(i);
         TValue *rb = KB(i);
         /* basic types do not use '__eq'; we can use raw equality */
         int cond = luaV_rawequalobj(s2v(ra), rb);
@@ -1568,6 +1621,7 @@
         vmbreak;
       }
       vmcase(OP_EQI) {
+        StkId ra = RA(i);
         int cond;
         int im = GETARG_sB(i);
         if (ttisinteger(s2v(ra)))
@@ -1596,11 +1650,13 @@
         vmbreak;
       }
       vmcase(OP_TEST) {
+        StkId ra = RA(i);
         int cond = !l_isfalse(s2v(ra));
         docondjump();
         vmbreak;
       }
       vmcase(OP_TESTSET) {
+        StkId ra = RA(i);
         TValue *rb = vRB(i);
         if (l_isfalse(rb) == GETARG_k(i))
           pc++;
@@ -1611,6 +1667,7 @@
         vmbreak;
       }
       vmcase(OP_CALL) {
+        StkId ra = RA(i);
         CallInfo *newci;
         int b = GETARG_B(i);
         int nresults = GETARG_C(i) - 1;
@@ -1622,13 +1679,14 @@
           updatetrap(ci); /* C call; nothing else to be done */
         else {            /* Lua call: run function in this same C frame */
           ci = newci;
-          ci->callstatus = 0; /* call re-uses 'luaV_execute' */
           goto startfunc;
         }
         vmbreak;
       }
       vmcase(OP_TAILCALL) {
+        StkId ra = RA(i);
         int b = GETARG_B(i); /* number of arguments + 1 (function) */
+        int n;               /* number of results when calling a C function */
         int nparams1 = GETARG_C(i);
         /* delta is virtual 'func' - real 'func' (vararg functions) */
         int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;
@@ -1638,40 +1696,31 @@
           b = cast_int(L->top - ra);
         savepc(ci); /* several calls here can raise errors */
         if (TESTARG_k(i)) {
-          /* close upvalues from current call; the compiler ensures
-             that there are no to-be-closed variables here, so this
-             call cannot change the stack */
-          luaF_close(L, base, NOCLOSINGMETH);
+          luaF_closeupval(L, base);      /* close upvalues from current call */
+          lua_assert(L->tbclist < base); /* no pending tbc variables */
           lua_assert(base == ci->func + 1);
         }
-        while (!ttisfunction(s2v(ra))) { /* not a function? */
-          luaD_tryfuncTM(L, ra);         /* try '__call' metamethod */
-          b++;                           /* there is now one extra argument */
-          checkstackGCp(L, 1, ra);
-        }
-        if (!ttisLclosure(s2v(ra))) {       /* C function? */
-          luaD_precall(L, ra, LUA_MULTRET); /* call it */
-          updatetrap(ci);
-          updatestack(ci);   /* stack may have been relocated */
-          ci->func -= delta; /* restore 'func' (if vararg) */
-          luaD_poscall(L, ci, cast_int(L->top - ra)); /* finish caller */
-          updatetrap(ci); /* 'luaD_poscall' can change hooks */
-          goto ret;       /* caller returns after the tail call */
+        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0) /* Lua function? */
+          goto startfunc;         /* execute the callee */
+        else {                    /* C function? */
+          ci->func -= delta;      /* restore 'func' (if vararg) */
+          luaD_poscall(L, ci, n); /* finish caller */
+          updatetrap(ci);         /* 'luaD_poscall' can change hooks */
+          goto ret;               /* caller returns after the tail call */
         }
-        ci->func -= delta;              /* restore 'func' (if vararg) */
-        luaD_pretailcall(L, ci, ra, b); /* prepare call frame */
-        goto startfunc;                 /* execute the callee */
       }
       vmcase(OP_RETURN) {
+        StkId ra = RA(i);
         int n = GETARG_B(i) - 1; /* number of results */
         int nparams1 = GETARG_C(i);
         if (n < 0)                   /* not fixed? */
           n = cast_int(L->top - ra); /* get what is available */
         savepc(ci);
         if (TESTARG_k(i)) { /* may there be open upvalues? */
+          ci->u2.nres = n;  /* save number of returns */
           if (L->top < ci->top)
             L->top = ci->top;
-          luaF_close(L, base, LUA_OK);
+          luaF_close(L, base, CLOSEKTOP, 1);
           updatetrap(ci);
           updatestack(ci);
         }
@@ -1683,22 +1732,24 @@
         goto ret;
       }
       vmcase(OP_RETURN0) {
-        if (L->hookmask) {
+        if (l_unlikely(L->hookmask)) {
+          StkId ra = RA(i);
           L->top = ra;
           savepc(ci);
           luaD_poscall(L, ci, 0); /* no hurry... */
           trap = 1;
         } else { /* do the 'poscall' here */
-          int nres = ci->nresults;
+          int nres;
           L->ci = ci->previous; /* back to caller */
           L->top = base - 1;
-          while (nres-- > 0)
+          for (nres = ci->nresults; l_unlikely(nres > 0); nres--)
             setnilvalue(s2v(L->top++)); /* all results are nil */
         }
         goto ret;
       }
       vmcase(OP_RETURN1) {
-        if (L->hookmask) {
+        if (l_unlikely(L->hookmask)) {
+          StkId ra = RA(i);
           L->top = ra + 1;
           savepc(ci);
           luaD_poscall(L, ci, 1); /* no hurry... */
@@ -1709,10 +1760,11 @@
           if (nres == 0)
             L->top = base - 1; /* asked for no results */
           else {
+            StkId ra = RA(i);
             setobjs2s(L, base - 1, ra); /* at least this result */
             L->top = base;
-            while (--nres > 0) /* complete missing results */
-              setnilvalue(s2v(L->top++));
+            for (; l_unlikely(nres > 1); nres--)
+              setnilvalue(s2v(L->top++)); /* complete missing results */
           }
         }
       ret: /* return from a Lua function */
@@ -1724,6 +1776,7 @@
         }
       }
       vmcase(OP_FORLOOP) {
+        StkId ra = RA(i);
         if (ttisinteger(s2v(ra + 2))) { /* integer loop? */
           lua_Unsigned count = l_castS2U(ivalue(s2v(ra + 1)));
           if (count > 0) { /* still more iterations? */
@@ -1741,12 +1794,14 @@
         vmbreak;
       }
       vmcase(OP_FORPREP) {
+        StkId ra = RA(i);
         savestate(L, ci); /* in case of errors */
         if (forprep(L, ra))
           pc += GETARG_Bx(i) + 1; /* skip the loop */
         vmbreak;
       }
       vmcase(OP_TFORPREP) {
+        StkId ra = RA(i);
         /* create to-be-closed upvalue (if needed) */
         halfProtect(luaF_newtbcupval(L, ra + 3));
         pc += GETARG_Bx(i);
@@ -1755,7 +1810,8 @@
         goto l_tforcall;
       }
       vmcase(OP_TFORCALL) {
-      l_tforcall:
+      l_tforcall : {
+        StkId ra = RA(i);
         /* 'ra' has the iterator function, 'ra + 1' has the state,
            'ra + 2' has the control variable, and 'ra + 3' has the
            to-be-closed variable. The call will use the stack after
@@ -1770,15 +1826,19 @@
         lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));
         goto l_tforloop;
       }
+      }
       vmcase(OP_TFORLOOP) {
-      l_tforloop:
+      l_tforloop : {
+        StkId ra = RA(i);
         if (!ttisnil(s2v(ra + 4))) {    /* continue loop? */
           setobjs2s(L, ra + 2, ra + 4); /* save control variable */
           pc -= GETARG_Bx(i);           /* jump back */
         }
         vmbreak;
       }
+      }
       vmcase(OP_SETLIST) {
+        StkId ra = RA(i);
         int n = GETARG_B(i);
         unsigned int last = GETARG_C(i);
         Table *h = hvalue(s2v(ra));
@@ -1802,19 +1862,21 @@
         vmbreak;
       }
       vmcase(OP_CLOSURE) {
+        StkId ra = RA(i);
         Proto *p = cl->p->p[GETARG_Bx(i)];
         halfProtect(pushclosure(L, p, cl->upvals, base, ra));
         checkGC(L, ra + 1);
         vmbreak;
       }
       vmcase(OP_VARARG) {
+        StkId ra = RA(i);
         int n = GETARG_C(i) - 1; /* required results */
         Protect(luaT_getvarargs(L, ci, ra, n));
         vmbreak;
       }
       vmcase(OP_VARARGPREP) {
         ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));
-        if (trap) {
+        if (l_unlikely(trap)) { /* previous "Protect" updated trap */
           luaD_hookcall(L, ci);
           L->oldpc = 1; /* next opcode will be seen as a "new" line */
         }
