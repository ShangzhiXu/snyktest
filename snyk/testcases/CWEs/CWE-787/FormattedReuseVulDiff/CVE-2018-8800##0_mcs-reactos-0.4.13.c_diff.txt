--- /home/V1SCAN/CWE-787/FormattedUsed/mcs-reactos-0.4.13.c	2023-12-13 06:17:19.099354823 +0900
+++ /home/V1SCAN/CWE-787/FormattedVul/OLD##CVE-2018-8800##0##rdesktop@@rdesktop##mcs.c	2023-12-13 06:17:20.399353187 +0900
@@ -1,11 +1,13 @@
 /* -*- c-basic-offset: 8 -*-
    rdesktop: A Remote Desktop Protocol client.
    Protocol services - Multipoint Communications Service
-   Copyright (C) Matthew Chapman 1999-2005
+   Copyright (C) Matthew Chapman <matthewc.unsw.edu.au> 1999-2008
+   Copyright 2005-2011 Peter Astrand <astrand@cendio.se> for Cendio AB
+   Copyright 2018 Henrik Andersson <hean01@cendio.com> for Cendio AB
 
-   This program is free software; you can redistribute it and/or modify
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
+   the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -13,61 +15,15 @@
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "rdesktop.h"
 
-/* Parse an ASN.1 BER header */
-static BOOL ber_parse_header(STREAM s, int tagval, int *length) {
-  int tag, len;
-
-  if (tagval > 0xff) {
-    in_uint16_be(s, tag);
-  } else {
-    in_uint8(s, tag)
-  }
-
-  if (tag != tagval) {
-    error("expected tag %d, got %d\n", tagval, tag);
-    return False;
-  }
-
-  in_uint8(s, len);
-
-  if (len & 0x80) {
-    len &= ~0x80;
-    *length = 0;
-    while (len--)
-      next_be(s, *length);
-  } else
-    *length = len;
-
-  return s_check(s);
-}
-
-/* Output an ASN.1 BER header */
-static void ber_out_header(STREAM s, int tagval, int length) {
-  if (tagval > 0xff) {
-    out_uint16_be(s, tagval);
-  } else {
-    out_uint8(s, tagval);
-  }
-
-  if (length >= 0x80) {
-    out_uint8(s, 0x82);
-    out_uint16_be(s, length);
-  } else
-    out_uint8(s, length);
-}
-
-/* Output an ASN.1 BER integer */
-static void ber_out_integer(STREAM s, int value) {
-  ber_out_header(s, BER_TAG_INTEGER, 2);
-  out_uint16_be(s, value);
-}
+uint16 g_mcs_userid;
+extern VCHANNEL g_channels[];
+extern unsigned int g_num_channels;
 
 /* Output a DOMAIN_PARAMS structure (ASN.1 BER) */
 static void mcs_out_domain_params(STREAM s, int max_channels, int max_users,
@@ -84,7 +40,7 @@
 }
 
 /* Parse a DOMAIN_PARAMS structure (ASN.1 BER) */
-static BOOL mcs_parse_domain_params(STREAM s) {
+static RD_BOOL mcs_parse_domain_params(STREAM s) {
   int length;
 
   ber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);
@@ -94,15 +50,12 @@
 }
 
 /* Send an MCS_CONNECT_INITIAL message (ASN.1 BER) */
-static BOOL mcs_send_connect_initial(RDPCLIENT *This, STREAM mcs_data) {
-  int datalen = (uint16)(mcs_data->end - mcs_data->data);
+static void mcs_send_connect_initial(STREAM mcs_data) {
+  int datalen = mcs_data->end - mcs_data->data;
   int length = 9 + 3 * 34 + 4 + datalen;
   STREAM s;
-
-  s = iso_init(This, length + 5);
-
-  if (s == NULL)
-    return False;
+  logger(Protocol, Debug, "%s()", __func__);
+  s = iso_init(length + 5);
 
   ber_out_header(s, MCS_CONNECT_INITIAL, length);
   ber_out_header(s, BER_TAG_OCTET_STRING, 1); /* calling domain */
@@ -121,16 +74,21 @@
   out_uint8p(s, mcs_data->data, datalen);
 
   s_mark_end(s);
-  return iso_send(This, s);
+  iso_send(s);
 }
 
 /* Expect a MCS_CONNECT_RESPONSE message (ASN.1 BER) */
-static BOOL mcs_recv_connect_response(RDPCLIENT *This, STREAM mcs_data) {
+static RD_BOOL mcs_recv_connect_response(STREAM mcs_data) {
+  UNUSED(mcs_data);
   uint8 result;
   int length;
   STREAM s;
+  RD_BOOL is_fastpath;
+  uint8 fastpath_hdr;
+
+  logger(Protocol, Debug, "%s()", __func__);
+  s = iso_recv(&is_fastpath, &fastpath_hdr);
 
-  s = iso_recv(This, NULL);
   if (s == NULL)
     return False;
 
@@ -139,7 +97,7 @@
   ber_parse_header(s, BER_TAG_RESULT, &length);
   in_uint8(s, result);
   if (result != 0) {
-    error("MCS connect: %d\n", result);
+    logger(Protocol, Error, "mcs_recv_connect_response(), result=%d", result);
     return False;
   }
 
@@ -149,13 +107,12 @@
 
   ber_parse_header(s, BER_TAG_OCTET_STRING, &length);
 
-  sec_process_mcs_data(This, s);
+  sec_process_mcs_data(s);
   /*
      if (length > mcs_data->size)
      {
-     error("MCS data length %d, expected %d\n", length,
-     mcs_data->size);
-     length = mcs_data->size;
+     logger(Protocol, Error, "mcs_recv_connect_response(), expected length=%d,
+     got %d",length, mcs_data->size); length = mcs_data->size;
      }
 
      in_uint8a(s, mcs_data->data, length);
@@ -166,55 +123,55 @@
 }
 
 /* Send an EDrq message (ASN.1 PER) */
-static BOOL mcs_send_edrq(RDPCLIENT *This) {
+static void mcs_send_edrq(void) {
   STREAM s;
-
-  s = iso_init(This, 5);
-
-  if (s == NULL)
-    return False;
+  logger(Protocol, Debug, "%s()", __func__);
+  s = iso_init(5);
 
   out_uint8(s, (MCS_EDRQ << 2));
   out_uint16_be(s, 1); /* height */
   out_uint16_be(s, 1); /* interval */
 
   s_mark_end(s);
-  return iso_send(This, s);
+  iso_send(s);
 }
 
 /* Send an AUrq message (ASN.1 PER) */
-static BOOL mcs_send_aurq(RDPCLIENT *This) {
+static void mcs_send_aurq(void) {
   STREAM s;
-
-  s = iso_init(This, 1);
-
-  if (s == NULL)
-    return False;
+  logger(Protocol, Debug, "%s()", __func__);
+  s = iso_init(1);
 
   out_uint8(s, (MCS_AURQ << 2));
 
   s_mark_end(s);
-  return iso_send(This, s);
+  iso_send(s);
 }
 
 /* Expect a AUcf message (ASN.1 PER) */
-static BOOL mcs_recv_aucf(RDPCLIENT *This, uint16 *mcs_userid) {
+static RD_BOOL mcs_recv_aucf(uint16 *mcs_userid) {
+  RD_BOOL is_fastpath;
+  uint8 fastpath_hdr;
   uint8 opcode, result;
   STREAM s;
 
-  s = iso_recv(This, NULL);
+  logger(Protocol, Debug, "%s()", __func__);
+  s = iso_recv(&is_fastpath, &fastpath_hdr);
+
   if (s == NULL)
     return False;
 
   in_uint8(s, opcode);
   if ((opcode >> 2) != MCS_AUCF) {
-    error("expected AUcf, got %d\n", opcode);
+    logger(Protocol, Error, "mcs_recv_aucf(), expected opcode AUcf, got %d",
+           opcode);
     return False;
   }
 
   in_uint8(s, result);
   if (result != 0) {
-    error("AUrq: %d\n", result);
+    logger(Protocol, Error, "mcs_recv_aucf(), expected result 0, got %d",
+           result);
     return False;
   }
 
@@ -225,42 +182,45 @@
 }
 
 /* Send a CJrq message (ASN.1 PER) */
-static BOOL mcs_send_cjrq(RDPCLIENT *This, uint16 chanid) {
+static void mcs_send_cjrq(uint16 chanid) {
   STREAM s;
 
-  DEBUG_RDP5(("Sending CJRQ for channel #%d\n", chanid));
+  logger(Protocol, Debug, "mcs_send_cjrq(), chanid=%d", chanid);
 
-  s = iso_init(This, 5);
-
-  if (s == NULL)
-    return False;
+  s = iso_init(5);
 
   out_uint8(s, (MCS_CJRQ << 2));
-  out_uint16_be(s, This->mcs_userid);
+  out_uint16_be(s, g_mcs_userid);
   out_uint16_be(s, chanid);
 
   s_mark_end(s);
-  return iso_send(This, s);
+  iso_send(s);
 }
 
 /* Expect a CJcf message (ASN.1 PER) */
-static BOOL mcs_recv_cjcf(RDPCLIENT *This) {
+static RD_BOOL mcs_recv_cjcf(void) {
+  RD_BOOL is_fastpath;
+  uint8 fastpath_hdr;
   uint8 opcode, result;
   STREAM s;
 
-  s = iso_recv(This, NULL);
+  logger(Protocol, Debug, "%s()", __func__);
+  s = iso_recv(&is_fastpath, &fastpath_hdr);
+
   if (s == NULL)
     return False;
 
   in_uint8(s, opcode);
   if ((opcode >> 2) != MCS_CJCF) {
-    error("expected CJcf, got %d\n", opcode);
+    logger(Protocol, Error, "mcs_recv_cjcf(), expected opcode CJcf, got %d",
+           opcode);
     return False;
   }
 
   in_uint8(s, result);
   if (result != 0) {
-    error("CJrq: %d\n", result);
+    logger(Protocol, Error, "mcs_recv_cjcf(), expected result 0, got %d",
+           result);
     return False;
   }
 
@@ -271,60 +231,79 @@
   return s_check_end(s);
 }
 
+/* Send MCS Disconnect provider ultimatum PDU */
+void mcs_send_dpu(unsigned short reason) {
+  STREAM s, contents;
+
+  logger(Protocol, Debug, "mcs_send_dpu(), reason=%d", reason);
+
+  contents = malloc(sizeof(struct stream));
+  memset(contents, 0, sizeof(struct stream));
+  s_realloc(contents, 6);
+  s_reset(contents);
+  ber_out_integer(contents, reason); /* Reason */
+  ber_out_sequence(contents,
+                   NULL); /* SEQUENCE OF NonStandradParameters OPTIONAL */
+  s_mark_end(contents);
+
+  s = iso_init(8);
+  ber_out_sequence(s, contents);
+  s_free(contents);
+
+  s_mark_end(s);
+
+  iso_send(s);
+}
+
 /* Initialise an MCS transport data packet */
 STREAM
-mcs_init(RDPCLIENT *This, int length) {
+mcs_init(int length) {
   STREAM s;
 
-  s = iso_init(This, length + 8);
-
-  if (s == NULL)
-    return NULL;
-
+  s = iso_init(length + 8);
   s_push_layer(s, mcs_hdr, 8);
 
   return s;
 }
 
 /* Send an MCS transport data packet to a specific channel */
-BOOL mcs_send_to_channel(RDPCLIENT *This, STREAM s, uint16 channel) {
+void mcs_send_to_channel(STREAM s, uint16 channel) {
   uint16 length;
 
   s_pop_layer(s, mcs_hdr);
-  length = (uint16)(s->end - s->p - 8);
+  length = s->end - s->p - 8;
   length |= 0x8000;
 
   out_uint8(s, (MCS_SDRQ << 2));
-  out_uint16_be(s, This->mcs_userid);
+  out_uint16_be(s, g_mcs_userid);
   out_uint16_be(s, channel);
   out_uint8(s, 0x70); /* flags */
   out_uint16_be(s, length);
 
-  return iso_send(This, s);
+  iso_send(s);
 }
 
 /* Send an MCS transport data packet to the global channel */
-BOOL mcs_send(RDPCLIENT *This, STREAM s) {
-  return mcs_send_to_channel(This, s, MCS_GLOBAL_CHANNEL);
-}
+void mcs_send(STREAM s) { mcs_send_to_channel(s, MCS_GLOBAL_CHANNEL); }
 
 /* Receive an MCS transport data packet */
 STREAM
-mcs_recv(RDPCLIENT *This, uint16 *channel, uint8 *rdpver) {
+mcs_recv(uint16 *channel, RD_BOOL *is_fastpath, uint8 *fastpath_hdr) {
   uint8 opcode, appid, length;
   STREAM s;
 
-  s = iso_recv(This, rdpver);
+  s = iso_recv(is_fastpath, fastpath_hdr);
   if (s == NULL)
     return NULL;
-  if (rdpver != NULL)
-    if (*rdpver != 3)
-      return s;
+
+  if (*is_fastpath == True)
+    return s;
+
   in_uint8(s, opcode);
   appid = opcode >> 2;
   if (appid != MCS_SDIN) {
     if (appid != MCS_DPUM) {
-      error("expected data, got %d\n", opcode);
+      logger(Protocol, Error, "mcs_recv(), expected data, got %d", opcode);
     }
     return NULL;
   }
@@ -337,84 +316,58 @@
   return s;
 }
 
-/* Establish a connection up to the MCS layer */
-BOOL mcs_connect(RDPCLIENT *This, char *server, char *cookie, STREAM mcs_data) {
-  unsigned int i;
-
-  if (!iso_connect(This, server, cookie))
-    return False;
-
-  if (!mcs_send_connect_initial(This, mcs_data) ||
-      !mcs_recv_connect_response(This, mcs_data))
-    goto error;
-
-  if (!mcs_send_edrq(This) || !mcs_send_aurq(This))
-    goto error;
-
-  if (!mcs_recv_aucf(This, &This->mcs_userid))
-    goto error;
-
-  if (!mcs_send_cjrq(This, This->mcs_userid + MCS_USERCHANNEL_BASE) ||
-      !mcs_recv_cjcf(This))
-    goto error;
-
-  if (!mcs_send_cjrq(This, MCS_GLOBAL_CHANNEL) || !mcs_recv_cjcf(This))
-    goto error;
-
-  for (i = 0; i < This->num_channels; i++) {
-    if (!mcs_send_cjrq(This, MCS_GLOBAL_CHANNEL + 1 + i) ||
-        !mcs_recv_cjcf(This))
-      goto error;
-  }
-  return True;
-
-error:
-  iso_disconnect(This);
-  return False;
+RD_BOOL
+mcs_connect_start(char *server, char *username, char *domain, char *password,
+                  RD_BOOL reconnect, uint32 *selected_protocol) {
+  logger(Protocol, Debug, "%s()", __func__);
+  return iso_connect(server, username, domain, password, reconnect,
+                     selected_protocol);
 }
 
-/* Establish a connection up to the MCS layer */
-BOOL mcs_reconnect(RDPCLIENT *This, char *server, char *cookie,
-                   STREAM mcs_data) {
+RD_BOOL
+mcs_connect_finalize(STREAM mcs_data) {
   unsigned int i;
 
-  if (!iso_reconnect(This, server, cookie))
-    return False;
-
-  if (!mcs_send_connect_initial(This, mcs_data) ||
-      !mcs_recv_connect_response(This, mcs_data))
+  logger(Protocol, Debug, "%s()", __func__);
+  mcs_send_connect_initial(mcs_data);
+  if (!mcs_recv_connect_response(mcs_data))
     goto error;
 
-  if (!mcs_send_edrq(This) || !mcs_send_aurq(This))
-    goto error;
+  mcs_send_edrq();
 
-  if (!mcs_recv_aucf(This, &This->mcs_userid))
+  mcs_send_aurq();
+  if (!mcs_recv_aucf(&g_mcs_userid))
     goto error;
 
-  if (!mcs_send_cjrq(This, This->mcs_userid + MCS_USERCHANNEL_BASE) ||
-      !mcs_recv_cjcf(This))
+  mcs_send_cjrq(g_mcs_userid + MCS_USERCHANNEL_BASE);
+
+  if (!mcs_recv_cjcf())
     goto error;
 
-  if (!mcs_send_cjrq(This, MCS_GLOBAL_CHANNEL) || !mcs_recv_cjcf(This))
+  mcs_send_cjrq(MCS_GLOBAL_CHANNEL);
+  if (!mcs_recv_cjcf())
     goto error;
 
-  for (i = 0; i < This->num_channels; i++) {
-    if (!mcs_send_cjrq(This, MCS_GLOBAL_CHANNEL + 1 + i) ||
-        !mcs_recv_cjcf(This))
+  for (i = 0; i < g_num_channels; i++) {
+    mcs_send_cjrq(g_channels[i].mcs_id);
+    if (!mcs_recv_cjcf())
       goto error;
   }
   return True;
 
 error:
-  iso_disconnect(This);
+  iso_disconnect();
   return False;
 }
 
 /* Disconnect from the MCS layer */
-void mcs_disconnect(RDPCLIENT *This) { iso_disconnect(This); }
+void mcs_disconnect(int reason) {
+  mcs_send_dpu(reason);
+  iso_disconnect();
+}
 
 /* reset the state of the mcs layer */
-void mcs_reset_state(RDPCLIENT *This) {
-  This->mcs_userid = 0;
-  iso_reset_state(This);
+void mcs_reset_state(void) {
+  g_mcs_userid = 0;
+  iso_reset_state();
 }
