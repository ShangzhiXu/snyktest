--- /home/V1SCAN/CWE-787/FormattedUsed/seamless-reactos-0.4.13.c	2023-12-13 06:17:19.239354209 +0900
+++ /home/V1SCAN/CWE-787/FormattedVul/OLD##CVE-2018-8800##0##rdesktop@@rdesktop##seamless.c	2023-12-13 06:17:20.509353182 +0900
@@ -1,11 +1,13 @@
 /* -*- c-basic-offset: 8 -*-
    rdesktop: A Remote Desktop Protocol client.
    Seamless Windows support
-   Copyright (C) Peter Astrand <astrand@cendio.se> 2005-2006
+   Copyright 2005-2008 Peter Astrand <astrand@cendio.se> for Cendio AB
+   Copyright 2007-2008 Pierre Ossman <ossman@cendio.se> for Cendio AB
+   Copyright 2013-2017 Henrik Andersson  <hean01@cendio.se> for Cendio AB
 
-   This program is free software; you can redistribute it and/or modify
+   This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
+   the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -13,22 +15,19 @@
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 
 #include "rdesktop.h"
 #include <assert.h>
 #include <stdarg.h>
 
-/* #define WITH_DEBUG_SEAMLESS */
-
-#ifdef WITH_DEBUG_SEAMLESS
-#define DEBUG_SEAMLESS(args) printf args;
-#else
-#define DEBUG_SEAMLESS(args)
-#endif
+extern RD_BOOL g_seamless_rdp;
+static VCHANNEL *seamless_channel;
+static unsigned int seamless_serial;
+static char *seamless_rest = NULL;
+static char icon_buf[1024];
 
 static char *seamless_get_token(char **s) {
   char *comma, *head;
@@ -48,20 +47,20 @@
   return head;
 }
 
-static BOOL seamless_process_line(RDPCLIENT *This, const char *line,
-                                  void *data) {
+static RD_BOOL seamless_process_line(const char *line, void *data) {
+  UNUSED(data);
   char *p, *l;
-  char *tok1, *tok2, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;
+  char *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;
   unsigned long id, flags;
   char *endptr;
 
   l = xstrdup(line);
   p = l;
 
-  DEBUG_SEAMLESS(("seamlessrdp got:%s\n", p));
+  logger(Core, Debug, "seamless_process_line(), got '%s'", p);
 
   tok1 = seamless_get_token(&p);
-  tok2 = seamless_get_token(&p);
+  (void)seamless_get_token(&p);
   tok3 = seamless_get_token(&p);
   tok4 = seamless_get_token(&p);
   tok5 = seamless_get_token(&p);
@@ -90,7 +89,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_create_window(This, id, group, parent, flags);
+    ui_seamless_create_window(id, group, parent, flags);
   } else if (!strcmp("DESTROY", tok1)) {
     if (!tok4)
       return False;
@@ -103,7 +102,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_destroy_window(This, id, flags);
+    ui_seamless_destroy_window(id, flags);
 
   } else if (!strcmp("DESTROYGRP", tok1)) {
     if (!tok4)
@@ -117,9 +116,64 @@
     if (*endptr)
       return False;
 
-    ui_seamless_destroy_group(This, id, flags);
+    ui_seamless_destroy_group(id, flags);
   } else if (!strcmp("SETICON", tok1)) {
-    unimpl("SeamlessRDP SETICON1\n");
+    int chunk, width, height, len;
+    char byte[3];
+
+    if (!tok8)
+      return False;
+
+    id = strtoul(tok3, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    chunk = strtoul(tok4, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    width = strtoul(tok6, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    height = strtoul(tok7, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    byte[2] = '\0';
+    len = 0;
+    while (*tok8 != '\0') {
+      byte[0] = *tok8;
+      tok8++;
+      if (*tok8 == '\0')
+        return False;
+      byte[1] = *tok8;
+      tok8++;
+
+      icon_buf[len] = strtol(byte, NULL, 16);
+      len++;
+    }
+
+    ui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);
+  } else if (!strcmp("DELICON", tok1)) {
+    int width, height;
+
+    if (!tok6)
+      return False;
+
+    id = strtoul(tok3, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    width = strtoul(tok5, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    height = strtoul(tok6, &endptr, 0);
+    if (*endptr)
+      return False;
+
+    ui_seamless_delicon(id, tok4, width, height);
   } else if (!strcmp("POSITION", tok1)) {
     int x, y, width, height;
 
@@ -148,7 +202,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_move_window(This, id, x, y, width, height, flags);
+    ui_seamless_move_window(id, x, y, width, height, flags);
   } else if (!strcmp("ZCHANGE", tok1)) {
     unsigned long behind;
 
@@ -164,7 +218,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_restack_window(This, id, behind, flags);
+    ui_seamless_restack_window(id, behind, flags);
   } else if (!strcmp("TITLE", tok1)) {
     if (!tok5)
       return False;
@@ -177,7 +231,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_settitle(This, id, tok4, flags);
+    ui_seamless_settitle(id, tok4, flags);
   } else if (!strcmp("STATE", tok1)) {
     unsigned int state;
 
@@ -196,9 +250,9 @@
     if (*endptr)
       return False;
 
-    ui_seamless_setstate(This, id, state, flags);
+    ui_seamless_setstate(id, state, flags);
   } else if (!strcmp("DEBUG", tok1)) {
-    DEBUG_SEAMLESS(("SeamlessRDP:%s\n", line));
+    logger(Core, Debug, "seamless_process_line(), %s", line);
   } else if (!strcmp("SYNCBEGIN", tok1)) {
     if (!tok3)
       return False;
@@ -207,7 +261,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_syncbegin(This, flags);
+    ui_seamless_syncbegin(flags);
   } else if (!strcmp("SYNCEND", tok1)) {
     if (!tok3)
       return False;
@@ -225,7 +279,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_begin(This, !!(flags & SEAMLESSRDP_HELLO_HIDDEN));
+    ui_seamless_begin(!!(flags & SEAMLESSRDP_HELLO_HIDDEN));
   } else if (!strcmp("ACK", tok1)) {
     unsigned int serial;
 
@@ -233,7 +287,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_ack(This, serial);
+    ui_seamless_ack(serial);
   } else if (!strcmp("HIDE", tok1)) {
     if (!tok3)
       return False;
@@ -242,7 +296,7 @@
     if (*endptr)
       return False;
 
-    ui_seamless_hide_desktop(This);
+    ui_seamless_hide_desktop();
   } else if (!strcmp("UNHIDE", tok1)) {
     if (!tok3)
       return False;
@@ -251,61 +305,62 @@
     if (*endptr)
       return False;
 
-    ui_seamless_unhide_desktop(This);
+    ui_seamless_unhide_desktop();
   }
 
   xfree(l);
   return True;
 }
 
-static BOOL seamless_line_handler(RDPCLIENT *This, const char *line,
-                                  void *data) {
-  if (!seamless_process_line(This, line, data)) {
-    warning("SeamlessRDP: Invalid request:%s\n", line);
+static RD_BOOL seamless_line_handler(const char *line, void *data) {
+  if (!seamless_process_line(line, data)) {
+    logger(Core, Warning, "seamless_line_handler(), invalid request '%s'",
+           line);
   }
   return True;
 }
 
-static void seamless_process(RDPCLIENT *This, STREAM s) {
+static void seamless_process(STREAM s) {
   unsigned int pkglen;
-  static char *rest = NULL;
   char *buf;
 
   pkglen = s->end - s->p;
   /* str_handle_lines requires null terminated strings */
   buf = xmalloc(pkglen + 1);
   STRNCPY(buf, (char *)s->p, pkglen + 1);
-#if 0
-	printf("seamless recv:\n");
-	hexdump(s->p, pkglen);
-#endif
-
-  str_handle_lines(This, buf, &rest, seamless_line_handler, NULL);
+  str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);
 
   xfree(buf);
 }
 
-BOOL seamless_init(RDPCLIENT *This) {
-  if (!This->seamless_rdp)
+RD_BOOL
+seamless_init(void) {
+  if (!g_seamless_rdp)
     return False;
 
-  This->seamless.serial = 0;
+  seamless_serial = 0;
 
-  This->seamless.channel = channel_register(
-      This, "seamrdp", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,
+  seamless_channel = channel_register(
+      "seamrdp", CHANNEL_OPTION_INITIALIZED | CHANNEL_OPTION_ENCRYPT_RDP,
       seamless_process);
-  return (This->seamless.channel != NULL);
+  return (seamless_channel != NULL);
+}
+
+void seamless_reset_state(void) {
+  if (seamless_rest != NULL) {
+    xfree(seamless_rest);
+    seamless_rest = NULL;
+  }
 }
 
-static unsigned int seamless_send(RDPCLIENT *This, const char *command,
-                                  const char *format, ...) {
+static unsigned int seamless_send(const char *command, const char *format,
+                                  ...) {
   STREAM s;
   size_t len;
   va_list argp;
-  char buf[1025];
+  char *escaped, buf[1025];
 
-  len =
-      snprintf(buf, sizeof(buf) - 1, "%s,%u,", command, This->seamless.serial);
+  len = snprintf(buf, sizeof(buf) - 1, "%s,%u,", command, seamless_serial);
 
   assert(len < (sizeof(buf) - 1));
 
@@ -315,53 +370,52 @@
 
   assert(len < (sizeof(buf) - 1));
 
+  escaped = utils_string_escape(buf);
+  len = snprintf(buf, sizeof(buf), "%s", escaped);
+  free(escaped);
+  assert(len < (sizeof(buf) - 1));
+
   buf[len] = '\n';
   buf[len + 1] = '\0';
 
   len++;
 
-  s = channel_init(This, This->seamless.channel, len);
+  s = channel_init(seamless_channel, len);
   out_uint8p(s, buf, len) s_mark_end(s);
 
-  DEBUG_SEAMLESS(("SeamlessRDP sending:%s", buf));
-
-#if 0
-	printf("seamless send:\n");
-	hexdump(s->channel_hdr + 8, s->end - s->channel_hdr - 8);
-#endif
+  logger(Core, Debug, "seamless_send(), sending '%s'", buf);
 
-  channel_send(This, s, This->seamless.channel);
+  channel_send(s, seamless_channel);
 
-  return This->seamless.serial++;
+  return seamless_serial++;
 }
 
-unsigned int seamless_send_sync(RDPCLIENT *This) {
-  if (!This->seamless_rdp)
+unsigned int seamless_send_sync() {
+  if (!g_seamless_rdp)
     return (unsigned int)-1;
 
-  return seamless_send(This, "SYNC", "");
+  return seamless_send("SYNC", "");
 }
 
-unsigned int seamless_send_state(RDPCLIENT *This, unsigned long id,
-                                 unsigned int state, unsigned long flags) {
-  if (!This->seamless_rdp)
+unsigned int seamless_send_state(unsigned long id, unsigned int state,
+                                 unsigned long flags) {
+  if (!g_seamless_rdp)
     return (unsigned int)-1;
 
-  return seamless_send(This, "STATE", "0x%08lx,0x%x,0x%lx", id, state, flags);
+  return seamless_send("STATE", "0x%08lx,0x%x,0x%lx", id, state, flags);
 }
 
-unsigned int seamless_send_position(RDPCLIENT *This, unsigned long id, int x,
-                                    int y, int width, int height,
-                                    unsigned long flags) {
-  return seamless_send(This, "POSITION", "0x%08lx,%d,%d,%d,%d,0x%lx", id, x, y,
-                       width, height, flags);
+unsigned int seamless_send_position(unsigned long id, int x, int y, int width,
+                                    int height, unsigned long flags) {
+  return seamless_send("POSITION", "0x%08lx,%d,%d,%d,%d,0x%lx", id, x, y, width,
+                       height, flags);
 }
 
 /* Update select timeout */
-void seamless_select_timeout(RDPCLIENT *This, struct timeval *tv) {
+void seamless_select_timeout(struct timeval *tv) {
   struct timeval ourtimeout = {0, SEAMLESSRDP_POSITION_TIMER};
 
-  if (This->seamless_rdp) {
+  if (g_seamless_rdp) {
     if (timercmp(&ourtimeout, tv, <)) {
       tv->tv_sec = ourtimeout.tv_sec;
       tv->tv_usec = ourtimeout.tv_usec;
@@ -369,19 +423,44 @@
   }
 }
 
-unsigned int seamless_send_zchange(RDPCLIENT *This, unsigned long id,
-                                   unsigned long below, unsigned long flags) {
-  if (!This->seamless_rdp)
+unsigned int seamless_send_zchange(unsigned long id, unsigned long below,
+                                   unsigned long flags) {
+  if (!g_seamless_rdp)
     return (unsigned int)-1;
 
-  return seamless_send(This, "ZCHANGE", "0x%08lx,0x%08lx,0x%lx", id, below,
-                       flags);
+  return seamless_send("ZCHANGE", "0x%08lx,0x%08lx,0x%lx", id, below, flags);
 }
 
-unsigned int seamless_send_focus(RDPCLIENT *This, unsigned long id,
-                                 unsigned long flags) {
-  if (!This->seamless_rdp)
+unsigned int seamless_send_focus(unsigned long id, unsigned long flags) {
+  if (!g_seamless_rdp)
+    return (unsigned int)-1;
+
+  return seamless_send("FOCUS", "0x%08lx,0x%lx", id, flags);
+}
+
+/* Send client-to-server message to destroy process on the server. */
+unsigned int seamless_send_destroy(unsigned long id) {
+  return seamless_send("DESTROY", "0x%08lx", id);
+}
+
+unsigned int seamless_send_spawn(char *cmdline) {
+  unsigned int res;
+  if (!g_seamless_rdp)
     return (unsigned int)-1;
 
-  return seamless_send(This, "FOCUS", "0x%08lx,0x%lx", id, flags);
+  res = seamless_send("SPAWN", cmdline);
+
+  return res;
+}
+
+unsigned int seamless_send_persistent(RD_BOOL enable) {
+  unsigned int res;
+  if (!g_seamless_rdp)
+    return (unsigned int)-1;
+
+  logger(Core, Debug, "seamless_send_persistent(), %s persistent seamless mode",
+         enable ? "enable" : "disable");
+  res = seamless_send("PERSISTENT", "%d", enable);
+
+  return res;
 }
